/**
 * @version 1.0.8899.38197
 * @copyright anton
 * @compiler Bridge.NET 17.9.40-luna
 */
Bridge.assembly("UnityScriptsCompiler", function ($asm, globals) {
    "use strict";

    /*enemy start.*/
    Bridge.define("enemy", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            gm: null
        },
        methods: {
            /*enemy.attack start.*/
            attack: function () {
                this.gm.enemyAttack();
            },
            /*enemy.attack end.*/


        }
    });
    /*enemy end.*/

    /*gamemanager start.*/
    Bridge.define("gamemanager", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            sprites: null,
            t: null,
            tests: null,
            playerHpbar: null,
            dmg: null,
            hpMax: 0,
            enemyPower: 0,
            playerPower: 0,
            playerPowerMul: 0,
            attackSpeed: 0,
            attackSpeedMul: 0,
            endCover: null,
            curPlayerPower: System.Int64(0),
            curdmg: System.Int64(0),
            curHp: 0,
            ani: null,
            isCheck: false
        },
        props: {
            CanClick: {
                get: function () {
                    return UnityEngine.MonoBehaviour.op_Equality(this.tests[0], null) || UnityEngine.MonoBehaviour.op_Equality(this.tests[1], null);
                }
            }
        },
        ctors: {
            init: function () {
                this.tests = System.Array.init(2, null, test);
                this.hpMax = 30;
                this.enemyPower = 1;
                this.playerPower = 1;
                this.playerPowerMul = 2;
                this.attackSpeed = 1.0;
                this.attackSpeedMul = 1.5;
                this.isCheck = false;
            }
        },
        methods: {
            /*gamemanager.Awake start.*/
            Awake: function () {
                this.endCover.SetActive(false);
                this.curHp = this.hpMax;
                this.curdmg = System.Int64(0);
                this.curPlayerPower = System.Int64(this.playerPower);
                this.isCheck = false;

                for (var i = 0; i < this.t.length; i = (i + 1) | 0) {
                    this.t[i].sprite = this.sprites[((Bridge.Int.div(i, 2)) | 0)];
                }

                for (var i1 = (this.t.length - 1) | 0; i1 >= 0; i1 = (i1 - 1) | 0) {
                    var j = UnityEngine.Random.Range(0, ((i1 + 1) | 0));
                    var temp = this.t[i1].sprite;
                    this.t[i1].sprite = this.t[j].sprite;
                    this.t[j].sprite = temp;
                    this.t[i1].img.sprite = this.t[i1].sprite;
                }
            },
            /*gamemanager.Awake end.*/

            /*gamemanager.onClickTest start.*/
            onClickTest: function (t) {
                if (UnityEngine.MonoBehaviour.op_Inequality(this.tests[0], null) && UnityEngine.MonoBehaviour.op_Inequality(this.tests[1], null)) {
                    return;
                }

                if (UnityEngine.MonoBehaviour.op_Equality(this.tests[0], null)) {
                    this.tests[0] = t;
                    return;
                }

                this.tests[1] = t;
            },
            /*gamemanager.onClickTest end.*/

            /*gamemanager.EndProc start.*/
            EndProc: function () {
                var $t;
                if (UnityEngine.MonoBehaviour.op_Inequality(this.tests[0], null) && UnityEngine.MonoBehaviour.op_Inequality(this.tests[1], null) && this.isCheck === false) {
                    this.isCheck = true;
                    this.Check();
                } else if (UnityEngine.MonoBehaviour.op_Inequality(this.tests[0], null) && UnityEngine.MonoBehaviour.op_Inequality(this.tests[1], null)) {
                    this.tests[0] = ($t = null, this.tests[1] = $t, $t);
                    this.isCheck = false;
                }
            },
            /*gamemanager.EndProc end.*/

            /*gamemanager.Check start.*/
            Check: function () {
                if (!Bridge.referenceEquals(this.tests[0].sprite, this.tests[1].sprite)) {
                    this.tests[0].setDisable();
                    this.tests[1].setDisable();

                    return;
                }

                this.tests[0].setClear();
                this.tests[1].setClear();

                this.curPlayerPower = this.curPlayerPower.mul(System.Int64(this.playerPowerMul));
                this.attackSpeed *= this.attackSpeedMul;
                this.ani.SetFloat$1("attackSpeed", this.attackSpeed);
            },
            /*gamemanager.Check end.*/

            /*gamemanager.enemyAttack start.*/
            enemyAttack: function () {
                this.curHp -= this.enemyPower;

                this.playerHpbar.value = this.curHp / this.hpMax;

                if (this.curHp <= 0) {
                    this.endCover.SetActive(true);
                }
            },
            /*gamemanager.enemyAttack end.*/

            /*gamemanager.playerAttack start.*/
            playerAttack: function () {
                this.curdmg = this.curdmg.add(this.curPlayerPower);
                this.dmg.text = Bridge.toString(this.curdmg);
            },
            /*gamemanager.playerAttack end.*/


        }
    });
    /*gamemanager end.*/

    /*IAmAnEmptyScriptJustToMakeCodelessProjectsCompileProperty start.*/
    Bridge.define("IAmAnEmptyScriptJustToMakeCodelessProjectsCompileProperty", {
        inherits: [UnityEngine.MonoBehaviour]
    });
    /*IAmAnEmptyScriptJustToMakeCodelessProjectsCompileProperty end.*/

    /*player start.*/
    Bridge.define("player", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            gm: null
        },
        methods: {
            /*player.hit start.*/
            hit: function () {
                this.gm.playerAttack();
            },
            /*player.hit end.*/


        }
    });
    /*player end.*/

    /*screen start.*/
    Bridge.define("screen", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            canvas: null
        },
        methods: {
            /*screen.Awake start.*/
            Awake: function () {
                this.canvas.referenceResolution = new pc.Vec2( UnityEngine.Screen.width, UnityEngine.Screen.height );
            },
            /*screen.Awake end.*/


        }
    });
    /*screen end.*/

    /*Spine.BoneMatrix start.*/
    Bridge.define("Spine.BoneMatrix", {
        $kind: 4,
        statics: {
            methods: {
                /*Spine.BoneMatrix.CalculateSetupWorld:static start.*/
                /**
                 * Recursively calculates a worldspace bone matrix based on BoneData.
                 *
                 * @static
                 * @public
                 * @this Spine.BoneMatrix
                 * @memberof Spine.BoneMatrix
                 * @param   {spine.BoneData}      boneData
                 * @return  {Spine.BoneMatrix}
                 */
                CalculateSetupWorld: function (boneData) {
                    if (boneData == null) {
                        return Bridge.getDefaultValue(Spine.BoneMatrix);
                    }

                    // End condition: isRootBone
                    if (boneData.parent == null) {
                        return Spine.BoneMatrix.GetInheritedInternal(boneData, Bridge.getDefaultValue(Spine.BoneMatrix));
                    }

                    var result = Spine.BoneMatrix.CalculateSetupWorld(boneData.parent);
                    return Spine.BoneMatrix.GetInheritedInternal(boneData, result.$clone());
                },
                /*Spine.BoneMatrix.CalculateSetupWorld:static end.*/

                /*Spine.BoneMatrix.GetInheritedInternal:static start.*/
                GetInheritedInternal: function (boneData, parentMatrix) {
                    var parent = boneData.parent;
                    if (parent == null) {
                        return new Spine.BoneMatrix.$ctor2(boneData);
                    } // isRootBone

                    var pa = parentMatrix.a, pb = parentMatrix.b, pc = parentMatrix.c, pd = parentMatrix.d;
                    var result = Bridge.getDefaultValue(Spine.BoneMatrix);
                    result.x = pa * boneData.x + pb * boneData.y + parentMatrix.x;
                    result.y = pc * boneData.x + pd * boneData.y + parentMatrix.y;

                    switch (boneData.transformMode) {
                        case spine.BoneData.Normal: 
                            {
                                var rotationY = boneData.rotation + 90 + boneData.shearY;
                                var la = Spine.MathUtils.CosDeg(boneData.rotation + boneData.shearX) * boneData.scaleX;
                                var lb = Spine.MathUtils.CosDeg(rotationY) * boneData.scaleY;
                                var lc = Spine.MathUtils.SinDeg(boneData.rotation + boneData.shearX) * boneData.scaleX;
                                var ld = Spine.MathUtils.SinDeg(rotationY) * boneData.scaleY;
                                result.a = pa * la + pb * lc;
                                result.b = pa * lb + pb * ld;
                                result.c = pc * la + pd * lc;
                                result.d = pc * lb + pd * ld;
                                break;
                            }
                        case spine.BoneData.OnlyTranslation: 
                            {
                                var rotationY1 = boneData.rotation + 90 + boneData.shearY;
                                result.a = Spine.MathUtils.CosDeg(boneData.rotation + boneData.shearX) * boneData.scaleX;
                                result.b = Spine.MathUtils.CosDeg(rotationY1) * boneData.scaleY;
                                result.c = Spine.MathUtils.SinDeg(boneData.rotation + boneData.shearX) * boneData.scaleX;
                                result.d = Spine.MathUtils.SinDeg(rotationY1) * boneData.scaleY;
                                break;
                            }
                        case spine.BoneData.NoRotationOrReflection: 
                            {
                                var s = pa * pa + pc * pc, prx;
                                if (s > 0.0001) {
                                    s = Math.abs(pa * pd - pb * pc) / s;
                                    pb = pc * s;
                                    pd = pa * s;
                                    prx = Spine.MathUtils.Atan2(pc, pa) * Spine.MathUtils.RadDeg;
                                } else {
                                    pa = 0;
                                    pc = 0;
                                    prx = 90 - Spine.MathUtils.Atan2(pd, pb) * Spine.MathUtils.RadDeg;
                                }
                                var rx = boneData.rotation + boneData.shearX - prx;
                                var ry = boneData.rotation + boneData.shearY - prx + 90;
                                var la1 = Spine.MathUtils.CosDeg(rx) * boneData.scaleX;
                                var lb1 = Spine.MathUtils.CosDeg(ry) * boneData.scaleY;
                                var lc1 = Spine.MathUtils.SinDeg(rx) * boneData.scaleX;
                                var ld1 = Spine.MathUtils.SinDeg(ry) * boneData.scaleY;
                                result.a = pa * la1 - pb * lc1;
                                result.b = pa * lb1 - pb * ld1;
                                result.c = pc * la1 + pd * lc1;
                                result.d = pc * lb1 + pd * ld1;
                                break;
                            }
                        case spine.BoneData.NoScale: 
                        case spine.BoneData.NoScaleOrReflection: 
                            {
                                var cos = Spine.MathUtils.CosDeg(boneData.rotation), sin = Spine.MathUtils.SinDeg(boneData.rotation);
                                var za = pa * cos + pb * sin;
                                var zc = pc * cos + pd * sin;
                                var s1 = Math.sqrt(za * za + zc * zc);
                                if (s1 > 1E-05) {
                                    s1 = 1 / s1;
                                }
                                za *= s1;
                                zc *= s1;
                                s1 = Math.sqrt(za * za + zc * zc);
                                var r = 1.57079637 + Spine.MathUtils.Atan2(zc, za);
                                var zb = Spine.MathUtils.Cos(r) * s1;
                                var zd = Spine.MathUtils.Sin(r) * s1;
                                var la2 = Spine.MathUtils.CosDeg(boneData.shearX) * boneData.scaleX;
                                var lb2 = Spine.MathUtils.CosDeg(90 + boneData.shearY) * boneData.scaleY;
                                var lc2 = Spine.MathUtils.SinDeg(boneData.shearX) * boneData.scaleX;
                                var ld2 = Spine.MathUtils.SinDeg(90 + boneData.shearY) * boneData.scaleY;
                                if (boneData.transformMode !== spine.BoneData.NoScaleOrReflection ? pa * pd - pb * pc < 0 : false) {
                                    zb = -zb;
                                    zd = -zd;
                                }
                                result.a = za * la2 + zb * lc2;
                                result.b = za * lb2 + zb * ld2;
                                result.c = zc * la2 + zd * lc2;
                                result.d = zc * lb2 + zd * ld2;
                                break;
                            }
                    }

                    return result.$clone();
                },
                /*Spine.BoneMatrix.GetInheritedInternal:static end.*/

                getDefaultValue: function () { return new Spine.BoneMatrix(); }
            }
        },
        fields: {
            a: 0,
            b: 0,
            c: 0,
            d: 0,
            x: 0,
            y: 0
        },
        ctors: {
            /**
             * Constructor for a local bone matrix based on Setup Pose BoneData.
             *
             * @instance
             * @public
             * @this Spine.BoneMatrix
             * @memberof Spine.BoneMatrix
             * @param   {spine.BoneData}    boneData
             * @return  {void}
             */
            $ctor2: function (boneData) {
                this.$initialize();
                var rotationY = boneData.rotation + 90 + boneData.shearY;
                var rotationX = boneData.rotation + boneData.shearX;

                this.a = Spine.MathUtils.CosDeg(rotationX) * boneData.scaleX;
                this.c = Spine.MathUtils.SinDeg(rotationX) * boneData.scaleX;
                this.b = Spine.MathUtils.CosDeg(rotationY) * boneData.scaleY;
                this.d = Spine.MathUtils.SinDeg(rotationY) * boneData.scaleY;
                this.x = boneData.x;
                this.y = boneData.y;
            },
            /**
             * Constructor for a local bone matrix based on a bone instance's current pose.
             *
             * @instance
             * @public
             * @this Spine.BoneMatrix
             * @memberof Spine.BoneMatrix
             * @param   {Spine.Bone}    bone
             * @return  {void}
             */
            $ctor1: function (bone) {
                this.$initialize();
                var rotationY = bone.rotation + 90 + bone.shearY;
                var rotationX = bone.rotation + bone.shearX;

                this.a = Spine.MathUtils.CosDeg(rotationX) * bone.scaleX;
                this.c = Spine.MathUtils.SinDeg(rotationX) * bone.scaleX;
                this.b = Spine.MathUtils.CosDeg(rotationY) * bone.scaleY;
                this.d = Spine.MathUtils.SinDeg(rotationY) * bone.scaleY;
                this.x = bone.x;
                this.y = bone.y;
            },
            ctor: function () {
                this.$initialize();
            }
        },
        methods: {
            /*Spine.BoneMatrix.TransformMatrix start.*/
            TransformMatrix: function (local) {
                var $t;
                return ($t = new Spine.BoneMatrix.ctor(), $t.a = this.a * local.a + this.b * local.c, $t.b = this.a * local.b + this.b * local.d, $t.c = this.c * local.a + this.d * local.c, $t.d = this.c * local.b + this.d * local.d, $t.x = this.a * local.x + this.b * local.y + this.x, $t.y = this.c * local.x + this.d * local.y + this.y, $t);
            },
            /*Spine.BoneMatrix.TransformMatrix end.*/

            getHashCode: function () {
                var h = Bridge.addHash([3621996792, this.a, this.b, this.c, this.d, this.x, this.y]);
                return h;
            },
            equals: function (o) {
                if (!Bridge.is(o, Spine.BoneMatrix)) {
                    return false;
                }
                return Bridge.equals(this.a, o.a) && Bridge.equals(this.b, o.b) && Bridge.equals(this.c, o.c) && Bridge.equals(this.d, o.d) && Bridge.equals(this.x, o.x) && Bridge.equals(this.y, o.y);
            },
            $clone: function (to) {
                var s = to || new Spine.BoneMatrix();
                s.a = this.a;
                s.b = this.b;
                s.c = this.c;
                s.d = this.d;
                s.x = this.x;
                s.y = this.y;
                return s;
            }
        }
    });
    /*Spine.BoneMatrix end.*/

    /*Spine.SpineSkeletonExtensions start.*/
    Bridge.define("Spine.SpineSkeletonExtensions", {
        statics: {
            methods: {
                /*Spine.SpineSkeletonExtensions.IsWeighted:static start.*/
                IsWeighted: function (va) {
                    return va.bones != null && va.bones.length > 0;
                },
                /*Spine.SpineSkeletonExtensions.IsWeighted:static end.*/

                /*Spine.SpineSkeletonExtensions.InheritsRotation:static start.*/
                InheritsRotation: function (mode) {
                    var RotationBit = 0;
                    return (System.Int64(mode).and(System.Int64((1)))).equals(System.Int64(0));
                },
                /*Spine.SpineSkeletonExtensions.InheritsRotation:static end.*/

                /*Spine.SpineSkeletonExtensions.InheritsScale:static start.*/
                InheritsScale: function (mode) {
                    var ScaleBit = 1;
                    return (System.Int64(mode).and(System.Int64((2)))).equals(System.Int64(0));
                },
                /*Spine.SpineSkeletonExtensions.InheritsScale:static end.*/


            }
        }
    });
    /*Spine.SpineSkeletonExtensions end.*/

    /*Spine.Unity.ActivateBasedOnFlipDirection start.*/
    /** @namespace Spine.Unity */

    /**
     * Utility component to support flipping of 2D hinge chains (chains of HingeJoint2D objects) along
     with the parent skeleton by activating the respective mirrored versions of the hinge chain.
     Note: This component is automatically attached when calling "Create Hinge Chain 2D" at {@link },
     do not attempt to use this component for other purposes.
     *
     * @public
     * @class Spine.Unity.ActivateBasedOnFlipDirection
     * @augments UnityEngine.MonoBehaviour
     */
    Bridge.define("Spine.Unity.ActivateBasedOnFlipDirection", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            skeletonRenderer: null,
            skeletonGraphic: null,
            activeOnNormalX: null,
            activeOnFlippedX: null,
            jointsNormalX: null,
            jointsFlippedX: null,
            skeletonComponent: null,
            wasFlippedXBefore: false
        },
        ctors: {
            init: function () {
                this.wasFlippedXBefore = false;
            }
        },
        methods: {
            /*Spine.Unity.ActivateBasedOnFlipDirection.Start start.*/
            Start: function () {
                this.jointsNormalX = this.activeOnNormalX.GetComponentsInChildren(UnityEngine.HingeJoint2D);
                this.jointsFlippedX = this.activeOnFlippedX.GetComponentsInChildren(UnityEngine.HingeJoint2D);
                this.skeletonComponent = UnityEngine.MonoBehaviour.op_Inequality(this.skeletonRenderer, null) ? Bridge.cast(this.skeletonRenderer, Spine.Unity.ISkeletonComponent) : Bridge.cast(this.skeletonGraphic, Spine.Unity.ISkeletonComponent);
            },
            /*Spine.Unity.ActivateBasedOnFlipDirection.Start end.*/

            /*Spine.Unity.ActivateBasedOnFlipDirection.FixedUpdate start.*/
            FixedUpdate: function () {
                var isFlippedX = (this.skeletonComponent.Spine$Unity$ISkeletonComponent$Skeleton.scaleX < 0);
                if (isFlippedX !== this.wasFlippedXBefore) {
                    this.HandleFlip(isFlippedX);
                }
                this.wasFlippedXBefore = isFlippedX;
            },
            /*Spine.Unity.ActivateBasedOnFlipDirection.FixedUpdate end.*/

            /*Spine.Unity.ActivateBasedOnFlipDirection.HandleFlip start.*/
            HandleFlip: function (isFlippedX) {
                var gameObjectToActivate = isFlippedX ? this.activeOnFlippedX : this.activeOnNormalX;
                var gameObjectToDeactivate = isFlippedX ? this.activeOnNormalX : this.activeOnFlippedX;

                gameObjectToActivate.SetActive(true);
                gameObjectToDeactivate.SetActive(false);

                this.ResetJointPositions(isFlippedX ? this.jointsFlippedX : this.jointsNormalX);
                this.ResetJointPositions(isFlippedX ? this.jointsNormalX : this.jointsFlippedX);
                this.CompensateMovementAfterFlipX(gameObjectToActivate.transform, gameObjectToDeactivate.transform);
            },
            /*Spine.Unity.ActivateBasedOnFlipDirection.HandleFlip end.*/

            /*Spine.Unity.ActivateBasedOnFlipDirection.ResetJointPositions start.*/
            ResetJointPositions: function (joints) {
                for (var i = 0; i < joints.length; i = (i + 1) | 0) {
                    var joint = joints[i];
                    var parent = joint.connectedBody.transform;
                    joint.transform.position = parent.TransformPoint$1(UnityEngine.Vector3.FromVector2(joint.connectedAnchor));
                }
            },
            /*Spine.Unity.ActivateBasedOnFlipDirection.ResetJointPositions end.*/

            /*Spine.Unity.ActivateBasedOnFlipDirection.CompensateMovementAfterFlipX start.*/
            CompensateMovementAfterFlipX: function (toActivate, toDeactivate) {
                var targetLocation = toDeactivate.GetChild(0);
                var currentLocation = toActivate.GetChild(0);
                toActivate.position = toActivate.position.$clone().add( targetLocation.position.$clone().sub( currentLocation.position ) );
            },
            /*Spine.Unity.ActivateBasedOnFlipDirection.CompensateMovementAfterFlipX end.*/


        }
    });
    /*Spine.Unity.ActivateBasedOnFlipDirection end.*/

    /*Spine.Unity.ISpineComponent start.*/
    Bridge.define("Spine.Unity.ISpineComponent", {
        $kind: 3
    });
    /*Spine.Unity.ISpineComponent end.*/

    /*Spine.Unity.AnimationTools.TimelineExtensions start.*/
    Bridge.define("Spine.Unity.AnimationTools.TimelineExtensions", {
        statics: {
            methods: {
                /*Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$1:static start.*/
                /**
                 * Evaluates the resulting value of a TranslateTimeline at a given time.
                 SkeletonData can be accessed from Skeleton.Data or from SkeletonDataAsset.GetSkeletonData.
                 If no SkeletonData is provided, values are returned as difference to setup pose
                 instead of absolute values.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AnimationTools.TimelineExtensions
                 * @memberof Spine.Unity.AnimationTools.TimelineExtensions
                 * @param   {spine.TranslateTimeline}    timeline        
                 * @param   {number}                     time            
                 * @param   {Spine.SkeletonData}         skeletonData
                 * @return  {UnityEngine.Vector2}
                 */
                Evaluate$1: function (timeline, time, skeletonData) {
                    var $t, $t1;
                    if (skeletonData === void 0) { skeletonData = null; }
                    if (time < ($t = timeline.frames)[0]) {
                        return pc.Vec2.ZERO.clone();
                    }

                    var x = { }, y = { };
                    timeline.getCurveValue(x, y, time);

                    if (skeletonData == null) {
                        return new pc.Vec2( x.v, y.v );
                    } else {
                        var boneData = ($t1 = skeletonData.Bones.Items)[timeline.boneIndex];
                        return new pc.Vec2( boneData.x + x.v, boneData.y + y.v );
                    }
                },
                /*Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$1:static end.*/

                /*Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$2:static start.*/
                /**
                 * Evaluates the resulting value of a pair of split translate timelines at a given time.
                 SkeletonData can be accessed from Skeleton.Data or from SkeletonDataAsset.GetSkeletonData.
                 If no SkeletonData is given, values are returned as difference to setup pose
                 instead of absolute values.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AnimationTools.TimelineExtensions
                 * @memberof Spine.Unity.AnimationTools.TimelineExtensions
                 * @param   {spine.TranslateXTimeline}    xTimeline       
                 * @param   {spine.TranslateYTimeline}    yTimeline       
                 * @param   {number}                      time            
                 * @param   {Spine.SkeletonData}          skeletonData
                 * @return  {UnityEngine.Vector2}
                 */
                Evaluate$2: function (xTimeline, yTimeline, time, skeletonData) {
                    var $t, $t1;
                    if (skeletonData === void 0) { skeletonData = null; }

                    var x = 0, y = 0;
                    if (xTimeline != null && time > ($t = xTimeline.frames)[0]) {
                        x = xTimeline.getCurveValue(time);
                    }
                    if (yTimeline != null && time > ($t1 = yTimeline.frames)[0]) {
                        y = yTimeline.getCurveValue(time);
                    }

                    if (skeletonData == null) {
                        return new pc.Vec2( x, y );
                    } else {
                        var bonesItems = skeletonData.Bones.Items;
                        var boneDataX = bonesItems[xTimeline.boneIndex];
                        var boneDataY = bonesItems[yTimeline.boneIndex];
                        return new pc.Vec2( boneDataX.x + x, boneDataY.y + y );
                    }
                },
                /*Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$2:static end.*/

                /*Spine.Unity.AnimationTools.TimelineExtensions.Evaluate:static start.*/
                /**
                 * Evaluates the resulting value of a RotateTimeline at a given time.
                 SkeletonData can be accessed from Skeleton.Data or from SkeletonDataAsset.GetSkeletonData.
                 If no SkeletonData is given, values are returned as difference to setup pose
                 instead of absolute values.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AnimationTools.TimelineExtensions
                 * @memberof Spine.Unity.AnimationTools.TimelineExtensions
                 * @param   {spine.RotateTimeline}    timeline        
                 * @param   {number}                  time            
                 * @param   {Spine.SkeletonData}      skeletonData
                 * @return  {number}
                 */
                Evaluate: function (timeline, time, skeletonData) {
                    var $t, $t1;
                    if (skeletonData === void 0) { skeletonData = null; }
                    if (time < ($t = timeline.frames)[0]) {
                        return 0.0;
                    }

                    var rotation = timeline.getCurveValue(time);
                    if (skeletonData == null) {
                        return rotation;
                    } else {
                        var boneData = ($t1 = skeletonData.Bones.Items)[timeline.boneIndex];
                        return (boneData.rotation + rotation);
                    }
                },
                /*Spine.Unity.AnimationTools.TimelineExtensions.Evaluate:static end.*/

                /*Spine.Unity.AnimationTools.TimelineExtensions.EvaluateTranslateXYMix:static start.*/
                /**
                 * Evaluates the resulting X and Y translate mix values of a
                 TransformConstraintTimeline at a given time.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AnimationTools.TimelineExtensions
                 * @memberof Spine.Unity.AnimationTools.TimelineExtensions
                 * @param   {spine.TransformConstraintTimeline}    timeline    
                 * @param   {number}                               time
                 * @return  {UnityEngine.Vector2}
                 */
                EvaluateTranslateXYMix: function (timeline, time) {
                    var $t;
                    if (time < ($t = timeline.frames)[0]) {
                        return pc.Vec2.ZERO.clone();
                    }

                    var rotate = { }, mixX = { }, mixY = { }, scaleX = { }, scaleY = { }, shearY = { };
                    timeline.getCurveValue(rotate, mixX, mixY, scaleX, scaleY, shearY, time);
                    return new pc.Vec2( mixX.v, mixY.v );
                },
                /*Spine.Unity.AnimationTools.TimelineExtensions.EvaluateTranslateXYMix:static end.*/

                /*Spine.Unity.AnimationTools.TimelineExtensions.EvaluateRotateMix:static start.*/
                /**
                 * Evaluates the resulting rotate mix values of a
                 TransformConstraintTimeline at a given time.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AnimationTools.TimelineExtensions
                 * @memberof Spine.Unity.AnimationTools.TimelineExtensions
                 * @param   {spine.TransformConstraintTimeline}    timeline    
                 * @param   {number}                               time
                 * @return  {number}
                 */
                EvaluateRotateMix: function (timeline, time) {
                    var $t;
                    if (time < ($t = timeline.frames)[0]) {
                        return 0;
                    }

                    var rotate = { }, mixX = { }, mixY = { }, scaleX = { }, scaleY = { }, shearY = { };
                    timeline.getCurveValue(rotate, mixX, mixY, scaleX, scaleY, shearY, time);
                    return rotate.v;
                },
                /*Spine.Unity.AnimationTools.TimelineExtensions.EvaluateRotateMix:static end.*/

                /*Spine.Unity.AnimationTools.TimelineExtensions.FindTranslateTimelineForBone:static start.*/
                /**
                 * Gets the translate timeline for a given boneIndex.
                 You can get the boneIndex using SkeletonData.FindBone().Index.
                 The root bone is always boneIndex 0.
                 This will return null if a TranslateTimeline is not found.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AnimationTools.TimelineExtensions
                 * @memberof Spine.Unity.AnimationTools.TimelineExtensions
                 * @param   {Spine.Animation}            a            
                 * @param   {number}                     boneIndex
                 * @return  {spine.TranslateTimeline}
                 */
                FindTranslateTimelineForBone: function (a, boneIndex) {
                    var $t;
                    $t = Bridge.getEnumerator(a.Timelines);
                    try {
                        while ($t.moveNext()) {
                            var timeline = $t.Current;
                            if ((Bridge.getType(timeline).prototype instanceof spine.TranslateTimeline)) {
                                continue;
                            }

                            var translateTimeline = Bridge.as(timeline, spine.TranslateTimeline);
                            if (translateTimeline != null && translateTimeline.boneIndex === boneIndex) {
                                return translateTimeline;
                            }
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                    return null;
                },
                /*Spine.Unity.AnimationTools.TimelineExtensions.FindTranslateTimelineForBone:static end.*/

                /*Spine.Unity.AnimationTools.TimelineExtensions.FindTimelineForBone:static start.*/
                /**
                 * Gets the IBoneTimeline timeline of a given type for a given boneIndex.
                 You can get the boneIndex using SkeletonData.FindBoneIndex.
                 The root bone is always boneIndex 0.
                 This will return null if a timeline of the given type is not found.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AnimationTools.TimelineExtensions
                 * @memberof Spine.Unity.AnimationTools.TimelineExtensions
                 * @param   {Function}           T            
                 * @param   {Spine.Animation}    a            
                 * @param   {number}             boneIndex
                 * @return  {T}
                 */
                FindTimelineForBone: function (T, a, boneIndex) {
                    var $t;
                    $t = Bridge.getEnumerator(a.Timelines);
                    try {
                        while ($t.moveNext()) {
                            var timeline = $t.Current;
                            var translateTimeline = Bridge.as(timeline, T);
                            if (Bridge.rValue(translateTimeline) != null && Bridge.rValue(translateTimeline).Spine$IBoneTimeline$BoneIndex === boneIndex) {
                                return Bridge.rValue(translateTimeline);
                            }
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                    return null;
                },
                /*Spine.Unity.AnimationTools.TimelineExtensions.FindTimelineForBone:static end.*/

                /*Spine.Unity.AnimationTools.TimelineExtensions.FindTransformConstraintTimeline:static start.*/
                /**
                 * Gets the transform constraint timeline for a given boneIndex.
                 You can get the boneIndex using SkeletonData.FindBone().Index.
                 The root bone is always boneIndex 0.
                 This will return null if a TranslateTimeline is not found.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AnimationTools.TimelineExtensions
                 * @memberof Spine.Unity.AnimationTools.TimelineExtensions
                 * @param   {Spine.Animation}                      a                           
                 * @param   {number}                               transformConstraintIndex
                 * @return  {spine.TransformConstraintTimeline}
                 */
                FindTransformConstraintTimeline: function (a, transformConstraintIndex) {
                    var $t;
                    $t = Bridge.getEnumerator(a.Timelines);
                    try {
                        while ($t.moveNext()) {
                            var timeline = $t.Current;
                            if ((Bridge.getType(timeline).prototype instanceof spine.TransformConstraintTimeline)) {
                                continue;
                            }

                            var transformConstraintTimeline = Bridge.as(timeline, spine.TransformConstraintTimeline);
                            if (transformConstraintTimeline != null && transformConstraintTimeline.transformConstraintIndex === transformConstraintIndex) {
                                return transformConstraintTimeline;
                            }
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                    return null;
                },
                /*Spine.Unity.AnimationTools.TimelineExtensions.FindTransformConstraintTimeline:static end.*/


            }
        }
    });
    /*Spine.Unity.AnimationTools.TimelineExtensions end.*/

    /*Spine.Unity.AtlasAssetBase start.*/
    Bridge.define("Spine.Unity.AtlasAssetBase", {
        inherits: [UnityEngine.ScriptableObject],
        fields: {
            textureLoadingMode: 0,
            onDemandTextureLoader: null
        },
        props: {
            TextureLoadingMode: {
                get: function () {
                    return this.textureLoadingMode;
                },
                set: function (value) {
                    this.textureLoadingMode = value;
                }
            },
            OnDemandTextureLoader: {
                get: function () {
                    return this.onDemandTextureLoader;
                },
                set: function (value) {
                    this.onDemandTextureLoader = value;
                }
            }
        },
        ctors: {
            init: function () {
                this.textureLoadingMode = Spine.Unity.AtlasAssetBase.LoadingMode.Normal;
            }
        },
        methods: {
            /*Spine.Unity.AtlasAssetBase.BeginCustomTextureLoading start.*/
            BeginCustomTextureLoading: function () {
                if (UnityEngine.Object.op_Implicit(this.onDemandTextureLoader)) {
                    this.onDemandTextureLoader.BeginCustomTextureLoading();
                }
            },
            /*Spine.Unity.AtlasAssetBase.BeginCustomTextureLoading end.*/

            /*Spine.Unity.AtlasAssetBase.EndCustomTextureLoading start.*/
            EndCustomTextureLoading: function () {
                if (UnityEngine.Object.op_Implicit(this.onDemandTextureLoader)) {
                    this.onDemandTextureLoader.EndCustomTextureLoading();
                }
            },
            /*Spine.Unity.AtlasAssetBase.EndCustomTextureLoading end.*/

            /*Spine.Unity.AtlasAssetBase.RequireTexturesLoaded start.*/
            RequireTexturesLoaded: function (material, overrideMaterial) {
                if (UnityEngine.Object.op_Implicit(this.onDemandTextureLoader)) {
                    this.onDemandTextureLoader.RequestLoadMaterialTextures(material, overrideMaterial);
                }
            },
            /*Spine.Unity.AtlasAssetBase.RequireTexturesLoaded end.*/

            /*Spine.Unity.AtlasAssetBase.RequireTextureLoaded start.*/
            RequireTextureLoaded: function (placeholderTexture, replacementTexture, onTextureLoaded) {
                if (UnityEngine.Object.op_Implicit(this.onDemandTextureLoader)) {
                    this.onDemandTextureLoader.RequestLoadTexture(placeholderTexture, replacementTexture, onTextureLoaded);
                }
            },
            /*Spine.Unity.AtlasAssetBase.RequireTextureLoaded end.*/


        }
    });
    /*Spine.Unity.AtlasAssetBase end.*/

    /*Spine.Unity.AtlasAssetBase+LoadingMode start.*/
    Bridge.define("Spine.Unity.AtlasAssetBase.LoadingMode", {
        $kind: 1006,
        statics: {
            fields: {
                Normal: 0,
                OnDemand: 1
            }
        }
    });
    /*Spine.Unity.AtlasAssetBase+LoadingMode end.*/

    /*Spine.Unity.AttachmentTools.AtlasUtilities start.*/
    Bridge.define("Spine.Unity.AttachmentTools.AtlasUtilities", {
        statics: {
            fields: {
                SpineTextureFormat: 0,
                DefaultMipmapBias: 0,
                UseMipMaps: false,
                DefaultScale: 0,
                NonrenderingRegion: 0,
                existingRegions: null,
                regionIndices: null,
                originalRegions: null,
                repackedRegions: null,
                texturesToPackAtParam: null,
                inoutAttachments: null,
                CachedRegionTextures: null,
                CachedRegionTexturesList: null
            },
            ctors: {
                init: function () {
                    this.SpineTextureFormat = UnityEngine.TextureFormat.RGBA32;
                    this.DefaultMipmapBias = -0.5;
                    this.UseMipMaps = false;
                    this.DefaultScale = 0.01;
                    this.NonrenderingRegion = -1;
                    this.existingRegions = new (System.Collections.Generic.Dictionary$2(Spine.AtlasRegion,System.Int32)).ctor();
                    this.regionIndices = new (System.Collections.Generic.List$1(System.Int32)).ctor();
                    this.originalRegions = new (System.Collections.Generic.List$1(Spine.AtlasRegion)).ctor();
                    this.repackedRegions = new (System.Collections.Generic.List$1(Spine.AtlasRegion)).ctor();
                    this.texturesToPackAtParam = System.Array.init(1, null, System.Collections.Generic.List$1(UnityEngine.Texture2D));
                    this.inoutAttachments = new (System.Collections.Generic.List$1(spine.Attachment)).ctor();
                    this.CachedRegionTextures = new (System.Collections.Generic.Dictionary$2(Spine.Unity.AttachmentTools.AtlasUtilities.IntAndAtlasRegionKey,UnityEngine.Texture2D)).ctor();
                    this.CachedRegionTexturesList = new (System.Collections.Generic.List$1(UnityEngine.Texture2D)).ctor();
                }
            },
            methods: {
                /*Spine.Unity.AttachmentTools.AtlasUtilities.Init:static start.*/
                Init: function () {
                    // handle disabled domain reload
                    Spine.Unity.AttachmentTools.AtlasUtilities.ClearCache();
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.Init:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegion$2:static start.*/
                ToAtlasRegion$2: function (t, materialPropertySource, scale) {
                    if (scale === void 0) { scale = 0.01; }
                    return Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegion$3(t, materialPropertySource.shader, scale, materialPropertySource);
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegion$2:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegion$3:static start.*/
                ToAtlasRegion$3: function (t, shader, scale, materialPropertySource) {
                    if (scale === void 0) { scale = 0.01; }
                    if (materialPropertySource === void 0) { materialPropertySource = null; }
                    var material = new UnityEngine.Material.$ctor2(shader);
                    if (materialPropertySource != null) {
                        material.CopyPropertiesFromMaterial(materialPropertySource);
                        material.shaderKeywords = materialPropertySource.shaderKeywords;
                    }

                    material.mainTexture = t;
                    var page = Spine.Unity.AttachmentTools.AtlasUtilities.ToSpineAtlasPage(material);

                    var width = t.width;
                    var height = t.height;

                    var region = new Spine.AtlasRegion();
                    region.name = t.name;

                    // World space units
                    var boundsMin = pc.Vec2.ZERO.clone(), boundsMax = new pc.Vec2( width, height ).scale( scale );

                    // Texture space/pixel units
                    region.width = Bridge.Int.clip32(width);
                    region.originalWidth = Bridge.Int.clip32(width);
                    region.height = Bridge.Int.clip32(height);
                    region.originalHeight = Bridge.Int.clip32(height);
                    region.offsetX = width * (0.5 - Spine.Unity.AttachmentTools.AtlasUtilities.InverseLerp(boundsMin.x, boundsMax.x, 0));
                    region.offsetY = height * (0.5 - Spine.Unity.AttachmentTools.AtlasUtilities.InverseLerp(boundsMin.y, boundsMax.y, 0));

                    // Use the full area of the texture.
                    region.u = 0;
                    region.v = 1;
                    region.u2 = 1;
                    region.v2 = 0;
                    region.x = 0;
                    region.y = 0;

                    region.page = page;

                    return region;
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegion$3:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegion:static start.*/
                /**
                 * Creates a Spine.AtlasRegion from a UnityEngine.Sprite.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AtlasUtilities
                 * @memberof Spine.Unity.AttachmentTools.AtlasUtilities
                 * @param   {UnityEngine.Sprite}    s       
                 * @param   {Spine.AtlasPage}       page
                 * @return  {Spine.AtlasRegion}
                 */
                ToAtlasRegion: function (s, page) {
                    if (page == null) {
                        throw new System.ArgumentNullException.$ctor3("page", "page cannot be null. AtlasPage determines which texture region belongs and how it should be rendered. You can use material.ToSpineAtlasPage() to get a shareable AtlasPage from a Material, or use the sprite.ToAtlasRegion(material) overload.");
                    }
                    var region = Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegion$4(s);
                    region.page = page;
                    return region;
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegion:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegion$1:static start.*/
                /**
                 * Creates a Spine.AtlasRegion from a UnityEngine.Sprite. This creates a new AtlasPage object for every AtlasRegion you create. You can centralize Material control by creating a shared atlas page using Material.ToSpineAtlasPage and using the sprite.ToAtlasRegion(AtlasPage) overload.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AtlasUtilities
                 * @memberof Spine.Unity.AttachmentTools.AtlasUtilities
                 * @param   {UnityEngine.Sprite}      s           
                 * @param   {UnityEngine.Material}    material
                 * @return  {Spine.AtlasRegion}
                 */
                ToAtlasRegion$1: function (s, material) {
                    var region = Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegion$4(s);
                    region.page = Spine.Unity.AttachmentTools.AtlasUtilities.ToSpineAtlasPage(material);
                    return region;
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegion$1:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegion$4:static start.*/
                ToAtlasRegion$4: function (s, isolatedTexture) {
                    if (isolatedTexture === void 0) { isolatedTexture = false; }
                    var region = new Spine.AtlasRegion();
                    region.name = s.name;
                    region.index = -1;
                    region.degrees = s.packed && s.packingRotation !== UnityEngine.SpritePackingRotation.None ? 90 : 0;

                    // World space units
                    var bounds = s.bounds;
                    var boundsMin = UnityEngine.Vector2.FromVector3(bounds.min.$clone()), boundsMax = UnityEngine.Vector2.FromVector3(bounds.max.$clone());

                    // Texture space/pixel units
                    var spineRect = Spine.Unity.AttachmentTools.AtlasUtilities.SpineUnityFlipRect(s.textureRect, s.texture.height);
                    var originalRect = s.rect.$clone();
                    region.width = Bridge.Int.clip32(spineRect.width);
                    region.originalWidth = Bridge.Int.clip32(originalRect.width);
                    region.height = Bridge.Int.clip32(spineRect.height);
                    region.originalHeight = Bridge.Int.clip32(originalRect.height);
                    region.offsetX = s.textureRectOffset.x + spineRect.width * (0.5 - Spine.Unity.AttachmentTools.AtlasUtilities.InverseLerp(boundsMin.x, boundsMax.x, 0));
                    region.offsetY = s.textureRectOffset.y + spineRect.height * (0.5 - Spine.Unity.AttachmentTools.AtlasUtilities.InverseLerp(boundsMin.y, boundsMax.y, 0));

                    if (isolatedTexture) {
                        region.u = 0;
                        region.v = 1;
                        region.u2 = 1;
                        region.v2 = 0;
                        region.x = 0;
                        region.y = 0;
                    } else {
                        var tex = s.texture;
                        var uvRect = Spine.Unity.AttachmentTools.AtlasUtilities.TextureRectToUVRect(s.textureRect.$clone(), tex.width, tex.height);
                        region.u = uvRect.xMin;
                        region.v = uvRect.yMax;
                        region.u2 = uvRect.xMax;
                        region.v2 = uvRect.yMin;
                        region.x = Bridge.Int.clip32(spineRect.x);
                        region.y = Bridge.Int.clip32(spineRect.y);
                    }

                    return region;
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegion$4:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegionPMAClone$2:static start.*/
                /**
                 * Creates a Spine.AtlasRegion that uses a premultiplied alpha duplicate of the Sprite's texture data.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AtlasUtilities
                 * @memberof Spine.Unity.AttachmentTools.AtlasUtilities
                 * @param   {UnityEngine.Texture2D}        t                         
                 * @param   {UnityEngine.Material}         materialPropertySource    
                 * @param   {UnityEngine.TextureFormat}    textureFormat             
                 * @param   {boolean}                      mipmaps
                 * @return  {Spine.AtlasRegion}
                 */
                ToAtlasRegionPMAClone$2: function (t, materialPropertySource, textureFormat, mipmaps) {
                    if (textureFormat === void 0) { textureFormat = 4; }
                    if (mipmaps === void 0) { mipmaps = false; }
                    return Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegionPMAClone$3(t, materialPropertySource.shader, textureFormat, mipmaps, materialPropertySource);
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegionPMAClone$2:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegionPMAClone$3:static start.*/
                /**
                 * Creates a Spine.AtlasRegion that uses a premultiplied alpha duplicate of the Sprite's texture data.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AtlasUtilities
                 * @memberof Spine.Unity.AttachmentTools.AtlasUtilities
                 * @param   {UnityEngine.Texture2D}        t                         
                 * @param   {UnityEngine.Shader}           shader                    
                 * @param   {UnityEngine.TextureFormat}    textureFormat             
                 * @param   {boolean}                      mipmaps                   
                 * @param   {UnityEngine.Material}         materialPropertySource
                 * @return  {Spine.AtlasRegion}
                 */
                ToAtlasRegionPMAClone$3: function (t, shader, textureFormat, mipmaps, materialPropertySource) {
                    if (textureFormat === void 0) { textureFormat = 4; }
                    if (mipmaps === void 0) { mipmaps = false; }
                    if (materialPropertySource === void 0) { materialPropertySource = null; }
                    var material = new UnityEngine.Material.$ctor2(shader);
                    if (materialPropertySource != null) {
                        material.CopyPropertiesFromMaterial(materialPropertySource);
                        material.shaderKeywords = materialPropertySource.shaderKeywords;
                    }
                    var newTexture = Spine.Unity.AttachmentTools.AtlasUtilities.GetClone(t, textureFormat, mipmaps, false, true);

                    newTexture.name = (t.name || "") + "-pma-";
                    material.name = (t.name || "") + (shader.name || "");

                    material.mainTexture = newTexture;
                    var page = Spine.Unity.AttachmentTools.AtlasUtilities.ToSpineAtlasPage(material);

                    var region = Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegion$3(newTexture, shader);
                    region.page = page;

                    return region;
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegionPMAClone$3:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegionPMAClone:static start.*/
                ToAtlasRegionPMAClone: function (s, materialPropertySource, textureFormat, mipmaps) {
                    if (textureFormat === void 0) { textureFormat = 4; }
                    if (mipmaps === void 0) { mipmaps = false; }
                    return Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegionPMAClone$1(s, materialPropertySource.shader, textureFormat, mipmaps, materialPropertySource);
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegionPMAClone:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegionPMAClone$1:static start.*/
                /**
                 * Creates a Spine.AtlasRegion that uses a premultiplied alpha duplicate of the Sprite's texture data.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AtlasUtilities
                 * @memberof Spine.Unity.AttachmentTools.AtlasUtilities
                 * @param   {UnityEngine.Sprite}           s                         
                 * @param   {UnityEngine.Shader}           shader                    
                 * @param   {UnityEngine.TextureFormat}    textureFormat             
                 * @param   {boolean}                      mipmaps                   
                 * @param   {UnityEngine.Material}         materialPropertySource
                 * @return  {Spine.AtlasRegion}
                 */
                ToAtlasRegionPMAClone$1: function (s, shader, textureFormat, mipmaps, materialPropertySource) {
                    if (textureFormat === void 0) { textureFormat = 4; }
                    if (mipmaps === void 0) { mipmaps = false; }
                    if (materialPropertySource === void 0) { materialPropertySource = null; }
                    var material = new UnityEngine.Material.$ctor2(shader);
                    if (materialPropertySource != null) {
                        material.CopyPropertiesFromMaterial(materialPropertySource);
                        material.shaderKeywords = materialPropertySource.shaderKeywords;
                    }

                    var tex = Spine.Unity.AttachmentTools.AtlasUtilities.ToTexture$1(s, textureFormat, mipmaps, false, true);
                    tex.name = (s.name || "") + "-pma-";
                    material.name = (tex.name || "") + (shader.name || "");

                    material.mainTexture = tex;
                    var page = Spine.Unity.AttachmentTools.AtlasUtilities.ToSpineAtlasPage(material);

                    var region = Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegion$4(s, true);
                    region.page = page;

                    return region;
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegionPMAClone$1:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToSpineAtlasPage:static start.*/
                /**
                 * Creates a new Spine.AtlasPage from a UnityEngine.Material. If the material has a preassigned texture, the page width and height will be set.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AtlasUtilities
                 * @memberof Spine.Unity.AttachmentTools.AtlasUtilities
                 * @param   {UnityEngine.Material}    m
                 * @return  {Spine.AtlasPage}
                 */
                ToSpineAtlasPage: function (m) {
                    var $t;
                    var newPage = ($t = new Spine.AtlasPage(), $t.rendererObject = m, $t.name = m.name, $t);

                    var t = m.mainTexture;
                    if (t != null) {
                        newPage.width = t.width;
                        newPage.height = t.height;
                    }

                    return newPage;
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToSpineAtlasPage:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetRepackedAttachments:static start.*/
                /**
                 * Fills the outputAttachments list with new attachment objects based on the attachments in sourceAttachments,
                 but mapped to a new single texture using the same material.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AtlasUtilities
                 * @memberof Spine.Unity.AttachmentTools.AtlasUtilities
                 * @param   {System.Collections.Generic.List$1}    sourceAttachments                     The list of attachments to be repacked.
                 * @param   {System.Collections.Generic.List$1}    outputAttachments                     The List(Attachment) to populate with the newly created Attachment objects.
                 May be equal to <pre><code>sourceAttachments</code></pre> for in-place operation.
                 * @param   {UnityEngine.Material}                 materialPropertySource                May be null. If no Material property source is provided, a material with
                 default parameters using the provided <pre><code>shader</code></pre> will be created.
                 * @param   {UnityEngine.Material}                 outputMaterial                        
                 * @param   {UnityEngine.Texture2D}                outputTexture                         
                 * @param   {number}                               maxAtlasSize                          
                 * @param   {number}                               padding                               
                 * @param   {UnityEngine.TextureFormat}            textureFormat                         
                 * @param   {boolean}                              mipmaps                               
                 * @param   {string}                               newAssetName                          
                 * @param   {boolean}                              clearCache                            When set to <pre><code>true</code></pre>, {@link } is called after
                 repacking to clear the texture cache. See remarks for additional info.
                 * @param   {boolean}                              useOriginalNonrenderables             
                 * @param   {Array.<number>}                       additionalTexturePropertyIDsToCopy    Optional additional textures (such as normal maps) to copy while repacking.
                 To copy e.g. the main texture and normal maps, pass 'new int[] { Shader.PropertyToID("_BumpMap") }' at this parameter.
                 * @param   {Array.<UnityEngine.Texture2D>}        additionalOutputTextures              When <pre><code>additionalTexturePropertyIDsToCopy</code></pre> is non-null,
                 this array will be filled with the resulting repacked texture for every property,
                 just as the main repacked texture is assigned to <pre><code>outputTexture</code></pre>.
                 * @param   {Array.<UnityEngine.TextureFormat>}    additionalTextureFormats              When <pre><code>additionalTexturePropertyIDsToCopy</code></pre> is non-null,
                 this array will be used as <pre><code>TextureFormat</code></pre> at the Texture at the respective property.
                 When <pre><code>additionalTextureFormats</code></pre> is <pre><code>null</code></pre> or when its array size is smaller,
                 <pre><code>textureFormat</code></pre> is used where there exists no corresponding array item.
                 * @param   {Array.<boolean>}                      additionalTextureIsLinear             When <pre><code>additionalTexturePropertyIDsToCopy</code></pre> is non-null,
                 this array will be used to determine whether <pre><code>linear</code></pre> or <pre><code>sRGB</code></pre> color space is used at the
                 Texture at the respective property. When <pre><code>additionalTextureIsLinear</code></pre> is <pre><code>null</code></pre>, <pre><code>linear</code></pre> color space
                 is assumed at every additional Texture element.
                 When e.g. packing the main texture and normal maps, pass 'new bool[] { true }' at this parameter, because normal maps use
                 linear color space.
                 * @return  {void}
                 */
                GetRepackedAttachments: function (sourceAttachments, outputAttachments, materialPropertySource, outputMaterial, outputTexture, maxAtlasSize, padding, textureFormat, mipmaps, newAssetName, clearCache, useOriginalNonrenderables, additionalTexturePropertyIDsToCopy, additionalOutputTextures, additionalTextureFormats, additionalTextureIsLinear) {
                    if (maxAtlasSize === void 0) { maxAtlasSize = 1024; }
                    if (padding === void 0) { padding = 2; }
                    if (textureFormat === void 0) { textureFormat = 4; }
                    if (mipmaps === void 0) { mipmaps = false; }
                    if (newAssetName === void 0) { newAssetName = "Repacked Attachments"; }
                    if (clearCache === void 0) { clearCache = false; }
                    if (useOriginalNonrenderables === void 0) { useOriginalNonrenderables = true; }
                    if (additionalTexturePropertyIDsToCopy === void 0) { additionalTexturePropertyIDsToCopy = null; }
                    if (additionalOutputTextures === void 0) { additionalOutputTextures = null; }
                    if (additionalTextureFormats === void 0) { additionalTextureFormats = null; }
                    if (additionalTextureIsLinear === void 0) { additionalTextureIsLinear = null; }

                    var shader = materialPropertySource == null ? UnityEngine.Shader.Find("Spine/Skeleton") : materialPropertySource.shader;
                    Spine.Unity.AttachmentTools.AtlasUtilities.GetRepackedAttachments$1(sourceAttachments, outputAttachments, shader, outputMaterial, outputTexture, maxAtlasSize, padding, textureFormat, mipmaps, newAssetName, materialPropertySource, clearCache, useOriginalNonrenderables, additionalTexturePropertyIDsToCopy, additionalOutputTextures, additionalTextureFormats, additionalTextureIsLinear);
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetRepackedAttachments:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetRepackedAttachments$1:static start.*/
                /**
                 * Fills the outputAttachments list with new attachment objects based on the attachments in sourceAttachments,
                 but mapped to a new single texture using the same material.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AtlasUtilities
                 * @memberof Spine.Unity.AttachmentTools.AtlasUtilities
                 * @param   {System.Collections.Generic.List$1}    sourceAttachments                     The list of attachments to be repacked.
                 * @param   {System.Collections.Generic.List$1}    outputAttachments                     The List(Attachment) to populate with the newly created Attachment objects.
                 May be equal to <pre><code>sourceAttachments</code></pre> for in-place operation.
                 * @param   {UnityEngine.Shader}                   shader                                
                 * @param   {UnityEngine.Material}                 outputMaterial                        
                 * @param   {UnityEngine.Texture2D}                outputTexture                         
                 * @param   {number}                               maxAtlasSize                          
                 * @param   {number}                               padding                               
                 * @param   {UnityEngine.TextureFormat}            textureFormat                         
                 * @param   {boolean}                              mipmaps                               
                 * @param   {string}                               newAssetName                          
                 * @param   {UnityEngine.Material}                 materialPropertySource                May be null. If no Material property source is provided, a material with
                 default parameters using the provided <pre><code>shader</code></pre> will be created.
                 * @param   {boolean}                              clearCache                            
                 * @param   {boolean}                              useOriginalNonrenderables             
                 * @param   {Array.<number>}                       additionalTexturePropertyIDsToCopy    Optional additional textures (such as normal maps) to copy while repacking.
                 To copy e.g. the main texture and normal maps, pass 'new int[] { Shader.PropertyToID("_BumpMap") }' at this parameter.
                 * @param   {Array.<UnityEngine.Texture2D>}        additionalOutputTextures              When <pre><code>additionalTexturePropertyIDsToCopy</code></pre> is non-null,
                 this array will be filled with the resulting repacked texture for every property,
                 just as the main repacked texture is assigned to <pre><code>outputTexture</code></pre>.
                 * @param   {Array.<UnityEngine.TextureFormat>}    additionalTextureFormats              When <pre><code>additionalTexturePropertyIDsToCopy</code></pre> is non-null,
                 this array will be used as <pre><code>TextureFormat</code></pre> at the Texture at the respective property.
                 When <pre><code>additionalTextureFormats</code></pre> is <pre><code>null</code></pre> or when its array size is smaller,
                 <pre><code>textureFormat</code></pre> is used where there exists no corresponding array item.
                 * @param   {Array.<boolean>}                      additionalTextureIsLinear             When <pre><code>additionalTexturePropertyIDsToCopy</code></pre> is non-null,
                 this array will be used to determine whether <pre><code>linear</code></pre> or <pre><code>sRGB</code></pre> color space is used at the
                 Texture at the respective property. When <pre><code>additionalTextureIsLinear</code></pre> is <pre><code>null</code></pre>, <pre><code>linear</code></pre> color space
                 is assumed at every additional Texture element.
                 When e.g. packing the main texture and normal maps, pass 'new bool[] { true }' at this parameter, because normal maps use
                 linear color space.
                 * @return  {void}
                 */
                GetRepackedAttachments$1: function (sourceAttachments, outputAttachments, shader, outputMaterial, outputTexture, maxAtlasSize, padding, textureFormat, mipmaps, newAssetName, materialPropertySource, clearCache, useOriginalNonrenderables, additionalTexturePropertyIDsToCopy, additionalOutputTextures, additionalTextureFormats, additionalTextureIsLinear) {
                    if (maxAtlasSize === void 0) { maxAtlasSize = 1024; }
                    if (padding === void 0) { padding = 2; }
                    if (textureFormat === void 0) { textureFormat = 4; }
                    if (mipmaps === void 0) { mipmaps = false; }
                    if (newAssetName === void 0) { newAssetName = "Repacked Attachments"; }
                    if (materialPropertySource === void 0) { materialPropertySource = null; }
                    if (clearCache === void 0) { clearCache = false; }
                    if (useOriginalNonrenderables === void 0) { useOriginalNonrenderables = true; }
                    if (additionalTexturePropertyIDsToCopy === void 0) { additionalTexturePropertyIDsToCopy = null; }
                    if (additionalOutputTextures === void 0) { additionalOutputTextures = null; }
                    if (additionalTextureFormats === void 0) { additionalTextureFormats = null; }
                    if (additionalTextureIsLinear === void 0) { additionalTextureIsLinear = null; }

                    if (sourceAttachments == null) {
                        throw new System.ArgumentNullException.$ctor1("sourceAttachments");
                    }
                    if (outputAttachments == null) {
                        throw new System.ArgumentNullException.$ctor1("outputAttachments");
                    }
                    outputTexture.v = null;
                    if (additionalTexturePropertyIDsToCopy != null && additionalTextureIsLinear == null) {
                        additionalTextureIsLinear = System.Array.init(additionalTexturePropertyIDsToCopy.length, false, System.Boolean);
                        for (var i = 0; i < additionalTextureIsLinear.length; i = (i + 1) | 0) {
                            additionalTextureIsLinear[i] = true;
                        }
                    }

                    // Use these to detect and use shared regions.
                    Spine.Unity.AttachmentTools.AtlasUtilities.existingRegions.clear();
                    Spine.Unity.AttachmentTools.AtlasUtilities.regionIndices.clear();

                    // Collect all textures from original attachments.
                    var numTextureParamsToRepack = (1 + (additionalTexturePropertyIDsToCopy == null ? 0 : additionalTexturePropertyIDsToCopy.length)) | 0;
                    additionalOutputTextures = (additionalTexturePropertyIDsToCopy == null ? null : System.Array.init(additionalTexturePropertyIDsToCopy.length, null, UnityEngine.Texture2D));
                    if (Spine.Unity.AttachmentTools.AtlasUtilities.texturesToPackAtParam.length < numTextureParamsToRepack) {
                        System.Array.resize(Bridge.ref(Spine.Unity.AttachmentTools.AtlasUtilities, "texturesToPackAtParam"), numTextureParamsToRepack, null, System.Collections.Generic.List$1(UnityEngine.Texture2D));
                    }
                    for (var i1 = 0; i1 < numTextureParamsToRepack; i1 = (i1 + 1) | 0) {
                        if (Spine.Unity.AttachmentTools.AtlasUtilities.texturesToPackAtParam[i1] != null) {
                            Spine.Unity.AttachmentTools.AtlasUtilities.texturesToPackAtParam[i1].clear();
                        } else {
                            Spine.Unity.AttachmentTools.AtlasUtilities.texturesToPackAtParam[i1] = new (System.Collections.Generic.List$1(UnityEngine.Texture2D)).ctor();
                        }
                    }
                    Spine.Unity.AttachmentTools.AtlasUtilities.originalRegions.clear();

                    if (!Bridge.referenceEquals(sourceAttachments, outputAttachments)) {
                        outputAttachments.clear();
                        outputAttachments.AddRange(sourceAttachments);
                    }

                    var newRegionIndex = 0;
                    for (var attachmentIndex = 0, n = sourceAttachments.Count; attachmentIndex < n; attachmentIndex = (attachmentIndex + 1) | 0) {
                        var originalAttachment = sourceAttachments.getItem(attachmentIndex);

                        if (Bridge.is(originalAttachment, Spine.IHasTextureRegion)) {
                            var originalMeshAttachment = Bridge.as(originalAttachment, Spine.MeshAttachment);
                            var newAttachment = (originalMeshAttachment != null) ? originalMeshAttachment.newLinkedMesh() : originalAttachment.copy();
                            var region = Bridge.as(Bridge.cast(newAttachment, Spine.IHasTextureRegion).Spine$IHasTextureRegion$Region, Spine.AtlasRegion);
                            var existingIndex = { };
                            if (Spine.Unity.AttachmentTools.AtlasUtilities.existingRegions.tryGetValue(region, existingIndex)) {
                                Spine.Unity.AttachmentTools.AtlasUtilities.regionIndices.add(existingIndex.v);
                            } else {
                                Spine.Unity.AttachmentTools.AtlasUtilities.originalRegions.add(region);
                                for (var i2 = 0; i2 < numTextureParamsToRepack; i2 = (i2 + 1) | 0) {
                                    var regionTexture = (i2 === 0 ? Spine.Unity.AttachmentTools.AtlasUtilities.ToTexture(region, textureFormat, mipmaps) : Spine.Unity.AttachmentTools.AtlasUtilities.ToTexture(region, (additionalTextureFormats != null && ((i2 - 1) | 0) < additionalTextureFormats.length) ? additionalTextureFormats[((i2 - 1) | 0)] : textureFormat, mipmaps, additionalTexturePropertyIDsToCopy[((i2 - 1) | 0)], additionalTextureIsLinear[((i2 - 1) | 0)]));
                                    Spine.Unity.AttachmentTools.AtlasUtilities.texturesToPackAtParam[i2].add(regionTexture);
                                }

                                Spine.Unity.AttachmentTools.AtlasUtilities.existingRegions.add(region, newRegionIndex);
                                Spine.Unity.AttachmentTools.AtlasUtilities.regionIndices.add(newRegionIndex);
                                newRegionIndex = (newRegionIndex + 1) | 0;
                            }

                            outputAttachments.setItem(attachmentIndex, newAttachment);
                        } else {
                            outputAttachments.setItem(attachmentIndex, useOriginalNonrenderables ? originalAttachment : originalAttachment.copy());
                            Spine.Unity.AttachmentTools.AtlasUtilities.regionIndices.add(Spine.Unity.AttachmentTools.AtlasUtilities.NonrenderingRegion); // Output attachments pairs with regionIndices list 1:1. Pad with a sentinel if the attachment doesn't have a region.
                        }
                    }

                    // Rehydrate the repacked textures as a Material, Spine atlas and Spine.AtlasAttachments
                    var newMaterial = new UnityEngine.Material.$ctor2(shader);
                    if (materialPropertySource != null) {
                        newMaterial.CopyPropertiesFromMaterial(materialPropertySource);
                        newMaterial.shaderKeywords = materialPropertySource.shaderKeywords;
                    }
                    newMaterial.name = newAssetName;

                    var rects = null;
                    for (var i3 = 0; i3 < numTextureParamsToRepack; i3 = (i3 + 1) | 0) {
                        // Fill a new texture with the collected attachment textures.
                        var newTexture = new UnityEngine.Texture2D.$ctor2(maxAtlasSize, maxAtlasSize, (i3 > 0 && additionalTextureFormats != null && ((i3 - 1) | 0) < additionalTextureFormats.length) ? additionalTextureFormats[((i3 - 1) | 0)] : textureFormat, mipmaps, (i3 > 0) ? additionalTextureIsLinear[((i3 - 1) | 0)] : false);
                        newTexture.mipMapBias = Spine.Unity.AttachmentTools.AtlasUtilities.DefaultMipmapBias;

                        var texturesToPack = Spine.Unity.AttachmentTools.AtlasUtilities.texturesToPackAtParam[i3];
                        if (texturesToPack.Count > 0) {
                            var sourceTexture = texturesToPack.getItem(0);
                            Spine.Unity.AttachmentTools.AtlasUtilities.CopyTextureAttributesFrom(newTexture, sourceTexture);
                        }
                        newTexture.name = newAssetName;
                        var rectsForTexParam = newTexture.PackTextures(texturesToPack.ToArray(), padding, maxAtlasSize);
                        if (i3 === 0) {
                            rects = rectsForTexParam;
                            newMaterial.mainTexture = newTexture;
                            outputTexture.v = newTexture;
                        } else {
                            newMaterial.SetTexture(additionalTexturePropertyIDsToCopy[((i3 - 1) | 0)], newTexture);
                            additionalOutputTextures[((i3 - 1) | 0)] = newTexture;
                        }
                    }

                    var page = Spine.Unity.AttachmentTools.AtlasUtilities.ToSpineAtlasPage(newMaterial);
                    page.name = newAssetName;

                    Spine.Unity.AttachmentTools.AtlasUtilities.repackedRegions.clear();
                    for (var i4 = 0, n1 = Spine.Unity.AttachmentTools.AtlasUtilities.originalRegions.Count; i4 < n1; i4 = (i4 + 1) | 0) {
                        var oldRegion = Spine.Unity.AttachmentTools.AtlasUtilities.originalRegions.getItem(i4);
                        var newRegion = Spine.Unity.AttachmentTools.AtlasUtilities.UVRectToAtlasRegion(rects[i4].$clone(), oldRegion, page);
                        Spine.Unity.AttachmentTools.AtlasUtilities.repackedRegions.add(newRegion);
                    }

                    // Map the cloned attachments to the repacked atlas.
                    for (var i5 = 0, n2 = outputAttachments.Count; i5 < n2; i5 = (i5 + 1) | 0) {
                        var attachment = outputAttachments.getItem(i5);
                        var iHasRegion = Bridge.as(attachment, Spine.IHasTextureRegion);
                        if (iHasRegion != null) {
                            iHasRegion.Spine$IHasTextureRegion$Region = Spine.Unity.AttachmentTools.AtlasUtilities.repackedRegions.getItem(Spine.Unity.AttachmentTools.AtlasUtilities.regionIndices.getItem(i5));
                            iHasRegion.Spine$IHasTextureRegion$UpdateRegion();
                        }
                    }

                    // Clean up.
                    if (clearCache) {
                        Spine.Unity.AttachmentTools.AtlasUtilities.ClearCache();
                    }

                    outputMaterial.v = newMaterial;
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetRepackedAttachments$1:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetRepackedSkin:static start.*/
                /**
                 * Creates and populates a duplicate skin with cloned attachments that are backed by a new packed texture atlas
                 comprised of all the regions from the original skin.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AtlasUtilities
                 * @memberof Spine.Unity.AttachmentTools.AtlasUtilities
                 * @param   {Spine.Skin}                           o                                     
                 * @param   {string}                               newName                               
                 * @param   {UnityEngine.Material}                 materialPropertySource                
                 * @param   {UnityEngine.Material}                 outputMaterial                        
                 * @param   {UnityEngine.Texture2D}                outputTexture                         
                 * @param   {number}                               maxAtlasSize                          
                 * @param   {number}                               padding                               
                 * @param   {UnityEngine.TextureFormat}            textureFormat                         
                 * @param   {boolean}                              mipmaps                               
                 * @param   {boolean}                              useOriginalNonrenderables             
                 * @param   {boolean}                              clearCache                            When set to <pre><code>true</code></pre>, {@link } is called after
                 repacking to clear the texture cache. See remarks for additional info.
                 * @param   {Array.<number>}                       additionalTexturePropertyIDsToCopy    Optional additional textures (such as normal maps) to copy while repacking.
                 To copy e.g. the main texture and normal maps, pass 'new int[] { Shader.PropertyToID("_BumpMap") }' at this parameter.
                 * @param   {Array.<UnityEngine.Texture2D>}        additionalOutputTextures              When <pre><code>additionalTexturePropertyIDsToCopy</code></pre> is non-null,
                 this array will be filled with the resulting repacked texture for every property,
                 just as the main repacked texture is assigned to <pre><code>outputTexture</code></pre>.
                 * @param   {Array.<UnityEngine.TextureFormat>}    additionalTextureFormats              When <pre><code>additionalTexturePropertyIDsToCopy</code></pre> is non-null,
                 this array will be used as <pre><code>TextureFormat</code></pre> at the Texture at the respective property.
                 When <pre><code>additionalTextureFormats</code></pre> is <pre><code>null</code></pre> or when its array size is smaller,
                 <pre><code>textureFormat</code></pre> is used where there exists no corresponding array item.
                 * @param   {Array.<boolean>}                      additionalTextureIsLinear             When <pre><code>additionalTexturePropertyIDsToCopy</code></pre> is non-null,
                 this array will be used to determine whether <pre><code>linear</code></pre> or <pre><code>sRGB</code></pre> color space is used at the
                 Texture at the respective property. When <pre><code>additionalTextureIsLinear</code></pre> is <pre><code>null</code></pre>, <pre><code>linear</code></pre> color space
                 is assumed at every additional Texture element.
                 When e.g. packing the main texture and normal maps, pass 'new bool[] { true }' at this parameter, because normal maps use
                 linear color space.
                 * @return  {Spine.Skin}
                 */
                GetRepackedSkin: function (o, newName, materialPropertySource, outputMaterial, outputTexture, maxAtlasSize, padding, textureFormat, mipmaps, useOriginalNonrenderables, clearCache, additionalTexturePropertyIDsToCopy, additionalOutputTextures, additionalTextureFormats, additionalTextureIsLinear) {
                    if (maxAtlasSize === void 0) { maxAtlasSize = 1024; }
                    if (padding === void 0) { padding = 2; }
                    if (textureFormat === void 0) { textureFormat = 4; }
                    if (mipmaps === void 0) { mipmaps = false; }
                    if (useOriginalNonrenderables === void 0) { useOriginalNonrenderables = true; }
                    if (clearCache === void 0) { clearCache = false; }
                    if (additionalTexturePropertyIDsToCopy === void 0) { additionalTexturePropertyIDsToCopy = null; }
                    if (additionalOutputTextures === void 0) { additionalOutputTextures = null; }
                    if (additionalTextureFormats === void 0) { additionalTextureFormats = null; }
                    if (additionalTextureIsLinear === void 0) { additionalTextureIsLinear = null; }

                    return Spine.Unity.AttachmentTools.AtlasUtilities.GetRepackedSkin$1(o, newName, materialPropertySource.shader, outputMaterial, outputTexture, maxAtlasSize, padding, textureFormat, mipmaps, materialPropertySource, clearCache, useOriginalNonrenderables, additionalTexturePropertyIDsToCopy, additionalOutputTextures, additionalTextureFormats, additionalTextureIsLinear);
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetRepackedSkin:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetRepackedSkin$1:static start.*/
                /**
                 * Creates and populates a duplicate skin with cloned attachments that are backed by a new packed texture atlas
                 comprised of all the regions from the original skin.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AtlasUtilities
                 * @memberof Spine.Unity.AttachmentTools.AtlasUtilities
                 * @param   {Spine.Skin}                           o                                     
                 * @param   {string}                               newName                               
                 * @param   {UnityEngine.Shader}                   shader                                
                 * @param   {UnityEngine.Material}                 outputMaterial                        
                 * @param   {UnityEngine.Texture2D}                outputTexture                         
                 * @param   {number}                               maxAtlasSize                          
                 * @param   {number}                               padding                               
                 * @param   {UnityEngine.TextureFormat}            textureFormat                         
                 * @param   {boolean}                              mipmaps                               
                 * @param   {UnityEngine.Material}                 materialPropertySource                
                 * @param   {boolean}                              clearCache                            
                 * @param   {boolean}                              useOriginalNonrenderables             
                 * @param   {Array.<number>}                       additionalTexturePropertyIDsToCopy    
                 * @param   {Array.<UnityEngine.Texture2D>}        additionalOutputTextures              
                 * @param   {Array.<UnityEngine.TextureFormat>}    additionalTextureFormats              
                 * @param   {Array.<boolean>}                      additionalTextureIsLinear
                 * @return  {Spine.Skin}
                 */
                GetRepackedSkin$1: function (o, newName, shader, outputMaterial, outputTexture, maxAtlasSize, padding, textureFormat, mipmaps, materialPropertySource, clearCache, useOriginalNonrenderables, additionalTexturePropertyIDsToCopy, additionalOutputTextures, additionalTextureFormats, additionalTextureIsLinear) {
                    var $t, $t1;
                    if (maxAtlasSize === void 0) { maxAtlasSize = 1024; }
                    if (padding === void 0) { padding = 2; }
                    if (textureFormat === void 0) { textureFormat = 4; }
                    if (mipmaps === void 0) { mipmaps = false; }
                    if (materialPropertySource === void 0) { materialPropertySource = null; }
                    if (clearCache === void 0) { clearCache = false; }
                    if (useOriginalNonrenderables === void 0) { useOriginalNonrenderables = true; }
                    if (additionalTexturePropertyIDsToCopy === void 0) { additionalTexturePropertyIDsToCopy = null; }
                    if (additionalOutputTextures === void 0) { additionalOutputTextures = null; }
                    if (additionalTextureFormats === void 0) { additionalTextureFormats = null; }
                    if (additionalTextureIsLinear === void 0) { additionalTextureIsLinear = null; }

                    outputTexture.v = null;

                    if (o == null) {
                        throw new System.NullReferenceException.$ctor1("Skin was null");
                    }
                    var skinAttachments = o.Attachments;
                    var newSkin = new Spine.Skin(newName);

                    newSkin.Bones.AddRange(o.Bones);
                    newSkin.Constraints.AddRange(o.Constraints);

                    Spine.Unity.AttachmentTools.AtlasUtilities.inoutAttachments.clear();
                    $t = Bridge.getEnumerator(skinAttachments, spine.SkinEntry);
                    try {
                        while ($t.moveNext()) {
                            var entry = $t.Current;
                            Spine.Unity.AttachmentTools.AtlasUtilities.inoutAttachments.add(entry.attachment);
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                    Spine.Unity.AttachmentTools.AtlasUtilities.GetRepackedAttachments(Spine.Unity.AttachmentTools.AtlasUtilities.inoutAttachments, Spine.Unity.AttachmentTools.AtlasUtilities.inoutAttachments, materialPropertySource, outputMaterial, outputTexture, maxAtlasSize, padding, textureFormat, mipmaps, newName, clearCache, useOriginalNonrenderables, additionalTexturePropertyIDsToCopy, additionalOutputTextures, additionalTextureFormats, additionalTextureIsLinear);
                    var i = 0;
                    $t1 = Bridge.getEnumerator(skinAttachments, spine.SkinEntry);
                    try {
                        while ($t1.moveNext()) {
                            var originalSkinEntry = $t1.Current;
                            var newAttachment = Spine.Unity.AttachmentTools.AtlasUtilities.inoutAttachments.getItem(Bridge.identity(i, ((i = (i + 1) | 0))));
                            newSkin.setAttachment(originalSkinEntry.slotIndex, originalSkinEntry.name, newAttachment);
                        }
                    } finally {
                        if (Bridge.is($t1, System.IDisposable)) {
                            $t1.System$IDisposable$Dispose();
                        }
                    }
                    return newSkin;
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetRepackedSkin$1:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToSprite:static start.*/
                ToSprite: function (ar, pixelsPerUnit) {
                    if (pixelsPerUnit === void 0) { pixelsPerUnit = 100.0; }
                    return UnityEngine.Sprite.Create$1(Spine.Unity.AttachmentTools.AtlasUtilities.GetMainTexture(ar), Spine.Unity.AttachmentTools.AtlasUtilities.GetUnityRect(ar), new pc.Vec2( 0.5, 0.5 ), pixelsPerUnit);
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToSprite:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.ClearCache:static start.*/
                /**
                 * Frees up textures cached by repacking and remapping operations.
                 Calling {@link } with parameter <pre><code>premultiplyAlpha=true</code></pre>,
                 {@link } or {@link } will cache textures for later re-use,
                	which might steadily increase the texture memory footprint when used excessively.
                	You can clear this Texture cache by calling {@link }.
                 You may also want to call <pre><code>Resources.UnloadUnusedAssets()</code></pre> after that. Be aware that while this cleanup
                 frees up memory, it is also a costly operation and will likely cause a spike in the framerate.
                 Thus it is recommended to perform costly repacking and cleanup operations after e.g. a character customization
                 screen has been exited, and if required additionally after a certain number of <pre><code>GetRemappedClone()</code></pre> calls.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AtlasUtilities
                 * @memberof Spine.Unity.AttachmentTools.AtlasUtilities
                 * @return  {void}
                 */
                ClearCache: function () {
                    var $t;
                    $t = Bridge.getEnumerator(Spine.Unity.AttachmentTools.AtlasUtilities.CachedRegionTexturesList);
                    try {
                        while ($t.moveNext()) {
                            var t = $t.Current;
                            UnityEngine.Object.Destroy(t);
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                    Spine.Unity.AttachmentTools.AtlasUtilities.CachedRegionTextures.clear();
                    Spine.Unity.AttachmentTools.AtlasUtilities.CachedRegionTexturesList.clear();
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.ClearCache:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToTexture:static start.*/
                /**
                 * Creates a new Texture2D object based on an AtlasRegion.
                 If applyImmediately is true, Texture2D.Apply is called immediately after the Texture2D is filled with data.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AtlasUtilities
                 * @memberof Spine.Unity.AttachmentTools.AtlasUtilities
                 * @param   {Spine.AtlasRegion}            ar                   
                 * @param   {UnityEngine.TextureFormat}    textureFormat        
                 * @param   {boolean}                      mipmaps              
                 * @param   {number}                       texturePropertyId    
                 * @param   {boolean}                      linear               
                 * @param   {boolean}                      applyPMA
                 * @return  {UnityEngine.Texture2D}
                 */
                ToTexture: function (ar, textureFormat, mipmaps, texturePropertyId, linear, applyPMA) {
                    var $t;
                    if (textureFormat === void 0) { textureFormat = 4; }
                    if (mipmaps === void 0) { mipmaps = false; }
                    if (texturePropertyId === void 0) { texturePropertyId = 0; }
                    if (linear === void 0) { linear = false; }
                    if (applyPMA === void 0) { applyPMA = false; }

                    var output = { };

                    var cacheKey = new Spine.Unity.AttachmentTools.AtlasUtilities.IntAndAtlasRegionKey.$ctor1(texturePropertyId, ar);
                    Spine.Unity.AttachmentTools.AtlasUtilities.CachedRegionTextures.tryGetValue(cacheKey.$clone(), output);
                    if (output.v == null) {
                        var sourceTexture = texturePropertyId === 0 ? Spine.Unity.AttachmentTools.AtlasUtilities.GetMainTexture(ar) : Spine.Unity.AttachmentTools.AtlasUtilities.GetTexture(ar, texturePropertyId);
                        var r = Spine.Unity.AttachmentTools.AtlasUtilities.GetUnityRect(ar);
                        var width = Bridge.Int.clip32(r.width);
                        var height = Bridge.Int.clip32(r.height);
                        output.v = ($t = new UnityEngine.Texture2D.$ctor2(width, height, textureFormat, mipmaps, linear), $t.name = ar.name, $t);
                        Spine.Unity.AttachmentTools.AtlasUtilities.CopyTextureAttributesFrom(output.v, sourceTexture);
                        if (applyPMA) {
                            Spine.Unity.AttachmentTools.AtlasUtilities.CopyTextureApplyPMA(sourceTexture, r.$clone(), output.v);
                        } else {
                            Spine.Unity.AttachmentTools.AtlasUtilities.CopyTexture(sourceTexture, r.$clone(), output.v);
                        }
                        Spine.Unity.AttachmentTools.AtlasUtilities.CachedRegionTextures.add(cacheKey.$clone(), output.v);
                        Spine.Unity.AttachmentTools.AtlasUtilities.CachedRegionTexturesList.add(output.v);
                    }

                    return output.v;
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToTexture:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToTexture$1:static start.*/
                ToTexture$1: function (s, textureFormat, mipmaps, linear, applyPMA) {
                    var $t, $t1, $t2, $t3, $t4, $t5, $t6, $t7;
                    if (textureFormat === void 0) { textureFormat = 4; }
                    if (mipmaps === void 0) { mipmaps = false; }
                    if (linear === void 0) { linear = false; }
                    if (applyPMA === void 0) { applyPMA = false; }

                    var spriteTexture = s.texture;
                    var r = new UnityEngine.Rect();
                    if (!s.packed || s.packingMode === UnityEngine.SpritePackingMode.Rectangle) {
                        r = s.textureRect.$clone();
                    } else {
                        r = new UnityEngine.Rect.ctor();
                        r.xMin = Math.min(($t = s.uv)[0].x, ($t1 = s.uv)[1].x) * spriteTexture.width;
                        r.xMax = Math.max(($t2 = s.uv)[0].x, ($t3 = s.uv)[1].x) * spriteTexture.width;
                        r.yMin = Math.min(($t4 = s.uv)[0].y, ($t5 = s.uv)[2].y) * spriteTexture.height;
                        r.yMax = Math.max(($t6 = s.uv)[0].y, ($t7 = s.uv)[2].y) * spriteTexture.height;
                    }
                    var newTexture = new UnityEngine.Texture2D.$ctor2(Bridge.Int.clip32(r.width), Bridge.Int.clip32(r.height), textureFormat, mipmaps, linear);
                    Spine.Unity.AttachmentTools.AtlasUtilities.CopyTextureAttributesFrom(newTexture, spriteTexture);
                    if (applyPMA) {
                        Spine.Unity.AttachmentTools.AtlasUtilities.CopyTextureApplyPMA(spriteTexture, r.$clone(), newTexture);
                    } else {
                        Spine.Unity.AttachmentTools.AtlasUtilities.CopyTexture(spriteTexture, r.$clone(), newTexture);
                    }
                    return newTexture;
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToTexture$1:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetClone:static start.*/
                GetClone: function (t, textureFormat, mipmaps, linear, applyPMA) {
                    if (textureFormat === void 0) { textureFormat = 4; }
                    if (mipmaps === void 0) { mipmaps = false; }
                    if (linear === void 0) { linear = false; }
                    if (applyPMA === void 0) { applyPMA = false; }

                    var newTexture = new UnityEngine.Texture2D.$ctor2(t.width, t.height, textureFormat, mipmaps, linear);
                    Spine.Unity.AttachmentTools.AtlasUtilities.CopyTextureAttributesFrom(newTexture, t);
                    if (applyPMA) {
                        Spine.Unity.AttachmentTools.AtlasUtilities.CopyTextureApplyPMA(t, new UnityEngine.Rect.$ctor1(0, 0, t.width, t.height), newTexture);
                    } else {
                        Spine.Unity.AttachmentTools.AtlasUtilities.CopyTexture(t, new UnityEngine.Rect.$ctor1(0, 0, t.width, t.height), newTexture);
                    }
                    return newTexture;
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetClone:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.CopyTexture:static start.*/
                CopyTexture: function (source, sourceRect, destination) {
                    if (UnityEngine.SystemInfo.copyTextureSupport === UnityEngine.Rendering.CopyTextureSupport.None) {
                        // GetPixels fallback for old devices.
                        var pixelBuffer = source.GetPixels$2(Bridge.Int.clip32(sourceRect.x), Bridge.Int.clip32(sourceRect.y), Bridge.Int.clip32(sourceRect.width), Bridge.Int.clip32(sourceRect.height));
                        destination.SetPixels$1(pixelBuffer);
                        destination.Apply();
                    } else {
                        UnityEngine.Graphics.CopyTexture(source, 0, 0, Bridge.Int.clip32(sourceRect.x), Bridge.Int.clip32(sourceRect.y), Bridge.Int.clip32(sourceRect.width), Bridge.Int.clip32(sourceRect.height), destination, 0, 0, 0, 0);
                    }
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.CopyTexture:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.CopyTextureApplyPMA:static start.*/
                CopyTextureApplyPMA: function (source, sourceRect, destination) {
                    var pixelBuffer = source.GetPixels$2(Bridge.Int.clip32(sourceRect.x), Bridge.Int.clip32(sourceRect.y), Bridge.Int.clip32(sourceRect.width), Bridge.Int.clip32(sourceRect.height));
                    for (var i = 0, n = pixelBuffer.length; i < n; i = (i + 1) | 0) {
                        var p = pixelBuffer[i].$clone();
                        var a = p.a;
                        p.r = p.r * a;
                        p.g = p.g * a;
                        p.b = p.b * a;
                        pixelBuffer[i] = p.$clone();
                    }
                    destination.SetPixels$1(pixelBuffer);
                    destination.Apply();
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.CopyTextureApplyPMA:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.IsRenderable:static start.*/
                IsRenderable: function (a) {
                    return Bridge.is(a, Spine.IHasTextureRegion);
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.IsRenderable:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.SpineUnityFlipRect:static start.*/
                /**
                 * Get a rect with flipped Y so that a Spine atlas rect gets converted to a Unity Sprite rect and vice versa.
                 *
                 * @static
                 * @private
                 * @this Spine.Unity.AttachmentTools.AtlasUtilities
                 * @memberof Spine.Unity.AttachmentTools.AtlasUtilities
                 * @param   {UnityEngine.Rect}    rect             
                 * @param   {number}              textureHeight
                 * @return  {UnityEngine.Rect}
                 */
                SpineUnityFlipRect: function (rect, textureHeight) {
                    rect.y = textureHeight - rect.y - rect.height;
                    return rect.$clone();
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.SpineUnityFlipRect:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetUnityRect:static start.*/
                /**
                 * Gets the Rect of an AtlasRegion according to Unity texture coordinates (x-right, y-up).
                 This overload relies on region.page.height being correctly set.
                 *
                 * @static
                 * @private
                 * @this Spine.Unity.AttachmentTools.AtlasUtilities
                 * @memberof Spine.Unity.AttachmentTools.AtlasUtilities
                 * @param   {Spine.AtlasRegion}    region
                 * @return  {UnityEngine.Rect}
                 */
                GetUnityRect: function (region) {
                    return Spine.Unity.AttachmentTools.AtlasUtilities.SpineUnityFlipRect(Spine.Unity.AttachmentTools.AtlasUtilities.GetSpineAtlasRect(region), region.page.height);
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetUnityRect:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetUnityRect$1:static start.*/
                /**
                 * Gets the Rect of an AtlasRegion according to Unity texture coordinates (x-right, y-up).
                 *
                 * @static
                 * @private
                 * @this Spine.Unity.AttachmentTools.AtlasUtilities
                 * @memberof Spine.Unity.AttachmentTools.AtlasUtilities
                 * @param   {Spine.AtlasRegion}    region           
                 * @param   {number}               textureHeight
                 * @return  {UnityEngine.Rect}
                 */
                GetUnityRect$1: function (region, textureHeight) {
                    return Spine.Unity.AttachmentTools.AtlasUtilities.SpineUnityFlipRect(Spine.Unity.AttachmentTools.AtlasUtilities.GetSpineAtlasRect(region), textureHeight);
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetUnityRect$1:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetSpineAtlasRect:static start.*/
                /**
                 * Returns a Rect of the AtlasRegion according to Spine texture coordinates. (x-right, y-down)
                 *
                 * @static
                 * @private
                 * @this Spine.Unity.AttachmentTools.AtlasUtilities
                 * @memberof Spine.Unity.AttachmentTools.AtlasUtilities
                 * @param   {Spine.AtlasRegion}    region           
                 * @param   {boolean}              includeRotate
                 * @return  {UnityEngine.Rect}
                 */
                GetSpineAtlasRect: function (region, includeRotate) {
                    if (includeRotate === void 0) { includeRotate = true; }
                    var width = region.width;
                    var height = region.height;
                    if (includeRotate && region.degrees === 270) {
                        width = region.height;
                        height = region.width;
                    }
                    return new UnityEngine.Rect.$ctor1(region.x, region.y, width, height);
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetSpineAtlasRect:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.UVRectToTextureRect:static start.*/
                /**
                 * Denormalize a uvRect into a texture-space Rect.
                 *
                 * @static
                 * @private
                 * @this Spine.Unity.AttachmentTools.AtlasUtilities
                 * @memberof Spine.Unity.AttachmentTools.AtlasUtilities
                 * @param   {UnityEngine.Rect}    uvRect       
                 * @param   {number}              texWidth     
                 * @param   {number}              texHeight
                 * @return  {UnityEngine.Rect}
                 */
                UVRectToTextureRect: function (uvRect, texWidth, texHeight) {
                    uvRect.x *= texWidth;
                    uvRect.width *= texWidth;
                    uvRect.y *= texHeight;
                    uvRect.height *= texHeight;
                    return uvRect.$clone();
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.UVRectToTextureRect:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.TextureRectToUVRect:static start.*/
                /**
                 * Normalize a texture Rect into UV coordinates.
                 *
                 * @static
                 * @private
                 * @this Spine.Unity.AttachmentTools.AtlasUtilities
                 * @memberof Spine.Unity.AttachmentTools.AtlasUtilities
                 * @param   {UnityEngine.Rect}    textureRect    
                 * @param   {number}              texWidth       
                 * @param   {number}              texHeight
                 * @return  {UnityEngine.Rect}
                 */
                TextureRectToUVRect: function (textureRect, texWidth, texHeight) {
                    textureRect.x = pc.math.inverseLerp(0, texWidth, textureRect.x);
                    textureRect.y = pc.math.inverseLerp(0, texHeight, textureRect.y);
                    textureRect.width = pc.math.inverseLerp(0, texWidth, textureRect.width);
                    textureRect.height = pc.math.inverseLerp(0, texHeight, textureRect.height);
                    return textureRect.$clone();
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.TextureRectToUVRect:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.UVRectToAtlasRegion:static start.*/
                /**
                 * Creates a new Spine AtlasRegion according to a Unity UV Rect (x-right, y-up, uv-normalized).
                 *
                 * @static
                 * @private
                 * @this Spine.Unity.AttachmentTools.AtlasUtilities
                 * @memberof Spine.Unity.AttachmentTools.AtlasUtilities
                 * @param   {UnityEngine.Rect}     uvRect             
                 * @param   {Spine.AtlasRegion}    referenceRegion    
                 * @param   {Spine.AtlasPage}      page
                 * @return  {Spine.AtlasRegion}
                 */
                UVRectToAtlasRegion: function (uvRect, referenceRegion, page) {
                    var $t;
                    var tr = Spine.Unity.AttachmentTools.AtlasUtilities.UVRectToTextureRect(uvRect.$clone(), page.width, page.height);
                    var rr = Spine.Unity.AttachmentTools.AtlasUtilities.SpineUnityFlipRect(tr, page.height);

                    var x = Bridge.Int.clip32(rr.x);
                    var y = Bridge.Int.clip32(rr.y);
                    var w = Bridge.Int.clip32(rr.width);
                    var h = Bridge.Int.clip32(rr.height);

                    if (referenceRegion.degrees === 270) {
                        var tempW = w;
                        w = h;
                        h = tempW;
                    }

                    // Note: originalW and originalH need to be scaled according to the
                    // repacked width and height, repacking can mess with aspect ratio, etc.
                    var originalW = Math.round(w * (referenceRegion.originalWidth / referenceRegion.width));
                    var originalH = Math.round(h * (referenceRegion.originalHeight / referenceRegion.height));

                    var offsetX = Math.round(referenceRegion.offsetX * (w / referenceRegion.width));
                    var offsetY = Math.round(referenceRegion.offsetY * (h / referenceRegion.height));

                    var u = uvRect.xMin;
                    var u2 = uvRect.xMax;
                    var v = uvRect.yMax;
                    var v2 = uvRect.yMin;

                    if (referenceRegion.degrees === 270) {
                        // at a 270 degree region, u2/v2 deltas and atlas width/height are swapped, and delta-v is negative.
                        var du = uvRect.width; // u2 - u;
                        var dv = uvRect.height; // v - v2;
                        var atlasAspectRatio = page.width / page.height;
                        u2 = u + (dv / atlasAspectRatio);
                        v2 = v - (du * atlasAspectRatio);
                    }

                    return ($t = new Spine.AtlasRegion(), $t.page = page, $t.name = referenceRegion.name, $t.u = u, $t.u2 = u2, $t.v = v, $t.v2 = v2, $t.index = -1, $t.width = w, $t.originalWidth = originalW, $t.height = h, $t.originalHeight = originalH, $t.offsetX = offsetX, $t.offsetY = offsetY, $t.x = x, $t.y = y, $t.rotate = referenceRegion.rotate, $t.degrees = referenceRegion.degrees, $t);
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.UVRectToAtlasRegion:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetMainTexture:static start.*/
                /**
                 * Convenience method for getting the main texture of the material of the page of the region.
                 *
                 * @static
                 * @private
                 * @this Spine.Unity.AttachmentTools.AtlasUtilities
                 * @memberof Spine.Unity.AttachmentTools.AtlasUtilities
                 * @param   {Spine.AtlasRegion}        region
                 * @return  {UnityEngine.Texture2D}
                 */
                GetMainTexture: function (region) {
                    var material = (Bridge.as(region.page.rendererObject, UnityEngine.Material));
                    return Bridge.as(material.mainTexture, UnityEngine.Texture2D);
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetMainTexture:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetTexture$1:static start.*/
                /**
                 * Convenience method for getting any texture of the material of the page of the region by texture property name.
                 *
                 * @static
                 * @private
                 * @this Spine.Unity.AttachmentTools.AtlasUtilities
                 * @memberof Spine.Unity.AttachmentTools.AtlasUtilities
                 * @param   {Spine.AtlasRegion}        region                 
                 * @param   {string}                   texturePropertyName
                 * @return  {UnityEngine.Texture2D}
                 */
                GetTexture$1: function (region, texturePropertyName) {
                    var material = (Bridge.as(region.page.rendererObject, UnityEngine.Material));
                    return Bridge.as(material.GetTexture$1(texturePropertyName), UnityEngine.Texture2D);
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetTexture$1:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetTexture:static start.*/
                /**
                 * Convenience method for getting any texture of the material of the page of the region by texture property id.
                 *
                 * @static
                 * @private
                 * @this Spine.Unity.AttachmentTools.AtlasUtilities
                 * @memberof Spine.Unity.AttachmentTools.AtlasUtilities
                 * @param   {Spine.AtlasRegion}        region               
                 * @param   {number}                   texturePropertyId
                 * @return  {UnityEngine.Texture2D}
                 */
                GetTexture: function (region, texturePropertyId) {
                    var material = (Bridge.as(region.page.rendererObject, UnityEngine.Material));
                    return Bridge.as(material.GetTexture(texturePropertyId), UnityEngine.Texture2D);
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetTexture:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.CopyTextureAttributesFrom:static start.*/
                CopyTextureAttributesFrom: function (destination, source) {
                    destination.filterMode = source.filterMode;
                    destination.anisoLevel = source.anisoLevel;
                    destination.wrapModeU = source.wrapModeU;
                    destination.wrapModeV = source.wrapModeV;
                    destination.wrapModeW = source.wrapModeW;
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.CopyTextureAttributesFrom:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.InverseLerp:static start.*/
                InverseLerp: function (a, b, value) {
                    return (value - a) / (b - a);
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.InverseLerp:static end.*/


            }
        }
    });
    /*Spine.Unity.AttachmentTools.AtlasUtilities end.*/

    /*Spine.Unity.AttachmentTools.AtlasUtilities+IntAndAtlasRegionKey start.*/
    Bridge.define("Spine.Unity.AttachmentTools.AtlasUtilities.IntAndAtlasRegionKey", {
        $kind: 1004,
        statics: {
            methods: {
                getDefaultValue: function () { return new Spine.Unity.AttachmentTools.AtlasUtilities.IntAndAtlasRegionKey(); }
            }
        },
        fields: {
            i: 0,
            region: null
        },
        ctors: {
            $ctor1: function (i, region) {
                this.$initialize();
                this.i = i;
                this.region = region;
            },
            ctor: function () {
                this.$initialize();
            }
        },
        methods: {
            /*Spine.Unity.AttachmentTools.AtlasUtilities+IntAndAtlasRegionKey.getHashCode start.*/
            getHashCode: function () {
                return Bridge.Int.mul(Bridge.getHashCode(this.i), 23) ^ Bridge.getHashCode(this.region);
            },
            /*Spine.Unity.AttachmentTools.AtlasUtilities+IntAndAtlasRegionKey.getHashCode end.*/

            equals: function (o) {
                if (!Bridge.is(o, Spine.Unity.AttachmentTools.AtlasUtilities.IntAndAtlasRegionKey)) {
                    return false;
                }
                return Bridge.equals(this.i, o.i) && Bridge.equals(this.region, o.region);
            },
            $clone: function (to) {
                var s = to || new Spine.Unity.AttachmentTools.AtlasUtilities.IntAndAtlasRegionKey();
                s.i = this.i;
                s.region = this.region;
                return s;
            }
        },
        overloads: {
            "GetHashCode()": "getHashCode"
        }
    });
    /*Spine.Unity.AttachmentTools.AtlasUtilities+IntAndAtlasRegionKey end.*/

    /*Spine.Unity.AttachmentTools.AttachmentCloneExtensions start.*/
    Bridge.define("Spine.Unity.AttachmentTools.AttachmentCloneExtensions", {
        statics: {
            methods: {
                /*Spine.Unity.AttachmentTools.AttachmentCloneExtensions.GetRemappedClone$1:static start.*/
                
                GetRemappedClone$1: function (o, sprite, sourceMaterial, premultiplyAlpha, cloneMeshAsLinked, useOriginalRegionSize, pivotShiftsMeshUVCoords, useOriginalRegionScale, pmaCloneTextureFormat, pmaCloneMipmaps) {
                    var $t;
                    if (premultiplyAlpha === void 0) { premultiplyAlpha = true; }
                    if (cloneMeshAsLinked === void 0) { cloneMeshAsLinked = true; }
                    if (useOriginalRegionSize === void 0) { useOriginalRegionSize = false; }
                    if (pivotShiftsMeshUVCoords === void 0) { pivotShiftsMeshUVCoords = true; }
                    if (useOriginalRegionScale === void 0) { useOriginalRegionScale = false; }
                    if (pmaCloneTextureFormat === void 0) { pmaCloneTextureFormat = 4; }
                    if (pmaCloneMipmaps === void 0) { pmaCloneMipmaps = false; }

                    var atlasRegion = premultiplyAlpha ? Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegionPMAClone(sprite, sourceMaterial, pmaCloneTextureFormat, pmaCloneMipmaps) : Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegion$1(sprite, ($t = new UnityEngine.Material.$ctor1(sourceMaterial), $t.mainTexture = sprite.texture, $t));
                    if (!pivotShiftsMeshUVCoords && Bridge.is(o, Spine.MeshAttachment)) {
                        // prevent non-central sprite pivot setting offsetX/Y and shifting uv coords out of mesh bounds
                        atlasRegion.offsetX = 0;
                        atlasRegion.offsetY = 0;
                    }
                    var scale = 1.0 / sprite.pixelsPerUnit;
                    if (useOriginalRegionScale) {
                        var regionAttachment = Bridge.as(o, Spine.RegionAttachment);
                        if (regionAttachment != null) {
                            scale = regionAttachment.width / regionAttachment.region.originalWidth;
                        }
                    }
                    return Spine.Unity.AttachmentTools.AttachmentCloneExtensions.GetRemappedClone(o, atlasRegion, cloneMeshAsLinked, useOriginalRegionSize, scale);
                },
                /*Spine.Unity.AttachmentTools.AttachmentCloneExtensions.GetRemappedClone$1:static end.*/

                /*Spine.Unity.AttachmentTools.AttachmentCloneExtensions.GetRemappedClone:static start.*/
                /**
                 * Gets a clone of the attachment remapped with an atlasRegion image.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AttachmentCloneExtensions
                 * @memberof Spine.Unity.AttachmentTools.AttachmentCloneExtensions
                 * @param   {spine.Attachment}     o                        The original attachment.
                 * @param   {Spine.AtlasRegion}    atlasRegion              Atlas region.
                 * @param   {boolean}              cloneMeshAsLinked        If <pre><code>true</code></pre> MeshAttachments will be cloned as linked meshes and will inherit animation from the original attachment.
                 * @param   {boolean}              useOriginalRegionSize    If <pre><code>true</code></pre> the size of the original attachment will be followed, instead of using the Sprite size.
                 * @param   {number}               scale                    Unity units per pixel scale used to scale the atlas region size when not using the original region size.
                 * @return  {spine.Attachment}                              The remapped clone.
                 */
                GetRemappedClone: function (o, atlasRegion, cloneMeshAsLinked, useOriginalRegionSize, scale) {
                    if (cloneMeshAsLinked === void 0) { cloneMeshAsLinked = true; }
                    if (useOriginalRegionSize === void 0) { useOriginalRegionSize = false; }
                    if (scale === void 0) { scale = 0.01; }
                    var regionAttachment = Bridge.as(o, Spine.RegionAttachment);
                    if (regionAttachment != null) {
                        var newAttachment = Bridge.cast(regionAttachment.copy(), Spine.RegionAttachment);
                        newAttachment.region = atlasRegion;
                        if (!useOriginalRegionSize) {
                            newAttachment.width = atlasRegion.width * scale;
                            newAttachment.height = atlasRegion.height * scale;
                        }
                        newAttachment.updateRegion();
                        return newAttachment;
                    } else {
                        var meshAttachment = Bridge.as(o, Spine.MeshAttachment);
                        if (meshAttachment != null) {
                            var newAttachment1 = cloneMeshAsLinked ? meshAttachment.newLinkedMesh() : Bridge.cast(meshAttachment.copy(), Spine.MeshAttachment);
                            newAttachment1.region = atlasRegion;
                            newAttachment1.updateRegion();
                            return newAttachment1;
                        }
                    }
                    return o.copy();
                },
                /*Spine.Unity.AttachmentTools.AttachmentCloneExtensions.GetRemappedClone:static end.*/


            }
        }
    });
    /*Spine.Unity.AttachmentTools.AttachmentCloneExtensions end.*/

    /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions start.*/
    Bridge.define("Spine.Unity.AttachmentTools.AttachmentRegionExtensions", {
        statics: {
            methods: {
                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.ToRegionAttachment$2:static start.*/
                /**
                 * Creates a RegionAttachment based on a sprite. This method creates a real, usable AtlasRegion. That AtlasRegion uses a new AtlasPage with the Material provided.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AttachmentRegionExtensions
                 * @memberof Spine.Unity.AttachmentTools.AttachmentRegionExtensions
                 * @param   {UnityEngine.Sprite}        sprite      
                 * @param   {UnityEngine.Material}      material    
                 * @param   {number}                    rotation
                 * @return  {Spine.RegionAttachment}
                 */
                ToRegionAttachment$2: function (sprite, material, rotation) {
                    if (rotation === void 0) { rotation = 0.0; }
                    return Spine.Unity.AttachmentTools.AttachmentRegionExtensions.ToRegionAttachment$1(sprite, Spine.Unity.AttachmentTools.AtlasUtilities.ToSpineAtlasPage(material), rotation);
                },
                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.ToRegionAttachment$2:static end.*/

                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.ToRegionAttachment$1:static start.*/
                /**
                 * Creates a RegionAttachment based on a sprite. This method creates a real, usable AtlasRegion. That AtlasRegion uses the AtlasPage provided.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AttachmentRegionExtensions
                 * @memberof Spine.Unity.AttachmentTools.AttachmentRegionExtensions
                 * @param   {UnityEngine.Sprite}        sprite      
                 * @param   {Spine.AtlasPage}           page        
                 * @param   {number}                    rotation
                 * @return  {Spine.RegionAttachment}
                 */
                ToRegionAttachment$1: function (sprite, page, rotation) {
                    if (rotation === void 0) { rotation = 0.0; }
                    if (sprite == null) {
                        throw new System.ArgumentNullException.$ctor1("sprite");
                    }
                    if (page == null) {
                        throw new System.ArgumentNullException.$ctor1("page");
                    }
                    var region = Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegion(sprite, page);
                    var unitsPerPixel = 1.0 / sprite.pixelsPerUnit;
                    return Spine.Unity.AttachmentTools.AttachmentRegionExtensions.ToRegionAttachment(region, sprite.name, unitsPerPixel, rotation);
                },
                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.ToRegionAttachment$1:static end.*/

                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.ToRegionAttachment:static start.*/
                /**
                 * Creates a new RegionAttachment from a given AtlasRegion.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AttachmentRegionExtensions
                 * @memberof Spine.Unity.AttachmentTools.AttachmentRegionExtensions
                 * @param   {Spine.AtlasRegion}         region            
                 * @param   {string}                    attachmentName    
                 * @param   {number}                    scale             
                 * @param   {number}                    rotation
                 * @return  {Spine.RegionAttachment}
                 */
                ToRegionAttachment: function (region, attachmentName, scale, rotation) {
                    if (scale === void 0) { scale = 0.01; }
                    if (rotation === void 0) { rotation = 0.0; }
                    if (System.String.isNullOrEmpty(attachmentName)) {
                        throw new System.ArgumentException.$ctor3("attachmentName can't be null or empty.", "attachmentName");
                    }
                    if (region == null) {
                        throw new System.ArgumentNullException.$ctor1("region");
                    }

                    // (AtlasAttachmentLoader.cs)
                    var attachment = new Spine.RegionAttachment(attachmentName);

                    attachment.region = region;
                    attachment.path = region.name;
                    attachment.scaleX = 1;
                    attachment.scaleY = 1;
                    attachment.rotation = rotation;

                    attachment.color.r = 1;
                    attachment.color.g = 1;
                    attachment.color.b = 1;
                    attachment.color.a = 1;

                    // pass OriginalWidth and OriginalHeight because UpdateOffset uses it in its calculation.
                    var textreRegion = attachment.region;
                    var atlasRegion = Bridge.as(textreRegion, Spine.AtlasRegion);
                    var originalWidth = atlasRegion != null ? atlasRegion.originalWidth : textreRegion.width;
                    var originalHeight = atlasRegion != null ? atlasRegion.originalHeight : textreRegion.height;
                    attachment.width = originalWidth * scale;
                    attachment.height = originalHeight * scale;

                    Spine.Unity.SkeletonExtensions.SetColor$2(attachment, new pc.Color( 1, 1, 1, 1 ));
                    attachment.updateRegion();
                    return attachment;
                },
                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.ToRegionAttachment:static end.*/

                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.ToRegionAttachmentPMAClone$1:static start.*/
                /**
                 * Creates a Spine.AtlasRegion that uses a premultiplied alpha duplicate texture of the Sprite's texture data.
                 Returns a RegionAttachment that uses it. Use this if you plan to use a premultiply alpha shader such as "Spine/Skeleton".
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AttachmentRegionExtensions
                 * @memberof Spine.Unity.AttachmentTools.AttachmentRegionExtensions
                 * @param   {UnityEngine.Sprite}           sprite                    
                 * @param   {UnityEngine.Shader}           shader                    
                 * @param   {UnityEngine.TextureFormat}    textureFormat             
                 * @param   {boolean}                      mipmaps                   
                 * @param   {UnityEngine.Material}         materialPropertySource    
                 * @param   {number}                       rotation
                 * @return  {Spine.RegionAttachment}
                 */
                ToRegionAttachmentPMAClone$1: function (sprite, shader, textureFormat, mipmaps, materialPropertySource, rotation) {
                    if (textureFormat === void 0) { textureFormat = 4; }
                    if (mipmaps === void 0) { mipmaps = false; }
                    if (materialPropertySource === void 0) { materialPropertySource = null; }
                    if (rotation === void 0) { rotation = 0.0; }
                    if (sprite == null) {
                        throw new System.ArgumentNullException.$ctor1("sprite");
                    }
                    if (shader == null) {
                        throw new System.ArgumentNullException.$ctor1("shader");
                    }
                    var region = Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegionPMAClone$1(sprite, shader, textureFormat, mipmaps, materialPropertySource);
                    var unitsPerPixel = 1.0 / sprite.pixelsPerUnit;
                    return Spine.Unity.AttachmentTools.AttachmentRegionExtensions.ToRegionAttachment(region, sprite.name, unitsPerPixel, rotation);
                },
                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.ToRegionAttachmentPMAClone$1:static end.*/

                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.ToRegionAttachmentPMAClone:static start.*/
                ToRegionAttachmentPMAClone: function (sprite, materialPropertySource, textureFormat, mipmaps, rotation) {
                    if (textureFormat === void 0) { textureFormat = 4; }
                    if (mipmaps === void 0) { mipmaps = false; }
                    if (rotation === void 0) { rotation = 0.0; }
                    return Spine.Unity.AttachmentTools.AttachmentRegionExtensions.ToRegionAttachmentPMAClone$1(sprite, materialPropertySource.shader, textureFormat, mipmaps, materialPropertySource, rotation);
                },
                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.ToRegionAttachmentPMAClone:static end.*/

                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.SetScale$1:static start.*/
                /**
                 * Sets the scale. Call regionAttachment.UpdateOffset to apply the change.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AttachmentRegionExtensions
                 * @memberof Spine.Unity.AttachmentTools.AttachmentRegionExtensions
                 * @param   {Spine.RegionAttachment}    regionAttachment    
                 * @param   {UnityEngine.Vector2}       scale
                 * @return  {void}
                 */
                SetScale$1: function (regionAttachment, scale) {
                    regionAttachment.scaleX = scale.x;
                    regionAttachment.scaleY = scale.y;
                },
                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.SetScale$1:static end.*/

                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.SetScale:static start.*/
                /**
                 * Sets the scale. Call regionAttachment.UpdateOffset to apply the change.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AttachmentRegionExtensions
                 * @memberof Spine.Unity.AttachmentTools.AttachmentRegionExtensions
                 * @param   {Spine.RegionAttachment}    regionAttachment    
                 * @param   {number}                    x                   
                 * @param   {number}                    y
                 * @return  {void}
                 */
                SetScale: function (regionAttachment, x, y) {
                    regionAttachment.scaleX = x;
                    regionAttachment.scaleY = y;
                },
                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.SetScale:static end.*/

                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.SetPositionOffset$1:static start.*/
                /**
                 * Sets the position offset. Call regionAttachment.UpdateOffset to apply the change.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AttachmentRegionExtensions
                 * @memberof Spine.Unity.AttachmentTools.AttachmentRegionExtensions
                 * @param   {Spine.RegionAttachment}    regionAttachment    
                 * @param   {UnityEngine.Vector2}       offset
                 * @return  {void}
                 */
                SetPositionOffset$1: function (regionAttachment, offset) {
                    regionAttachment.x = offset.x;
                    regionAttachment.y = offset.y;
                },
                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.SetPositionOffset$1:static end.*/

                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.SetPositionOffset:static start.*/
                /**
                 * Sets the position offset. Call regionAttachment.UpdateOffset to apply the change.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AttachmentRegionExtensions
                 * @memberof Spine.Unity.AttachmentTools.AttachmentRegionExtensions
                 * @param   {Spine.RegionAttachment}    regionAttachment    
                 * @param   {number}                    x                   
                 * @param   {number}                    y
                 * @return  {void}
                 */
                SetPositionOffset: function (regionAttachment, x, y) {
                    regionAttachment.x = x;
                    regionAttachment.y = y;
                },
                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.SetPositionOffset:static end.*/

                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.SetRotation:static start.*/
                /**
                 * Sets the rotation. Call regionAttachment.UpdateOffset to apply the change.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AttachmentRegionExtensions
                 * @memberof Spine.Unity.AttachmentTools.AttachmentRegionExtensions
                 * @param   {Spine.RegionAttachment}    regionAttachment    
                 * @param   {number}                    rotation
                 * @return  {void}
                 */
                SetRotation: function (regionAttachment, rotation) {
                    regionAttachment.rotation = rotation;
                },
                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.SetRotation:static end.*/


            }
        }
    });
    /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions end.*/

    /*Spine.Unity.BlendModeMaterials start.*/
    Bridge.define("Spine.Unity.BlendModeMaterials", {
        fields: {
            requiresBlendModeMaterials: false,
            applyAdditiveMaterial: false,
            additiveMaterials: null,
            multiplyMaterials: null,
            screenMaterials: null
        },
        props: {
            RequiresBlendModeMaterials: {
                get: function () {
                    return this.requiresBlendModeMaterials;
                },
                set: function (value) {
                    this.requiresBlendModeMaterials = value;
                }
            }
        },
        ctors: {
            init: function () {
                this.requiresBlendModeMaterials = false;
                this.applyAdditiveMaterial = false;
                this.additiveMaterials = new (System.Collections.Generic.List$1(Spine.Unity.BlendModeMaterials.ReplacementMaterial)).ctor();
                this.multiplyMaterials = new (System.Collections.Generic.List$1(Spine.Unity.BlendModeMaterials.ReplacementMaterial)).ctor();
                this.screenMaterials = new (System.Collections.Generic.List$1(Spine.Unity.BlendModeMaterials.ReplacementMaterial)).ctor();
            }
        },
        methods: {
            /*Spine.Unity.BlendModeMaterials.BlendModeForMaterial start.*/
            BlendModeForMaterial: function (material) {
                var $t, $t1, $t2;
                $t = Bridge.getEnumerator(this.multiplyMaterials);
                try {
                    while ($t.moveNext()) {
                        var pair = $t.Current;
                        if (Bridge.referenceEquals(pair.material, material)) {
                            return spine.BlendMode.Multiply;
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                $t1 = Bridge.getEnumerator(this.additiveMaterials);
                try {
                    while ($t1.moveNext()) {
                        var pair1 = $t1.Current;
                        if (Bridge.referenceEquals(pair1.material, material)) {
                            return spine.BlendMode.Additive;
                        }
                    }
                } finally {
                    if (Bridge.is($t1, System.IDisposable)) {
                        $t1.System$IDisposable$Dispose();
                    }
                }
                $t2 = Bridge.getEnumerator(this.screenMaterials);
                try {
                    while ($t2.moveNext()) {
                        var pair2 = $t2.Current;
                        if (Bridge.referenceEquals(pair2.material, material)) {
                            return spine.BlendMode.Screen;
                        }
                    }
                } finally {
                    if (Bridge.is($t2, System.IDisposable)) {
                        $t2.System$IDisposable$Dispose();
                    }
                }
                return spine.BlendMode.Normal;
            },
            /*Spine.Unity.BlendModeMaterials.BlendModeForMaterial end.*/

            /*Spine.Unity.BlendModeMaterials.ApplyMaterials start.*/
            ApplyMaterials: function (skeletonData) {
                var $t, $t1;
                if (skeletonData == null) {
                    throw new System.ArgumentNullException.$ctor1("skeletonData");
                }
                if (!this.requiresBlendModeMaterials) {
                    return;
                }

                var skinEntries = new (System.Collections.Generic.List$1(spine.SkinEntry)).ctor();
                var slotsItems = skeletonData.Slots.Items;
                for (var slotIndex = 0, slotCount = skeletonData.Slots.Count; slotIndex < slotCount; slotIndex = (slotIndex + 1) | 0) {
                    var slot = slotsItems[slotIndex];
                    if (slot.blendMode === spine.BlendMode.Normal) {
                        continue;
                    }
                    if (!this.applyAdditiveMaterial && slot.blendMode === spine.BlendMode.Additive) {
                        continue;
                    }

                    var replacementMaterials = null;
                    switch (slot.blendMode) {
                        case spine.BlendMode.Multiply: 
                            replacementMaterials = this.multiplyMaterials;
                            break;
                        case spine.BlendMode.Screen: 
                            replacementMaterials = this.screenMaterials;
                            break;
                        case spine.BlendMode.Additive: 
                            replacementMaterials = this.additiveMaterials;
                            break;
                    }
                    if (replacementMaterials == null) {
                        continue;
                    }

                    skinEntries.clear();
                    $t = Bridge.getEnumerator(skeletonData.Skins);
                    try {
                        while ($t.moveNext()) {
                            var skin = $t.Current;
                            ( skinEntries._items.length = 0, skin.getAttachmentsForSlot( slotIndex, skinEntries._items ), skinEntries._size = skinEntries._items.length );
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }

                    $t1 = Bridge.getEnumerator(skinEntries);
                    try {
                        while ($t1.moveNext()) {
                            var entry = $t1.Current;
                            var renderableAttachment = Bridge.as(entry.attachment, Spine.IHasTextureRegion);
                            if (renderableAttachment != null) {
                                if (renderableAttachment.Spine$IHasTextureRegion$Region != null) {
                                    renderableAttachment.Spine$IHasTextureRegion$Region = this.CloneAtlasRegionWithMaterial(Bridge.cast(renderableAttachment.Spine$IHasTextureRegion$Region, Spine.AtlasRegion), replacementMaterials);
                                } else {
                                    if (renderableAttachment.Spine$IHasTextureRegion$Sequence != null) {
                                        var regions = renderableAttachment.Spine$IHasTextureRegion$Sequence.regions;
                                        for (var i = 0; i < regions.length; i = (i + 1) | 0) {
                                            regions[i] = this.CloneAtlasRegionWithMaterial(Bridge.cast(regions[i], Spine.AtlasRegion), replacementMaterials);
                                        }
                                    }
                                }
                            }
                        }
                    } finally {
                        if (Bridge.is($t1, System.IDisposable)) {
                            $t1.System$IDisposable$Dispose();
                        }
                    }
                }
            },
            /*Spine.Unity.BlendModeMaterials.ApplyMaterials end.*/

            /*Spine.Unity.BlendModeMaterials.CloneAtlasRegionWithMaterial start.*/
            CloneAtlasRegionWithMaterial: function (originalRegion, replacementMaterials) {
                var $t;
                var newRegion = originalRegion.Clone();
                var material = null;
                $t = Bridge.getEnumerator(replacementMaterials);
                try {
                    while ($t.moveNext()) {
                        var replacement = $t.Current;
                        if (Bridge.referenceEquals(replacement.pageName, originalRegion.page.name)) {
                            material = replacement.material;
                            break;
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }

                var originalPage = originalRegion.page;
                var newPage = originalPage.Clone();
                newPage.rendererObject = material;
                newRegion.page = newPage;
                return newRegion;
            },
            /*Spine.Unity.BlendModeMaterials.CloneAtlasRegionWithMaterial end.*/


        }
    });
    /*Spine.Unity.BlendModeMaterials end.*/

    /*Spine.Unity.BlendModeMaterials+ReplacementMaterial start.*/
    Bridge.define("Spine.Unity.BlendModeMaterials.ReplacementMaterial", {
        $kind: 1002,
        fields: {
            pageName: null,
            material: null
        }
    });
    /*Spine.Unity.BlendModeMaterials+ReplacementMaterial end.*/

    /*Spine.Unity.SkeletonDataModifierAsset start.*/
    /**
     * Can be stored by SkeletonDataAsset to automatically apply modifications to loaded SkeletonData.
     *
     * @abstract
     * @public
     * @class Spine.Unity.SkeletonDataModifierAsset
     * @augments UnityEngine.ScriptableObject
     */
    Bridge.define("Spine.Unity.SkeletonDataModifierAsset", {
        inherits: [UnityEngine.ScriptableObject]
    });
    /*Spine.Unity.SkeletonDataModifierAsset end.*/

    /*Spine.Unity.BlendModeMaterialsAsset+AtlasMaterialCache start.*/
    Bridge.define("Spine.Unity.BlendModeMaterialsAsset.AtlasMaterialCache", {
        inherits: [System.IDisposable],
        $kind: 1002,
        fields: {
            cache: null
        },
        alias: ["Dispose", "System$IDisposable$Dispose"],
        ctors: {
            init: function () {
                this.cache = new (System.Collections.Generic.Dictionary$2(System.Collections.Generic.KeyValuePair$2(Spine.AtlasPage,UnityEngine.Material),Spine.AtlasPage)).ctor();
            }
        },
        methods: {
            /*Spine.Unity.BlendModeMaterialsAsset+AtlasMaterialCache.CloneAtlasRegionWithMaterial start.*/
            /**
             * Creates a clone of an AtlasRegion that uses different Material settings, while retaining the original texture.
             *
             * @instance
             * @public
             * @this Spine.Unity.BlendModeMaterialsAsset.AtlasMaterialCache
             * @memberof Spine.Unity.BlendModeMaterialsAsset.AtlasMaterialCache
             * @param   {Spine.AtlasRegion}       originalRegion      
             * @param   {UnityEngine.Material}    materialTemplate
             * @return  {Spine.AtlasRegion}
             */
            CloneAtlasRegionWithMaterial: function (originalRegion, materialTemplate) {
                var newRegion = originalRegion.Clone();
                newRegion.page = this.GetAtlasPageWithMaterial(originalRegion.page, materialTemplate);
                return newRegion;
            },
            /*Spine.Unity.BlendModeMaterialsAsset+AtlasMaterialCache.CloneAtlasRegionWithMaterial end.*/

            /*Spine.Unity.BlendModeMaterialsAsset+AtlasMaterialCache.GetAtlasPageWithMaterial start.*/
            GetAtlasPageWithMaterial: function (originalPage, materialTemplate) {
                var $t;
                if (originalPage == null) {
                    throw new System.ArgumentNullException.$ctor1("originalPage");
                }

                var newPage = { v : null };
                var key = new (System.Collections.Generic.KeyValuePair$2(Spine.AtlasPage,UnityEngine.Material)).$ctor1(originalPage, materialTemplate);
                this.cache.tryGetValue(key, newPage);

                if (newPage.v == null) {
                    newPage.v = originalPage.Clone();
                    var originalMaterial = Bridge.as(originalPage.rendererObject, UnityEngine.Material);
                    newPage.v.rendererObject = ($t = new UnityEngine.Material.$ctor1(materialTemplate), $t.name = (originalMaterial.name || "") + " " + (materialTemplate.name || ""), $t.mainTexture = originalMaterial.mainTexture, $t);
                    this.cache.add(key, newPage.v);
                }

                return newPage.v;
            },
            /*Spine.Unity.BlendModeMaterialsAsset+AtlasMaterialCache.GetAtlasPageWithMaterial end.*/

            /*Spine.Unity.BlendModeMaterialsAsset+AtlasMaterialCache.Dispose start.*/
            Dispose: function () {
                this.cache.clear();
            },
            /*Spine.Unity.BlendModeMaterialsAsset+AtlasMaterialCache.Dispose end.*/


        }
    });
    /*Spine.Unity.BlendModeMaterialsAsset+AtlasMaterialCache end.*/

    /*Spine.Unity.BoneFollower start.*/
    /**
     * Sets a GameObject's transform to match a bone on a Spine skeleton.
     *
     * @public
     * @class Spine.Unity.BoneFollower
     * @augments UnityEngine.MonoBehaviour
     */
    Bridge.define("Spine.Unity.BoneFollower", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            skeletonRenderer: null,
            /**
             * If a bone isn't set in code, boneName is used to find the bone at the beginning. For runtime switching by name, use SetBoneByName. You can also set the BoneFollower.bone field directly.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.BoneFollower
             * @type string
             */
            boneName: null,
            followXYPosition: false,
            followZPosition: false,
            followBoneRotation: false,
            followSkeletonFlip: false,
            followLocalScale: false,
            followParentWorldScale: false,
            maintainedAxisOrientation: 0,
            initializeOnAwake: false,
            valid: false,
            bone: null,
            skeletonTransform: null,
            skeletonTransformIsParent: false
        },
        props: {
            SkeletonRenderer: {
                get: function () {
                    return this.skeletonRenderer;
                },
                set: function (value) {
                    this.skeletonRenderer = value;
                    this.Initialize();
                }
            }
        },
        ctors: {
            init: function () {
                this.followXYPosition = true;
                this.followZPosition = true;
                this.followBoneRotation = true;
                this.followSkeletonFlip = true;
                this.followLocalScale = false;
                this.followParentWorldScale = false;
                this.maintainedAxisOrientation = Spine.Unity.BoneFollower.AxisOrientation.XAxis;
                this.initializeOnAwake = true;
            }
        },
        methods: {
            /*Spine.Unity.BoneFollower.SetBone start.*/
            /**
             * Sets the target bone by its bone name. Returns false if no bone was found. To set the bone by reference, use BoneFollower.bone directly.
             *
             * @instance
             * @public
             * @this Spine.Unity.BoneFollower
             * @memberof Spine.Unity.BoneFollower
             * @param   {string}     name
             * @return  {boolean}
             */
            SetBone: function (name) {
                this.bone = this.skeletonRenderer.skeleton.findBone(name);
                if (this.bone == null) {
                    UnityEngine.Debug.LogError$2("Bone not found: " + (name || ""), this);
                    return false;
                }
                this.boneName = name;
                return true;
            },
            /*Spine.Unity.BoneFollower.SetBone end.*/

            /*Spine.Unity.BoneFollower.Awake start.*/
            Awake: function () {
                if (this.initializeOnAwake) {
                    this.Initialize();
                }
            },
            /*Spine.Unity.BoneFollower.Awake end.*/

            /*Spine.Unity.BoneFollower.HandleRebuildRenderer start.*/
            HandleRebuildRenderer: function (skeletonRenderer) {
                this.Initialize();
            },
            /*Spine.Unity.BoneFollower.HandleRebuildRenderer end.*/

            /*Spine.Unity.BoneFollower.Initialize start.*/
            Initialize: function () {
                this.bone = null;
                this.valid = UnityEngine.MonoBehaviour.op_Inequality(this.skeletonRenderer, null) && this.skeletonRenderer.valid;
                if (!this.valid) {
                    return;
                }

                this.skeletonTransform = this.skeletonRenderer.transform;
                this.skeletonRenderer.removeOnRebuild(Bridge.fn.cacheBind(this, this.HandleRebuildRenderer));
                this.skeletonRenderer.addOnRebuild(Bridge.fn.cacheBind(this, this.HandleRebuildRenderer));
                this.skeletonTransformIsParent = Bridge.referenceEquals(this.skeletonTransform, this.transform.parent);

                if (!System.String.isNullOrEmpty(this.boneName)) {
                    this.bone = this.skeletonRenderer.skeleton.findBone(this.boneName);
                }

            },
            /*Spine.Unity.BoneFollower.Initialize end.*/

            /*Spine.Unity.BoneFollower.OnDestroy start.*/
            OnDestroy: function () {
                if (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonRenderer, null)) {
                    this.skeletonRenderer.removeOnRebuild(Bridge.fn.cacheBind(this, this.HandleRebuildRenderer));
                }
            },
            /*Spine.Unity.BoneFollower.OnDestroy end.*/

            /*Spine.Unity.BoneFollower.LateUpdate start.*/
            LateUpdate: function () {
                var $t, $t1;
                if (!this.valid) {
                    this.Initialize();
                    return;
                }


                if (this.bone == null) {
                    if (System.String.isNullOrEmpty(this.boneName)) {
                        return;
                    }
                    this.bone = this.skeletonRenderer.skeleton.findBone(this.boneName);
                    if (!this.SetBone(this.boneName)) {
                        return;
                    }
                }

                var thisTransform = this.transform;
                var additionalFlipScale = 1;
                if (this.skeletonTransformIsParent) {
                    // Recommended setup: Use local transform properties if Spine GameObject is the immediate parent
                    thisTransform.localPosition = new pc.Vec3( this.followXYPosition ? this.bone.worldX : thisTransform.localPosition.x, this.followXYPosition ? this.bone.worldY : thisTransform.localPosition.y, this.followZPosition ? 0.0 : thisTransform.localPosition.z );
                    if (this.followBoneRotation) {
                        var halfRotation = Math.atan2(this.bone.c, this.bone.a) * 0.5;
                        if (this.followLocalScale && this.bone.scaleX < 0) {
                            halfRotation += 1.57079637;
                        }

                        var q = Bridge.getDefaultValue(UnityEngine.Quaternion);
                        q.z = Math.sin(halfRotation);
                        q.w = Math.cos(halfRotation);
                        thisTransform.localRotation = q.$clone();
                    }
                } else {
                    // For special cases: Use transform world properties if transform relationship is complicated
                    var targetWorldPosition = this.skeletonTransform.TransformPoint$1(new pc.Vec3( this.bone.worldX, this.bone.worldY, 0.0 ));
                    if (!this.followZPosition) {
                        targetWorldPosition.z = thisTransform.position.z;
                    }
                    if (!this.followXYPosition) {
                        targetWorldPosition.x = thisTransform.position.x;
                        targetWorldPosition.y = thisTransform.position.y;
                    }

                    var skeletonLossyScale = this.skeletonTransform.lossyScale.$clone();
                    var transformParent = thisTransform.parent;
                    var parentLossyScale = UnityEngine.Component.op_Inequality(transformParent, null) ? transformParent.lossyScale.$clone() : new pc.Vec3( 1, 1, 1 );
                    if (this.followBoneRotation) {
                        var boneWorldRotation = this.bone.getWorldRotationX();

                        if ((skeletonLossyScale.x * skeletonLossyScale.y) < 0) {
                            boneWorldRotation = -boneWorldRotation;
                        }

                        if (this.followSkeletonFlip || this.maintainedAxisOrientation === Spine.Unity.BoneFollower.AxisOrientation.XAxis) {
                            if ((skeletonLossyScale.x * parentLossyScale.x < 0)) {
                                boneWorldRotation += 180.0;
                            }
                        } else {
                            if ((skeletonLossyScale.y * parentLossyScale.y < 0)) {
                                boneWorldRotation += 180.0;
                            }
                        }

                        var worldRotation = this.skeletonTransform.rotation.getPositiveEulerAngles().$clone();
                        if (this.followLocalScale && this.bone.scaleX < 0) {
                            boneWorldRotation += 180.0;
                        }
                        thisTransform.SetPositionAndRotation(targetWorldPosition.$clone(), new pc.Quat().setFromEulerAngles_Unity( worldRotation.x, worldRotation.y, worldRotation.z + boneWorldRotation ));
                    } else {
                        thisTransform.position = targetWorldPosition.$clone();
                    }

                    additionalFlipScale = ($t = skeletonLossyScale.x * parentLossyScale.x * skeletonLossyScale.y * parentLossyScale.y, ($t === 0 ? 1 : Math.sign($t)));
                }

                var parentBone = this.bone.parent;
                if (this.followParentWorldScale || this.followLocalScale || this.followSkeletonFlip) {
                    var localScale = new pc.Vec3( 1.0, 1.0, 1.0 );
                    if (this.followParentWorldScale && parentBone != null) {
                        localScale = new pc.Vec3( parentBone.getWorldScaleX(), parentBone.getWorldScaleY(), 1.0 );
                    }
                    if (this.followLocalScale) {
                        localScale.mul( new pc.Vec3( this.bone.scaleX, this.bone.scaleY, 1.0 ) );
                    }
                    if (this.followSkeletonFlip) {
                        localScale.y *= ($t1 = this.bone.skeleton.scaleX * this.bone.skeleton.scaleY, ($t1 === 0 ? 1 : Math.sign($t1))) * additionalFlipScale;
                    }
                    thisTransform.localScale = localScale.$clone();
                }
            },
            /*Spine.Unity.BoneFollower.LateUpdate end.*/


        }
    });
    /*Spine.Unity.BoneFollower end.*/

    /*Spine.Unity.BoneFollower+AxisOrientation start.*/
    Bridge.define("Spine.Unity.BoneFollower.AxisOrientation", {
        $kind: 1006,
        statics: {
            fields: {
                XAxis: 1,
                YAxis: 2
            }
        }
    });
    /*Spine.Unity.BoneFollower+AxisOrientation end.*/

    /*Spine.Unity.BoneFollowerGraphic start.*/
    Bridge.define("Spine.Unity.BoneFollowerGraphic", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            skeletonGraphic: null,
            initializeOnAwake: false,
            /**
             * If a bone isn't set in code, boneName is used to find the bone at the beginning. For runtime switching by name, use SetBoneByName. You can also set the BoneFollower.bone field directly.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.BoneFollowerGraphic
             * @type string
             */
            boneName: null,
            followBoneRotation: false,
            followSkeletonFlip: false,
            followLocalScale: false,
            followParentWorldScale: false,
            followXYPosition: false,
            followZPosition: false,
            maintainedAxisOrientation: 0,
            bone: null,
            skeletonTransform: null,
            skeletonTransformIsParent: false,
            valid: false
        },
        props: {
            SkeletonGraphic: {
                get: function () {
                    return this.skeletonGraphic;
                },
                set: function (value) {
                    this.skeletonGraphic = value;
                    this.Initialize();
                }
            }
        },
        ctors: {
            init: function () {
                this.initializeOnAwake = true;
                this.followBoneRotation = true;
                this.followSkeletonFlip = true;
                this.followLocalScale = false;
                this.followParentWorldScale = false;
                this.followXYPosition = true;
                this.followZPosition = true;
                this.maintainedAxisOrientation = Spine.Unity.BoneFollower.AxisOrientation.XAxis;
            }
        },
        methods: {
            /*Spine.Unity.BoneFollowerGraphic.SetBone start.*/
            /**
             * Sets the target bone by its bone name. Returns false if no bone was found.
             *
             * @instance
             * @public
             * @this Spine.Unity.BoneFollowerGraphic
             * @memberof Spine.Unity.BoneFollowerGraphic
             * @param   {string}     name
             * @return  {boolean}
             */
            SetBone: function (name) {
                this.bone = this.skeletonGraphic.Skeleton.findBone(name);
                if (this.bone == null) {
                    UnityEngine.Debug.LogError$2("Bone not found: " + (name || ""), this);
                    return false;
                }
                this.boneName = name;
                return true;
            },
            /*Spine.Unity.BoneFollowerGraphic.SetBone end.*/

            /*Spine.Unity.BoneFollowerGraphic.Awake start.*/
            Awake: function () {
                if (this.initializeOnAwake) {
                    this.Initialize();
                }
            },
            /*Spine.Unity.BoneFollowerGraphic.Awake end.*/

            /*Spine.Unity.BoneFollowerGraphic.Initialize start.*/
            Initialize: function () {
                this.bone = null;
                this.valid = UnityEngine.MonoBehaviour.op_Inequality(this.skeletonGraphic, null) && this.skeletonGraphic.IsValid;
                if (!this.valid) {
                    return;
                }

                this.skeletonTransform = this.skeletonGraphic.transform;
                //			skeletonGraphic.OnRebuild -= HandleRebuildRenderer;
                //			skeletonGraphic.OnRebuild += HandleRebuildRenderer;
                this.skeletonTransformIsParent = Bridge.referenceEquals(this.skeletonTransform, this.transform.parent);

                if (!System.String.isNullOrEmpty(this.boneName)) {
                    this.bone = this.skeletonGraphic.Skeleton.findBone(this.boneName);
                }

            },
            /*Spine.Unity.BoneFollowerGraphic.Initialize end.*/

            /*Spine.Unity.BoneFollowerGraphic.LateUpdate start.*/
            LateUpdate: function () {
                var $t, $t1;
                if (!this.valid) {
                    this.Initialize();
                    return;
                }


                if (this.bone == null) {
                    if (System.String.isNullOrEmpty(this.boneName)) {
                        return;
                    }
                    this.bone = this.skeletonGraphic.Skeleton.findBone(this.boneName);
                    if (!this.SetBone(this.boneName)) {
                        return;
                    }
                }

                var thisTransform = Bridge.as(this.transform, UnityEngine.RectTransform);
                if (UnityEngine.Component.op_Equality(thisTransform, null)) {
                    return;
                }

                var scale = this.skeletonGraphic.MeshScale;

                var additionalFlipScale = 1;
                if (this.skeletonTransformIsParent) {
                    // Recommended setup: Use local transform properties if Spine GameObject is the immediate parent
                    thisTransform.localPosition = new pc.Vec3( this.followXYPosition ? this.bone.worldX * scale : thisTransform.localPosition.x, this.followXYPosition ? this.bone.worldY * scale : thisTransform.localPosition.y, this.followZPosition ? 0.0 : thisTransform.localPosition.z );
                    if (this.followBoneRotation) {
                        thisTransform.localRotation = Spine.Unity.SkeletonExtensions.GetQuaternion(this.bone);
                    }
                } else {
                    // For special cases: Use transform world properties if transform relationship is complicated
                    var targetWorldPosition = this.skeletonTransform.TransformPoint$1(new pc.Vec3( this.bone.worldX * scale, this.bone.worldY * scale, 0.0 ));
                    if (!this.followZPosition) {
                        targetWorldPosition.z = thisTransform.position.z;
                    }
                    if (!this.followXYPosition) {
                        targetWorldPosition.x = thisTransform.position.x;
                        targetWorldPosition.y = thisTransform.position.y;
                    }

                    var skeletonLossyScale = this.skeletonTransform.lossyScale.$clone();
                    var transformParent = thisTransform.parent;
                    var parentLossyScale = UnityEngine.Component.op_Inequality(transformParent, null) ? transformParent.lossyScale.$clone() : new pc.Vec3( 1, 1, 1 );
                    if (this.followBoneRotation) {
                        var boneWorldRotation = this.bone.getWorldRotationX();

                        if ((skeletonLossyScale.x * skeletonLossyScale.y) < 0) {
                            boneWorldRotation = -boneWorldRotation;
                        }

                        if (this.followSkeletonFlip || this.maintainedAxisOrientation === Spine.Unity.BoneFollower.AxisOrientation.XAxis) {
                            if ((skeletonLossyScale.x * parentLossyScale.x < 0)) {
                                boneWorldRotation += 180.0;
                            }
                        } else {
                            if ((skeletonLossyScale.y * parentLossyScale.y < 0)) {
                                boneWorldRotation += 180.0;
                            }
                        }

                        var worldRotation = this.skeletonTransform.rotation.getPositiveEulerAngles().$clone();
                        if (this.followLocalScale && this.bone.scaleX < 0) {
                            boneWorldRotation += 180.0;
                        }
                        thisTransform.SetPositionAndRotation(targetWorldPosition.$clone(), new pc.Quat().setFromEulerAngles_Unity( worldRotation.x, worldRotation.y, worldRotation.z + boneWorldRotation ));
                    } else {
                        thisTransform.position = targetWorldPosition.$clone();
                    }

                    additionalFlipScale = ($t = skeletonLossyScale.x * parentLossyScale.x * skeletonLossyScale.y * parentLossyScale.y, ($t === 0 ? 1 : Math.sign($t)));
                }

                var parentBone = this.bone.parent;
                if (this.followParentWorldScale || this.followLocalScale || this.followSkeletonFlip) {
                    var localScale = new pc.Vec3( 1.0, 1.0, 1.0 );
                    if (this.followParentWorldScale && parentBone != null) {
                        localScale = new pc.Vec3( parentBone.getWorldScaleX(), parentBone.getWorldScaleY(), 1.0 );
                    }
                    if (this.followLocalScale) {
                        localScale.mul( new pc.Vec3( this.bone.scaleX, this.bone.scaleY, 1.0 ) );
                    }
                    if (this.followSkeletonFlip) {
                        localScale.y *= ($t1 = this.bone.skeleton.scaleX * this.bone.skeleton.scaleY, ($t1 === 0 ? 1 : Math.sign($t1))) * additionalFlipScale;
                    }
                    thisTransform.localScale = localScale.$clone();
                }
            },
            /*Spine.Unity.BoneFollowerGraphic.LateUpdate end.*/


        }
    });
    /*Spine.Unity.BoneFollowerGraphic end.*/

    /*Spine.Unity.BoundingBoxFollower start.*/
    Bridge.define("Spine.Unity.BoundingBoxFollower", {
        inherits: [UnityEngine.MonoBehaviour],
        statics: {
            fields: {
                DebugMessages: false
            },
            ctors: {
                init: function () {
                    this.DebugMessages = true;
                }
            }
        },
        fields: {
            skeletonRenderer: null,
            slotName: null,
            isTrigger: false,
            usedByEffector: false,
            usedByComposite: false,
            clearStateOnDisable: false,
            slot: null,
            currentAttachment: null,
            currentAttachmentName: null,
            currentCollider: null,
            colliderTable: null,
            nameTable: null
        },
        props: {
            Slot: {
                get: function () {
                    return this.slot;
                }
            },
            CurrentAttachment: {
                get: function () {
                    return this.currentAttachment;
                }
            },
            CurrentAttachmentName: {
                get: function () {
                    return this.currentAttachmentName;
                }
            },
            CurrentCollider: {
                get: function () {
                    return this.currentCollider;
                }
            },
            IsTrigger: {
                get: function () {
                    return this.isTrigger;
                }
            }
        },
        ctors: {
            init: function () {
                this.clearStateOnDisable = true;
                this.colliderTable = new (System.Collections.Generic.Dictionary$2(spine.BoundingBoxAttachment,UnityEngine.PolygonCollider2D)).ctor();
                this.nameTable = new (System.Collections.Generic.Dictionary$2(spine.BoundingBoxAttachment,System.String)).ctor();
            }
        },
        methods: {
            /*Spine.Unity.BoundingBoxFollower.Start start.*/
            Start: function () {
                this.Initialize();
            },
            /*Spine.Unity.BoundingBoxFollower.Start end.*/

            /*Spine.Unity.BoundingBoxFollower.OnEnable start.*/
            OnEnable: function () {
                if (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonRenderer, null)) {
                    this.skeletonRenderer.removeOnRebuild(Bridge.fn.cacheBind(this, this.HandleRebuild));
                    this.skeletonRenderer.addOnRebuild(Bridge.fn.cacheBind(this, this.HandleRebuild));
                }

                this.Initialize();
            },
            /*Spine.Unity.BoundingBoxFollower.OnEnable end.*/

            /*Spine.Unity.BoundingBoxFollower.HandleRebuild start.*/
            HandleRebuild: function (sr) {
                //if (BoundingBoxFollower.DebugMessages) Debug.Log("Skeleton was rebuilt. Repopulating BoundingBoxFollower.");
                this.Initialize();
            },
            /*Spine.Unity.BoundingBoxFollower.HandleRebuild end.*/

            /*Spine.Unity.BoundingBoxFollower.Initialize start.*/
            /**
             * Initialize and instantiate the BoundingBoxFollower colliders. This is method checks if the BoundingBoxFollower has already been initialized for the skeleton instance and slotName and prevents overwriting unless it detects a new setup.
             *
             * @instance
             * @public
             * @this Spine.Unity.BoundingBoxFollower
             * @memberof Spine.Unity.BoundingBoxFollower
             * @param   {boolean}    overwrite
             * @return  {void}
             */
            Initialize: function (overwrite) {
                var $t;
                if (overwrite === void 0) { overwrite = false; }
                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonRenderer, null)) {
                    return;
                }

                this.skeletonRenderer.Initialize(false);

                if (System.String.isNullOrEmpty(this.slotName)) {
                    return;
                }

                // Don't reinitialize if the setup did not change.
                if (!overwrite && this.colliderTable.Count > 0 && this.slot != null && Bridge.referenceEquals(this.skeletonRenderer.skeleton, this.slot.getSkeleton()) && Bridge.referenceEquals(this.slotName, this.slot.data.name)) {
                    return;
                }

                this.slot = null;
                this.currentAttachment = null;
                this.currentAttachmentName = null;
                this.currentCollider = null;
                this.colliderTable.clear();
                this.nameTable.clear();

                var skeleton = this.skeletonRenderer.skeleton;
                if (skeleton == null) {
                    return;
                }
                this.slot = skeleton.findSlot(this.slotName);
                if (this.slot == null) {
                    if (Spine.Unity.BoundingBoxFollower.DebugMessages) {
                        UnityEngine.Debug.LogWarning$1(System.String.format("Slot '{0}' not found for BoundingBoxFollower on '{1}'. (Previous colliders were disposed.)", this.slotName, this.gameObject.name));
                    }
                    return;
                }
                var slotIndex = this.slot.data.index;

                var requiredCollidersCount = { v : 0 };
                var colliders = this.GetComponents(UnityEngine.PolygonCollider2D);
                if (this.gameObject.activeInHierarchy) {
                    $t = Bridge.getEnumerator(skeleton.data.Skins);
                    try {
                        while ($t.moveNext()) {
                            var skin = $t.Current;
                            this.AddCollidersForSkin(skin, slotIndex, colliders, requiredCollidersCount);
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }

                    if (skeleton.skin != null) {
                        this.AddCollidersForSkin(skeleton.skin, slotIndex, colliders, requiredCollidersCount);
                    }
                }
                this.DisposeExcessCollidersAfter(requiredCollidersCount.v);

                if (Spine.Unity.BoundingBoxFollower.DebugMessages) {
                    var valid = this.colliderTable.Count !== 0;
                    if (!valid) {
                        if (this.gameObject.activeInHierarchy) {
                            UnityEngine.Debug.LogWarning$1("Bounding Box Follower not valid! Slot [" + (this.slotName || "") + "] does not contain any Bounding Box Attachments!");
                        } else {
                            UnityEngine.Debug.LogWarning$1("Bounding Box Follower tried to rebuild as a prefab.");
                        }
                    }
                }
            },
            /*Spine.Unity.BoundingBoxFollower.Initialize end.*/

            /*Spine.Unity.BoundingBoxFollower.AddCollidersForSkin start.*/
            AddCollidersForSkin: function (skin, slotIndex, previousColliders, collidersCount) {
                var $t;
                if (skin == null) {
                    return;
                }
                var skinEntries = new (System.Collections.Generic.List$1(spine.SkinEntry)).ctor();
                ( skinEntries._items.length = 0, skin.getAttachmentsForSlot( slotIndex, skinEntries._items ), skinEntries._size = skinEntries._items.length );

                $t = Bridge.getEnumerator(skinEntries);
                try {
                    while ($t.moveNext()) {
                        var entry = $t.Current;
                        var attachment = skin.getAttachment(slotIndex, entry.name);
                        var boundingBoxAttachment = Bridge.as(attachment, spine.BoundingBoxAttachment);

                        if (Spine.Unity.BoundingBoxFollower.DebugMessages && attachment != null && boundingBoxAttachment == null) {
                            UnityEngine.Debug.Log$1("BoundingBoxFollower tried to follow a slot that contains non-boundingbox attachments: " + (this.slotName || ""));
                        }

                        if (boundingBoxAttachment != null) {
                            if (!this.colliderTable.containsKey(boundingBoxAttachment)) {
                                var bbCollider = collidersCount.v < previousColliders.length ? previousColliders[collidersCount.v] : this.gameObject.AddComponent(UnityEngine.PolygonCollider2D);
                                collidersCount.v = (collidersCount.v + 1) | 0;
                                Spine.Unity.SkeletonUtility.SetColliderPointsLocal(bbCollider, this.slot, boundingBoxAttachment);
                                bbCollider.isTrigger = this.isTrigger;
                                bbCollider.usedByEffector = this.usedByEffector;
                                bbCollider.usedByComposite = this.usedByComposite;
                                bbCollider.enabled = false;
                                bbCollider.hideFlags = UnityEngine.HideFlags.NotEditable;
                                this.colliderTable.add(boundingBoxAttachment, bbCollider);
                                this.nameTable.add(boundingBoxAttachment, entry.name);
                            }
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.Unity.BoundingBoxFollower.AddCollidersForSkin end.*/

            /*Spine.Unity.BoundingBoxFollower.OnDisable start.*/
            OnDisable: function () {
                if (this.clearStateOnDisable) {
                    this.ClearState();
                }

                if (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonRenderer, null)) {
                    this.skeletonRenderer.removeOnRebuild(Bridge.fn.cacheBind(this, this.HandleRebuild));
                }
            },
            /*Spine.Unity.BoundingBoxFollower.OnDisable end.*/

            /*Spine.Unity.BoundingBoxFollower.ClearState start.*/
            ClearState: function () {
                var $t;
                if (this.colliderTable != null) {
                    $t = Bridge.getEnumerator(this.colliderTable.Values);
                    try {
                        while ($t.moveNext()) {
                            var col = $t.Current;
                            col.enabled = false;
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                }

                this.currentAttachment = null;
                this.currentAttachmentName = null;
                this.currentCollider = null;
            },
            /*Spine.Unity.BoundingBoxFollower.ClearState end.*/

            /*Spine.Unity.BoundingBoxFollower.DisposeExcessCollidersAfter start.*/
            DisposeExcessCollidersAfter: function (requiredCount) {
                var colliders = this.GetComponents(UnityEngine.PolygonCollider2D);
                if (colliders.length === 0) {
                    return;
                }

                for (var i = requiredCount; i < colliders.length; i = (i + 1) | 0) {
                    var collider = colliders[i];
                    if (UnityEngine.Component.op_Inequality(collider, null)) {
                        UnityEngine.Object.Destroy(collider);
                    }
                }
            },
            /*Spine.Unity.BoundingBoxFollower.DisposeExcessCollidersAfter end.*/

            /*Spine.Unity.BoundingBoxFollower.LateUpdate start.*/
            LateUpdate: function () {
                if (this.slot != null && !Bridge.referenceEquals(this.slot.getAttachment(), this.currentAttachment)) {
                    this.MatchAttachment(this.slot.getAttachment());
                }
            },
            /*Spine.Unity.BoundingBoxFollower.LateUpdate end.*/

            /*Spine.Unity.BoundingBoxFollower.MatchAttachment start.*/
            /**
             * Sets the current collider to match attachment.
             *
             * @instance
             * @private
             * @this Spine.Unity.BoundingBoxFollower
             * @memberof Spine.Unity.BoundingBoxFollower
             * @param   {spine.Attachment}    attachment    If the attachment is not a bounding box, it will be treated as null.
             * @return  {void}
             */
            MatchAttachment: function (attachment) {
                var bbAttachment = Bridge.as(attachment, spine.BoundingBoxAttachment);

                if (Spine.Unity.BoundingBoxFollower.DebugMessages && attachment != null && bbAttachment == null) {
                    UnityEngine.Debug.LogWarning$1("BoundingBoxFollower tried to match a non-boundingbox attachment. It will treat it as null.");
                }

                if (UnityEngine.Component.op_Inequality(this.currentCollider, null)) {
                    this.currentCollider.enabled = false;
                }

                if (bbAttachment == null) {
                    this.currentCollider = null;
                    this.currentAttachment = null;
                    this.currentAttachmentName = null;
                } else {
                    var foundCollider = { };
                    this.colliderTable.tryGetValue(bbAttachment, foundCollider);
                    if (UnityEngine.Component.op_Inequality(foundCollider.v, null)) {
                        this.currentCollider = foundCollider.v;
                        this.currentCollider.enabled = true;
                        this.currentAttachment = bbAttachment;
                        this.currentAttachmentName = this.nameTable.getItem(bbAttachment);
                    } else {
                        this.currentCollider = null;
                        this.currentAttachment = bbAttachment;
                        this.currentAttachmentName = null;
                        if (Spine.Unity.BoundingBoxFollower.DebugMessages) {
                            UnityEngine.Debug.LogFormat("Collider for BoundingBoxAttachment named '{0}' was not initialized. It is possibly from a new skin. currentAttachmentName will be null. You may need to call BoundingBoxFollower.Initialize(overwrite: true);", [bbAttachment.name]);
                        }
                    }
                }
            },
            /*Spine.Unity.BoundingBoxFollower.MatchAttachment end.*/


        }
    });
    /*Spine.Unity.BoundingBoxFollower end.*/

    /*Spine.Unity.BoundingBoxFollowerGraphic start.*/
    Bridge.define("Spine.Unity.BoundingBoxFollowerGraphic", {
        inherits: [UnityEngine.MonoBehaviour],
        statics: {
            fields: {
                DebugMessages: false
            },
            ctors: {
                init: function () {
                    this.DebugMessages = true;
                }
            }
        },
        fields: {
            skeletonGraphic: null,
            slotName: null,
            isTrigger: false,
            usedByEffector: false,
            usedByComposite: false,
            clearStateOnDisable: false,
            slot: null,
            currentAttachment: null,
            currentAttachmentName: null,
            currentCollider: null,
            colliderTable: null,
            nameTable: null
        },
        props: {
            Slot: {
                get: function () {
                    return this.slot;
                }
            },
            CurrentAttachment: {
                get: function () {
                    return this.currentAttachment;
                }
            },
            CurrentAttachmentName: {
                get: function () {
                    return this.currentAttachmentName;
                }
            },
            CurrentCollider: {
                get: function () {
                    return this.currentCollider;
                }
            },
            IsTrigger: {
                get: function () {
                    return this.isTrigger;
                }
            }
        },
        ctors: {
            init: function () {
                this.clearStateOnDisable = true;
                this.colliderTable = new (System.Collections.Generic.Dictionary$2(spine.BoundingBoxAttachment,UnityEngine.PolygonCollider2D)).ctor();
                this.nameTable = new (System.Collections.Generic.Dictionary$2(spine.BoundingBoxAttachment,System.String)).ctor();
            }
        },
        methods: {
            /*Spine.Unity.BoundingBoxFollowerGraphic.Start start.*/
            Start: function () {
                this.Initialize();
            },
            /*Spine.Unity.BoundingBoxFollowerGraphic.Start end.*/

            /*Spine.Unity.BoundingBoxFollowerGraphic.OnEnable start.*/
            OnEnable: function () {
                if (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonGraphic, null)) {
                    this.skeletonGraphic.removeOnRebuild(Bridge.fn.cacheBind(this, this.HandleRebuild));
                    this.skeletonGraphic.addOnRebuild(Bridge.fn.cacheBind(this, this.HandleRebuild));
                }

                this.Initialize();
            },
            /*Spine.Unity.BoundingBoxFollowerGraphic.OnEnable end.*/

            /*Spine.Unity.BoundingBoxFollowerGraphic.HandleRebuild start.*/
            HandleRebuild: function (sr) {
                //if (BoundingBoxFollowerGraphic.DebugMessages) Debug.Log("Skeleton was rebuilt. Repopulating BoundingBoxFollowerGraphic.");
                this.Initialize();
            },
            /*Spine.Unity.BoundingBoxFollowerGraphic.HandleRebuild end.*/

            /*Spine.Unity.BoundingBoxFollowerGraphic.Initialize start.*/
            /**
             * Initialize and instantiate the BoundingBoxFollowerGraphic colliders. This is method checks if the BoundingBoxFollowerGraphic has already been initialized for the skeleton instance and slotName and prevents overwriting unless it detects a new setup.
             *
             * @instance
             * @public
             * @this Spine.Unity.BoundingBoxFollowerGraphic
             * @memberof Spine.Unity.BoundingBoxFollowerGraphic
             * @param   {boolean}    overwrite
             * @return  {void}
             */
            Initialize: function (overwrite) {
                var $t;
                if (overwrite === void 0) { overwrite = false; }
                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonGraphic, null)) {
                    return;
                }

                this.skeletonGraphic.Initialize(false);

                if (System.String.isNullOrEmpty(this.slotName)) {
                    return;
                }

                // Don't reinitialize if the setup did not change.
                if (!overwrite && this.colliderTable.Count > 0 && this.slot != null && Bridge.referenceEquals(this.skeletonGraphic.Skeleton, this.slot.getSkeleton()) && Bridge.referenceEquals(this.slotName, this.slot.data.name)) {
                    return;
                }

                this.slot = null;
                this.currentAttachment = null;
                this.currentAttachmentName = null;
                this.currentCollider = null;
                this.colliderTable.clear();
                this.nameTable.clear();

                var skeleton = this.skeletonGraphic.Skeleton;
                if (skeleton == null) {
                    return;
                }
                this.slot = skeleton.findSlot(this.slotName);
                if (this.slot == null) {
                    if (Spine.Unity.BoundingBoxFollowerGraphic.DebugMessages) {
                        UnityEngine.Debug.LogWarning$1(System.String.format("Slot '{0}' not found for BoundingBoxFollowerGraphic on '{1}'. (Previous colliders were disposed.)", this.slotName, this.gameObject.name));
                    }
                    return;
                }
                var slotIndex = this.slot.data.index;

                var requiredCollidersCount = { v : 0 };
                var colliders = this.GetComponents(UnityEngine.PolygonCollider2D);
                if (this.gameObject.activeInHierarchy) {
                    var scale = this.skeletonGraphic.MeshScale;
                    $t = Bridge.getEnumerator(skeleton.data.Skins);
                    try {
                        while ($t.moveNext()) {
                            var skin = $t.Current;
                            this.AddCollidersForSkin(skin, slotIndex, colliders, scale, requiredCollidersCount);
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }

                    if (skeleton.skin != null) {
                        this.AddCollidersForSkin(skeleton.skin, slotIndex, colliders, scale, requiredCollidersCount);
                    }
                }
                this.DisposeExcessCollidersAfter(requiredCollidersCount.v);

                if (Spine.Unity.BoundingBoxFollowerGraphic.DebugMessages) {
                    var valid = this.colliderTable.Count !== 0;
                    if (!valid) {
                        if (this.gameObject.activeInHierarchy) {
                            UnityEngine.Debug.LogWarning$1("Bounding Box Follower not valid! Slot [" + (this.slotName || "") + "] does not contain any Bounding Box Attachments!");
                        } else {
                            UnityEngine.Debug.LogWarning$1("Bounding Box Follower tried to rebuild as a prefab.");
                        }
                    }
                }
            },
            /*Spine.Unity.BoundingBoxFollowerGraphic.Initialize end.*/

            /*Spine.Unity.BoundingBoxFollowerGraphic.AddCollidersForSkin start.*/
            AddCollidersForSkin: function (skin, slotIndex, previousColliders, scale, collidersCount) {
                var $t;
                if (skin == null) {
                    return;
                }
                var skinEntries = new (System.Collections.Generic.List$1(spine.SkinEntry)).ctor();
                ( skinEntries._items.length = 0, skin.getAttachmentsForSlot( slotIndex, skinEntries._items ), skinEntries._size = skinEntries._items.length );

                $t = Bridge.getEnumerator(skinEntries);
                try {
                    while ($t.moveNext()) {
                        var entry = $t.Current;
                        var attachment = skin.getAttachment(slotIndex, entry.name);
                        var boundingBoxAttachment = Bridge.as(attachment, spine.BoundingBoxAttachment);

                        if (Spine.Unity.BoundingBoxFollowerGraphic.DebugMessages && attachment != null && boundingBoxAttachment == null) {
                            UnityEngine.Debug.Log$1("BoundingBoxFollowerGraphic tried to follow a slot that contains non-boundingbox attachments: " + (this.slotName || ""));
                        }

                        if (boundingBoxAttachment != null) {
                            if (!this.colliderTable.containsKey(boundingBoxAttachment)) {
                                var bbCollider = collidersCount.v < previousColliders.length ? previousColliders[collidersCount.v] : this.gameObject.AddComponent(UnityEngine.PolygonCollider2D);
                                collidersCount.v = (collidersCount.v + 1) | 0;
                                Spine.Unity.SkeletonUtility.SetColliderPointsLocal(bbCollider, this.slot, boundingBoxAttachment, scale);
                                bbCollider.isTrigger = this.isTrigger;
                                bbCollider.usedByEffector = this.usedByEffector;
                                bbCollider.usedByComposite = this.usedByComposite;
                                bbCollider.enabled = false;
                                bbCollider.hideFlags = UnityEngine.HideFlags.NotEditable;
                                this.colliderTable.add(boundingBoxAttachment, bbCollider);
                                this.nameTable.add(boundingBoxAttachment, entry.name);
                            }
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.Unity.BoundingBoxFollowerGraphic.AddCollidersForSkin end.*/

            /*Spine.Unity.BoundingBoxFollowerGraphic.OnDisable start.*/
            OnDisable: function () {
                if (this.clearStateOnDisable) {
                    this.ClearState();
                }

                if (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonGraphic, null)) {
                    this.skeletonGraphic.removeOnRebuild(Bridge.fn.cacheBind(this, this.HandleRebuild));
                }
            },
            /*Spine.Unity.BoundingBoxFollowerGraphic.OnDisable end.*/

            /*Spine.Unity.BoundingBoxFollowerGraphic.ClearState start.*/
            ClearState: function () {
                var $t;
                if (this.colliderTable != null) {
                    $t = Bridge.getEnumerator(this.colliderTable.Values);
                    try {
                        while ($t.moveNext()) {
                            var col = $t.Current;
                            col.enabled = false;
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                }

                this.currentAttachment = null;
                this.currentAttachmentName = null;
                this.currentCollider = null;
            },
            /*Spine.Unity.BoundingBoxFollowerGraphic.ClearState end.*/

            /*Spine.Unity.BoundingBoxFollowerGraphic.DisposeExcessCollidersAfter start.*/
            DisposeExcessCollidersAfter: function (requiredCount) {
                var colliders = this.GetComponents(UnityEngine.PolygonCollider2D);
                if (colliders.length === 0) {
                    return;
                }

                for (var i = requiredCount; i < colliders.length; i = (i + 1) | 0) {
                    var collider = colliders[i];
                    if (UnityEngine.Component.op_Inequality(collider, null)) {
                        UnityEngine.Object.Destroy(collider);
                    }
                }
            },
            /*Spine.Unity.BoundingBoxFollowerGraphic.DisposeExcessCollidersAfter end.*/

            /*Spine.Unity.BoundingBoxFollowerGraphic.LateUpdate start.*/
            LateUpdate: function () {
                if (this.slot != null && !Bridge.referenceEquals(this.slot.getAttachment(), this.currentAttachment)) {
                    this.MatchAttachment(this.slot.getAttachment());
                }
            },
            /*Spine.Unity.BoundingBoxFollowerGraphic.LateUpdate end.*/

            /*Spine.Unity.BoundingBoxFollowerGraphic.MatchAttachment start.*/
            /**
             * Sets the current collider to match attachment.
             *
             * @instance
             * @private
             * @this Spine.Unity.BoundingBoxFollowerGraphic
             * @memberof Spine.Unity.BoundingBoxFollowerGraphic
             * @param   {spine.Attachment}    attachment    If the attachment is not a bounding box, it will be treated as null.
             * @return  {void}
             */
            MatchAttachment: function (attachment) {
                var bbAttachment = Bridge.as(attachment, spine.BoundingBoxAttachment);

                if (Spine.Unity.BoundingBoxFollowerGraphic.DebugMessages && attachment != null && bbAttachment == null) {
                    UnityEngine.Debug.LogWarning$1("BoundingBoxFollowerGraphic tried to match a non-boundingbox attachment. It will treat it as null.");
                }

                if (UnityEngine.Component.op_Inequality(this.currentCollider, null)) {
                    this.currentCollider.enabled = false;
                }

                if (bbAttachment == null) {
                    this.currentCollider = null;
                    this.currentAttachment = null;
                    this.currentAttachmentName = null;
                } else {
                    var foundCollider = { };
                    this.colliderTable.tryGetValue(bbAttachment, foundCollider);
                    if (UnityEngine.Component.op_Inequality(foundCollider.v, null)) {
                        this.currentCollider = foundCollider.v;
                        this.currentCollider.enabled = true;
                        this.currentAttachment = bbAttachment;
                        this.currentAttachmentName = this.nameTable.getItem(bbAttachment);
                    } else {
                        this.currentCollider = null;
                        this.currentAttachment = bbAttachment;
                        this.currentAttachmentName = null;
                        if (Spine.Unity.BoundingBoxFollowerGraphic.DebugMessages) {
                            UnityEngine.Debug.LogFormat("Collider for BoundingBoxAttachment named '{0}' was not initialized. It is possibly from a new skin. currentAttachmentName will be null. You may need to call BoundingBoxFollowerGraphic.Initialize(overwrite: true);", [bbAttachment.name]);
                        }
                    }
                }
            },
            /*Spine.Unity.BoundingBoxFollowerGraphic.MatchAttachment end.*/


        }
    });
    /*Spine.Unity.BoundingBoxFollowerGraphic end.*/

    /*Spine.Unity.DoubleBuffered$1 start.*/
    Bridge.define("Spine.Unity.DoubleBuffered$1", function (T) { return {
        fields: {
            a: null,
            b: null,
            usingA: false
        },
        ctors: {
            init: function () {
                this.a = Bridge.createInstance(T);
                this.b = Bridge.createInstance(T);
            }
        },
        methods: {
            /*Spine.Unity.DoubleBuffered$1.GetCurrent start.*/
            GetCurrent: function () {
                return this.usingA ? Bridge.rValue(this.a) : Bridge.rValue(this.b);
            },
            /*Spine.Unity.DoubleBuffered$1.GetCurrent end.*/

            /*Spine.Unity.DoubleBuffered$1.GetNext start.*/
            GetNext: function () {
                this.usingA = !this.usingA;
                return this.usingA ? Bridge.rValue(this.a) : Bridge.rValue(this.b);
            },
            /*Spine.Unity.DoubleBuffered$1.GetNext end.*/


        }
    }; });
    /*Spine.Unity.DoubleBuffered$1 end.*/

    /*Spine.Unity.EventDataReferenceAsset start.*/
    Bridge.define("Spine.Unity.EventDataReferenceAsset", {
        inherits: [UnityEngine.ScriptableObject],
        statics: {
            fields: {
                QuietSkeletonData: false
            },
            ctors: {
                init: function () {
                    this.QuietSkeletonData = true;
                }
            },
            methods: {
                op_Implicit: function (asset) {
                    return asset.EventData;
                }
            }
        },
        fields: {
            skeletonDataAsset: null,
            eventName: null,
            eventData: null
        },
        props: {
            EventData: {
                get: function () {
                    if (this.eventData == null) {
                        this.Initialize();
                    }
                    return this.eventData;
                }
            }
        },
        methods: {
            /*Spine.Unity.EventDataReferenceAsset.Initialize start.*/
            Initialize: function () {
                if (this.skeletonDataAsset == null) {
                    return;
                }
                this.eventData = this.skeletonDataAsset.GetSkeletonData(Spine.Unity.EventDataReferenceAsset.QuietSkeletonData).findEvent(this.eventName);
                if (this.eventData == null) {
                    UnityEngine.Debug.LogWarningFormat("Event Data '{0}' not found in SkeletonData : {1}.", [this.eventName, this.skeletonDataAsset.name]);
                }
            },
            /*Spine.Unity.EventDataReferenceAsset.Initialize end.*/


        }
    });
    /*Spine.Unity.EventDataReferenceAsset end.*/

    /*Spine.Unity.FollowLocationRigidbody start.*/
    /**
     * Utility component to support flipping of hinge chains (chains of HingeJoint objects) along with the parent skeleton.
     Note: This component is automatically attached when calling "Create Hinge Chain" at {@link }.
     *
     * @public
     * @class Spine.Unity.FollowLocationRigidbody
     * @augments UnityEngine.MonoBehaviour
     */
    Bridge.define("Spine.Unity.FollowLocationRigidbody", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            reference: null,
            ownRigidbody: null
        },
        methods: {
            /*Spine.Unity.FollowLocationRigidbody.Awake start.*/
            Awake: function () {
                this.ownRigidbody = this.GetComponent(UnityEngine.Rigidbody);
            },
            /*Spine.Unity.FollowLocationRigidbody.Awake end.*/

            /*Spine.Unity.FollowLocationRigidbody.FixedUpdate start.*/
            FixedUpdate: function () {
                this.ownRigidbody.rotation = this.reference.rotation.$clone();
                this.ownRigidbody.position = this.reference.position.$clone();
            },
            /*Spine.Unity.FollowLocationRigidbody.FixedUpdate end.*/


        }
    });
    /*Spine.Unity.FollowLocationRigidbody end.*/

    /*Spine.Unity.FollowLocationRigidbody2D start.*/
    /**
     * Utility component to support flipping of hinge chains (chains of HingeJoint objects) along with the parent skeleton.
     Note: This component is automatically attached when calling "Create Hinge Chain" at {@link }.
     *
     * @public
     * @class Spine.Unity.FollowLocationRigidbody2D
     * @augments UnityEngine.MonoBehaviour
     */
    Bridge.define("Spine.Unity.FollowLocationRigidbody2D", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            reference: null,
            followFlippedX: false,
            ownRigidbody: null
        },
        methods: {
            /*Spine.Unity.FollowLocationRigidbody2D.Awake start.*/
            Awake: function () {
                this.ownRigidbody = this.GetComponent(UnityEngine.Rigidbody2D);
            },
            /*Spine.Unity.FollowLocationRigidbody2D.Awake end.*/

            /*Spine.Unity.FollowLocationRigidbody2D.FixedUpdate start.*/
            FixedUpdate: function () {
                if (this.followFlippedX) {
                    this.ownRigidbody.rotation = ((-this.reference.rotation.getPositiveEulerAngles().z + 270.0) % 360.0) - 90.0;
                } else {
                    this.ownRigidbody.rotation = this.reference.rotation.getPositiveEulerAngles().z;
                }
                this.ownRigidbody.position = UnityEngine.Vector2.FromVector3(this.reference.position.$clone());
            },
            /*Spine.Unity.FollowLocationRigidbody2D.FixedUpdate end.*/


        }
    });
    /*Spine.Unity.FollowLocationRigidbody2D end.*/

    /*Spine.Unity.FollowSkeletonUtilityRootRotation start.*/
    /**
     * Utility component to support flipping of hinge chains (chains of HingeJoint objects) along with the parent skeleton.
     Note that flipping needs to be performed by 180 degree rotation at {@link },
     by setting {@link } to true, not via negative scale.
     Note: This component is automatically attached when calling "Create Hinge Chain" at {@link },
     do not attempt to use this component for other purposes.
     *
     * @public
     * @class Spine.Unity.FollowSkeletonUtilityRootRotation
     * @augments UnityEngine.MonoBehaviour
     */
    Bridge.define("Spine.Unity.FollowSkeletonUtilityRootRotation", {
        inherits: [UnityEngine.MonoBehaviour],
        statics: {
            fields: {
                FLIP_ANGLE_THRESHOLD: 0
            },
            ctors: {
                init: function () {
                    this.FLIP_ANGLE_THRESHOLD = 100.0;
                }
            }
        },
        fields: {
            reference: null,
            prevLocalEulerAngles: null
        },
        ctors: {
            init: function () {
                this.prevLocalEulerAngles = new UnityEngine.Vector3();
            }
        },
        methods: {
            /*Spine.Unity.FollowSkeletonUtilityRootRotation.Start start.*/
            Start: function () {
                this.prevLocalEulerAngles = this.transform.localEulerAngles.$clone();
            },
            /*Spine.Unity.FollowSkeletonUtilityRootRotation.Start end.*/

            /*Spine.Unity.FollowSkeletonUtilityRootRotation.FixedUpdate start.*/
            FixedUpdate: function () {
                this.transform.rotation = this.reference.rotation.$clone();

                var wasFlippedAroundY = Math.abs(this.transform.localEulerAngles.y - this.prevLocalEulerAngles.y) > Spine.Unity.FollowSkeletonUtilityRootRotation.FLIP_ANGLE_THRESHOLD;
                var wasFlippedAroundX = Math.abs(this.transform.localEulerAngles.x - this.prevLocalEulerAngles.x) > Spine.Unity.FollowSkeletonUtilityRootRotation.FLIP_ANGLE_THRESHOLD;
                if (wasFlippedAroundY) {
                    this.CompensatePositionToYRotation();
                }
                if (wasFlippedAroundX) {
                    this.CompensatePositionToXRotation();
                }

                this.prevLocalEulerAngles = this.transform.localEulerAngles.$clone();
            },
            /*Spine.Unity.FollowSkeletonUtilityRootRotation.FixedUpdate end.*/

            /*Spine.Unity.FollowSkeletonUtilityRootRotation.CompensatePositionToYRotation start.*/
            /**
             * Compensates the position so that a child at the reference position remains in the same place,
             to counter any movement that occurred by rotation.
             *
             * @instance
             * @private
             * @this Spine.Unity.FollowSkeletonUtilityRootRotation
             * @memberof Spine.Unity.FollowSkeletonUtilityRootRotation
             * @return  {void}
             */
            CompensatePositionToYRotation: function () {
                var newPosition = this.reference.position.$clone().add( (this.reference.position.$clone().sub( this.transform.position )) );
                newPosition.y = this.transform.position.y;
                this.transform.position = newPosition.$clone();
            },
            /*Spine.Unity.FollowSkeletonUtilityRootRotation.CompensatePositionToYRotation end.*/

            /*Spine.Unity.FollowSkeletonUtilityRootRotation.CompensatePositionToXRotation start.*/
            /**
             * Compensates the position so that a child at the reference position remains in the same place,
             to counter any movement that occurred by rotation.
             *
             * @instance
             * @private
             * @this Spine.Unity.FollowSkeletonUtilityRootRotation
             * @memberof Spine.Unity.FollowSkeletonUtilityRootRotation
             * @return  {void}
             */
            CompensatePositionToXRotation: function () {
                var newPosition = this.reference.position.$clone().add( (this.reference.position.$clone().sub( this.transform.position )) );
                newPosition.x = this.transform.position.x;
                this.transform.position = newPosition.$clone();
            },
            /*Spine.Unity.FollowSkeletonUtilityRootRotation.CompensatePositionToXRotation end.*/


        }
    });
    /*Spine.Unity.FollowSkeletonUtilityRootRotation end.*/

    /*Spine.Unity.ISpineComponentExtensions start.*/
    Bridge.define("Spine.Unity.ISpineComponentExtensions", {
        statics: {
            methods: {
                /*Spine.Unity.ISpineComponentExtensions.IsNullOrDestroyed:static start.*/
                IsNullOrDestroyed: function (component) {
                    if (component == null) {
                        return true;
                    }
                    return Bridge.cast(component, UnityEngine.Object) == null;
                },
                /*Spine.Unity.ISpineComponentExtensions.IsNullOrDestroyed:static end.*/


            }
        }
    });
    /*Spine.Unity.ISpineComponentExtensions end.*/

    /*Spine.Unity.MaterialsTextureLoader start.*/
    Bridge.define("Spine.Unity.MaterialsTextureLoader", {
        inherits: [Spine.TextureLoader],
        fields: {
            atlasAsset: null
        },
        alias: [
            "Load", "Spine$TextureLoader$Load",
            "Unload", "Spine$TextureLoader$Unload"
        ],
        ctors: {
            ctor: function (atlasAsset) {
                this.$initialize();
                this.atlasAsset = atlasAsset;
            }
        },
        methods: {
            /*Spine.Unity.MaterialsTextureLoader.Load start.*/
            Load: function (page, path) {
                var $t;
                var name = System.IO.Path.GetFileNameWithoutExtension(path);
                var material = null;
                $t = Bridge.getEnumerator(this.atlasAsset.materials);
                try {
                    while ($t.moveNext()) {
                        var other = $t.Current;
                        if (other.mainTexture == null) {
                            UnityEngine.Debug.LogError$2("Material is missing texture: " + (other.name || ""), other);
                            return;
                        }
                        var textureName = other.mainTexture.name;
                        if (Bridge.referenceEquals(textureName, name) || (this.atlasAsset.OnDemandTextureLoader != null && Bridge.referenceEquals(textureName, this.atlasAsset.OnDemandTextureLoader.GetPlaceholderTextureName(name)))) {
                            material = other;
                            break;
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                if (material == null) {
                    UnityEngine.Debug.LogError$2("Material with texture name \"" + (name || "") + "\" not found for atlas asset: " + (this.atlasAsset.name || ""), this.atlasAsset);
                    return;
                }
                page.rendererObject = material;

                // Very old atlas files expected the texture's actual size to be used at runtime.
                if (page.width === 0 || page.height === 0) {
                    page.width = material.mainTexture.width;
                    page.height = material.mainTexture.height;
                }
            },
            /*Spine.Unity.MaterialsTextureLoader.Load end.*/

            /*Spine.Unity.MaterialsTextureLoader.Unload start.*/
            Unload: function (texture) { },
            /*Spine.Unity.MaterialsTextureLoader.Unload end.*/


        }
    });
    /*Spine.Unity.MaterialsTextureLoader end.*/

    /*Spine.Unity.MathUtilities start.*/
    Bridge.define("Spine.Unity.MathUtilities", {
        statics: {
            methods: {
                /*Spine.Unity.MathUtilities.InverseLerp:static start.*/
                InverseLerp: function (a, b, value) {
                    return (value - a) / (b - a);
                },
                /*Spine.Unity.MathUtilities.InverseLerp:static end.*/

                /*Spine.Unity.MathUtilities.InverseLerp$1:static start.*/
                /**
                 * Returns the linear interpolation ratio of <pre><code>a</code></pre> to <pre><code>b</code></pre> that <pre><code>value</code></pre> lies on.
                 This is the t value that fulfills <pre><code>value = lerp(a, b, t)</code></pre>.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.MathUtilities
                 * @memberof Spine.Unity.MathUtilities
                 * @param   {UnityEngine.Vector2}    a        
                 * @param   {UnityEngine.Vector2}    b        
                 * @param   {UnityEngine.Vector2}    value
                 * @return  {UnityEngine.Vector2}
                 */
                InverseLerp$1: function (a, b, value) {
                    return new pc.Vec2( (value.x - a.x) / (b.x - a.x), (value.y - a.y) / (b.y - a.y) );
                },
                /*Spine.Unity.MathUtilities.InverseLerp$1:static end.*/

                /*Spine.Unity.MathUtilities.InverseLerp$2:static start.*/
                /**
                 * Returns the linear interpolation ratio of <pre><code>a</code></pre> to <pre><code>b</code></pre> that <pre><code>value</code></pre> lies on.
                 This is the t value that fulfills <pre><code>value = lerp(a, b, t)</code></pre>.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.MathUtilities
                 * @memberof Spine.Unity.MathUtilities
                 * @param   {UnityEngine.Vector3}    a        
                 * @param   {UnityEngine.Vector3}    b        
                 * @param   {UnityEngine.Vector3}    value
                 * @return  {UnityEngine.Vector3}
                 */
                InverseLerp$2: function (a, b, value) {
                    return new pc.Vec3( (value.x - a.x) / (b.x - a.x), (value.y - a.y) / (b.y - a.y), (value.z - a.z) / (b.z - a.z) );
                },
                /*Spine.Unity.MathUtilities.InverseLerp$2:static end.*/

                /*Spine.Unity.MathUtilities.InverseLerp$3:static start.*/
                /**
                 * Returns the linear interpolation ratio of <pre><code>a</code></pre> to <pre><code>b</code></pre> that <pre><code>value</code></pre> lies on.
                 This is the t value that fulfills <pre><code>value = lerp(a, b, t)</code></pre>.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.MathUtilities
                 * @memberof Spine.Unity.MathUtilities
                 * @param   {UnityEngine.Vector4}    a        
                 * @param   {UnityEngine.Vector4}    b        
                 * @param   {UnityEngine.Vector4}    value
                 * @return  {UnityEngine.Vector4}
                 */
                InverseLerp$3: function (a, b, value) {
                    return new pc.Vec4( (value.x - a.x) / (b.x - a.x), (value.y - a.y) / (b.y - a.y), (value.z - a.z) / (b.z - a.z), (value.w - a.w) / (b.w - a.w) );
                },
                /*Spine.Unity.MathUtilities.InverseLerp$3:static end.*/


            }
        }
    });
    /*Spine.Unity.MathUtilities end.*/

    /*Spine.Unity.MeshGenerator start.*/
    /**
     * Holds several methods to prepare and generate a UnityEngine mesh based on a skeleton. Contains buffers needed to perform the operation, and serializes settings for mesh generation.
     *
     * @public
     * @class Spine.Unity.MeshGenerator
     */
    Bridge.define("Spine.Unity.MeshGenerator", {
        statics: {
            fields: {
                BoundsMinDefault: 0,
                BoundsMaxDefault: 0,
                AttachmentVerts: null,
                AttachmentUVs: null,
                AttachmentColors32: null,
                AttachmentIndices: null
            },
            ctors: {
                init: function () {
                    this.BoundsMinDefault = Number.POSITIVE_INFINITY;
                    this.BoundsMaxDefault = Number.NEGATIVE_INFINITY;
                    this.AttachmentVerts = new (System.Collections.Generic.List$1(UnityEngine.Vector3)).ctor();
                    this.AttachmentUVs = new (System.Collections.Generic.List$1(UnityEngine.Vector2)).ctor();
                    this.AttachmentColors32 = new (System.Collections.Generic.List$1(UnityEngine.Color32)).ctor();
                    this.AttachmentIndices = new (System.Collections.Generic.List$1(System.Int32)).ctor();
                }
            },
            methods: {
                /*Spine.Unity.MeshGenerator.GenerateSingleSubmeshInstruction:static start.*/
                /**
                 * A specialized variant of {@link }.
                 Generates renderer instructions using a single submesh, using only a single material and texture.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.MeshGenerator
                 * @memberof Spine.Unity.MeshGenerator
                 * @param   {Spine.Unity.SkeletonRendererInstruction}    instructionOutput    The resulting instructions.
                 * @param   {Spine.Skeleton}                             skeleton             The skeleton to generate renderer instructions for.
                 * @param   {UnityEngine.Material}                       material             Material to be set at the renderer instruction. When null, the last attachment
                 in the draw order list is assigned as the instruction's material.
                 * @return  {void}
                 */
                GenerateSingleSubmeshInstruction: function (instructionOutput, skeleton, material) {
                    var $t;
                    var drawOrder = skeleton.DrawOrder;
                    var drawOrderCount = drawOrder.Count;

                    // Clear last state of attachments and submeshes
                    instructionOutput.Clear(); // submeshInstructions.Clear(); attachments.Clear();
                    var workingSubmeshInstructions = instructionOutput.submeshInstructions;

                    instructionOutput.attachments.Resize(drawOrderCount);
                    var workingAttachmentsItems = instructionOutput.attachments.Items;
                    var totalRawVertexCount = 0;

                    var current = ($t = new Spine.Unity.SubmeshInstruction(), $t.skeleton = skeleton, $t.preActiveClippingSlotSource = -1, $t.startSlot = 0, $t.rawFirstVertexIndex = 0, $t.material = material, $t.forceSeparate = false, $t.endSlot = drawOrderCount, $t);

                    var rendererObject = null;
                    var skeletonHasClipping = false;
                    var drawOrderItems = drawOrder.Items;
                    for (var i = 0; i < drawOrderCount; i = (i + 1) | 0) {
                        var slot = drawOrderItems[i];
                        if (!slot.bone.isActive()) {
                            workingAttachmentsItems[i] = null;
                            continue;
                        }
                        if (slot.data.blendMode === spine.BlendMode.Additive) {
                            current.hasPMAAdditiveSlot = true;
                        }
                        var attachment = slot.getAttachment();

                        workingAttachmentsItems[i] = attachment;
                        var attachmentTriangleCount;
                        var attachmentVertexCount;

                        var regionAttachment = Bridge.as(attachment, Spine.RegionAttachment);
                        if (regionAttachment != null) {
                            if (regionAttachment.sequence != null) {
                                regionAttachment.sequence.apply(slot, regionAttachment);
                            }
                            rendererObject = regionAttachment.region;
                            attachmentVertexCount = 4;
                            attachmentTriangleCount = 6;
                        } else {
                            var meshAttachment = Bridge.as(attachment, Spine.MeshAttachment);
                            if (meshAttachment != null) {
                                if (meshAttachment.sequence != null) {
                                    meshAttachment.sequence.apply(slot, meshAttachment);
                                }
                                rendererObject = meshAttachment.region;
                                attachmentVertexCount = meshAttachment.worldVerticesLength >> 1;
                                attachmentTriangleCount = meshAttachment.triangles.length;
                            } else {
                                var clippingAttachment = Bridge.as(attachment, spine.ClippingAttachment);
                                if (clippingAttachment != null) {
                                    current.hasClipping = true;
                                    skeletonHasClipping = true;
                                }
                                attachmentVertexCount = 0;
                                attachmentTriangleCount = 0;
                            }
                        }
                        current.rawTriangleCount = (current.rawTriangleCount + attachmentTriangleCount) | 0;
                        current.rawVertexCount = (current.rawVertexCount + attachmentVertexCount) | 0;
                        totalRawVertexCount = (totalRawVertexCount + attachmentVertexCount) | 0;
                    }

                    if (material == null && rendererObject != null) {
                        current.material = Bridge.cast(Bridge.cast(rendererObject, Spine.AtlasRegion).page.rendererObject, UnityEngine.Material);
                    }

                    instructionOutput.hasActiveClipping = skeletonHasClipping;
                    instructionOutput.rawVertexCount = totalRawVertexCount;

                    if (totalRawVertexCount > 0) {
                        workingSubmeshInstructions.Resize(1);
                        workingSubmeshInstructions.Items[0] = current.$clone();
                    } else {
                        workingSubmeshInstructions.Resize(0);
                    }
                },
                /*Spine.Unity.MeshGenerator.GenerateSingleSubmeshInstruction:static end.*/

                /*Spine.Unity.MeshGenerator.RequiresMultipleSubmeshesByDrawOrder:static start.*/
                RequiresMultipleSubmeshesByDrawOrder: function (skeleton) {

                    var drawOrder = skeleton.DrawOrder;
                    var drawOrderCount = drawOrder.Count;
                    var drawOrderItems = drawOrder.Items;

                    var lastRendererMaterial = null;
                    for (var i = 0; i < drawOrderCount; i = (i + 1) | 0) {
                        var slot = drawOrderItems[i];
                        if (!slot.bone.isActive()) {
                            continue;
                        }
                        var attachment = slot.getAttachment();
                        var rendererAttachment = Bridge.as(attachment, Spine.IHasTextureRegion);
                        if (rendererAttachment != null) {
                            if (rendererAttachment.Spine$IHasTextureRegion$Sequence != null) {
                                rendererAttachment.Spine$IHasTextureRegion$Sequence.apply(slot, rendererAttachment);
                            }
                            var atlasRegion = Bridge.cast(rendererAttachment.Spine$IHasTextureRegion$Region, Spine.AtlasRegion);
                            var material = Bridge.cast(atlasRegion.page.rendererObject, UnityEngine.Material);
                            if (!Bridge.referenceEquals(lastRendererMaterial, material)) {
                                if (lastRendererMaterial != null) {
                                    return true;
                                }
                                lastRendererMaterial = material;
                            }
                        }
                    }
                    return false;
                },
                /*Spine.Unity.MeshGenerator.RequiresMultipleSubmeshesByDrawOrder:static end.*/

                /*Spine.Unity.MeshGenerator.GenerateSkeletonRendererInstruction:static start.*/
                GenerateSkeletonRendererInstruction: function (instructionOutput, skeleton, customSlotMaterials, separatorSlots, generateMeshOverride, immutableTriangles) {
                    var $t;
                    if (immutableTriangles === void 0) { immutableTriangles = false; }
                    //			if (skeleton == null) throw new ArgumentNullException("skeleton");
                    //			if (instructionOutput == null) throw new ArgumentNullException("instructionOutput");

                    var drawOrder = skeleton.DrawOrder;
                    var drawOrderCount = drawOrder.Count;

                    // Clear last state of attachments and submeshes
                    instructionOutput.Clear(); // submeshInstructions.Clear(); attachments.Clear();
                    var workingSubmeshInstructions = instructionOutput.submeshInstructions;
                    instructionOutput.attachments.Resize(drawOrderCount);
                    var workingAttachmentsItems = instructionOutput.attachments.Items;
                    var totalRawVertexCount = 0;
                    var skeletonHasClipping = false;

                    var current = ($t = new Spine.Unity.SubmeshInstruction(), $t.skeleton = skeleton, $t.preActiveClippingSlotSource = -1, $t);

                    var isCustomSlotMaterialsPopulated = customSlotMaterials != null && customSlotMaterials.Count > 0;

                    var separatorCount = separatorSlots == null ? 0 : separatorSlots.Count;
                    var hasSeparators = separatorCount > 0;

                    var clippingAttachmentSource = -1;
                    var lastPreActiveClipping = -1; // The index of the last slot that had an active ClippingAttachment.
                    var clippingEndSlot = null;
                    var submeshIndex = 0;
                    var drawOrderItems = drawOrder.Items;
                    for (var i = 0; i < drawOrderCount; i = (i + 1) | 0) {
                        var slot = drawOrderItems[i];
                        if (!slot.bone.isActive()) {
                            workingAttachmentsItems[i] = null;
                            continue;
                        }
                        if (slot.data.blendMode === spine.BlendMode.Additive) {
                            current.hasPMAAdditiveSlot = true;
                        }
                        var attachment = slot.getAttachment();
                        workingAttachmentsItems[i] = attachment;
                        var attachmentVertexCount = 0, attachmentTriangleCount = 0;

                        var region = null;
                        var noRender = false; // Using this allows empty slots as separators, and keeps separated parts more stable despite slots being reordered

                        var regionAttachment = Bridge.as(attachment, Spine.RegionAttachment);
                        if (regionAttachment != null) {
                            if (regionAttachment.sequence != null) {
                                regionAttachment.sequence.apply(slot, regionAttachment);
                            }
                            region = regionAttachment.region;
                            attachmentVertexCount = 4;
                            attachmentTriangleCount = 6;
                        } else {
                            var meshAttachment = Bridge.as(attachment, Spine.MeshAttachment);
                            if (meshAttachment != null) {
                                if (meshAttachment.sequence != null) {
                                    meshAttachment.sequence.apply(slot, meshAttachment);
                                }
                                region = meshAttachment.region;
                                attachmentVertexCount = meshAttachment.worldVerticesLength >> 1;
                                attachmentTriangleCount = meshAttachment.triangles.length;
                            } else {
                                var clippingAttachment = Bridge.as(attachment, spine.ClippingAttachment);
                                if (clippingAttachment != null) {
                                    clippingEndSlot = clippingAttachment.endSlot;
                                    clippingAttachmentSource = i;
                                    current.hasClipping = true;
                                    skeletonHasClipping = true;
                                }
                                noRender = true;
                            }
                        }

                        // Create a new SubmeshInstruction when material changes. (or when forced to separate by a submeshSeparator)
                        // Slot with a separator/new material will become the starting slot of the next new instruction.
                        if (hasSeparators) { //current.forceSeparate = hasSeparators && separatorSlots.Contains(slot);
                            current.forceSeparate = false;
                            for (var s = 0; s < separatorCount; s = (s + 1) | 0) {
                                if (Bridge.referenceEquals(slot, separatorSlots.getItem(s))) {
                                    current.forceSeparate = true;
                                    break;
                                }
                            }
                        }

                        if (noRender) {
                            if (current.forceSeparate && generateMeshOverride) { // && current.rawVertexCount > 0) {
                                { // Add
                                    current.endSlot = i;
                                    current.preActiveClippingSlotSource = lastPreActiveClipping;

                                    workingSubmeshInstructions.Resize(((submeshIndex + 1) | 0));
                                    workingSubmeshInstructions.Items[submeshIndex] = current.$clone();

                                    submeshIndex = (submeshIndex + 1) | 0;
                                }

                                current.startSlot = i;
                                lastPreActiveClipping = clippingAttachmentSource;
                                current.rawTriangleCount = 0;
                                current.rawVertexCount = 0;
                                current.rawFirstVertexIndex = totalRawVertexCount;
                                current.hasClipping = clippingAttachmentSource >= 0;
                            }
                        } else {
                            var material = { };
                            if (isCustomSlotMaterialsPopulated) {
                                if (!customSlotMaterials.tryGetValue(slot, material)) {
                                    material.v = Bridge.cast(Bridge.cast(region, Spine.AtlasRegion).page.rendererObject, UnityEngine.Material);
                                }
                            } else {
                                material.v = Bridge.cast(Bridge.cast(region, Spine.AtlasRegion).page.rendererObject, UnityEngine.Material);
                            }

                            if (current.forceSeparate || (current.rawVertexCount > 0 && !Bridge.referenceEquals(current.material, material.v))) { // Material changed. Add the previous submesh.
                                { // Add
                                    current.endSlot = i;
                                    current.preActiveClippingSlotSource = lastPreActiveClipping;

                                    workingSubmeshInstructions.Resize(((submeshIndex + 1) | 0));
                                    workingSubmeshInstructions.Items[submeshIndex] = current.$clone();
                                    submeshIndex = (submeshIndex + 1) | 0;
                                }
                                current.startSlot = i;
                                lastPreActiveClipping = clippingAttachmentSource;
                                current.rawTriangleCount = 0;
                                current.rawVertexCount = 0;
                                current.rawFirstVertexIndex = totalRawVertexCount;
                                current.hasClipping = clippingAttachmentSource >= 0;
                            }

                            // Update state for the next Attachment.
                            current.material = material.v;
                            current.rawTriangleCount = (current.rawTriangleCount + attachmentTriangleCount) | 0;
                            current.rawVertexCount = (current.rawVertexCount + attachmentVertexCount) | 0;
                            current.rawFirstVertexIndex = totalRawVertexCount;
                            totalRawVertexCount = (totalRawVertexCount + attachmentVertexCount) | 0;
                        }

                        if (clippingEndSlot != null && Bridge.referenceEquals(slot.data, clippingEndSlot) && i !== clippingAttachmentSource) {
                            clippingEndSlot = null;
                            clippingAttachmentSource = -1;
                        }
                    }

                    if (current.rawVertexCount > 0) {
                        { // Add last or only submesh.
                            current.endSlot = drawOrderCount;
                            current.preActiveClippingSlotSource = lastPreActiveClipping;
                            current.forceSeparate = false;

                            workingSubmeshInstructions.Resize(((submeshIndex + 1) | 0));
                            workingSubmeshInstructions.Items[submeshIndex] = current.$clone();
                            //submeshIndex++;
                        }
                    }

                    instructionOutput.hasActiveClipping = skeletonHasClipping;
                    instructionOutput.rawVertexCount = totalRawVertexCount;
                    instructionOutput.immutableTriangles = immutableTriangles;
                },
                /*Spine.Unity.MeshGenerator.GenerateSkeletonRendererInstruction:static end.*/

                /*Spine.Unity.MeshGenerator.TryReplaceMaterials:static start.*/
                TryReplaceMaterials: function (workingSubmeshInstructions, customMaterialOverride) {
                    // Material overrides are done here so they can be applied per submesh instead of per slot
                    // but they will still be passed through the GenerateMeshOverride delegate,
                    // and will still go through the normal material match check step in STEP 3.
                    var wsii = workingSubmeshInstructions.Items;
                    for (var i = 0; i < workingSubmeshInstructions.Count; i = (i + 1) | 0) {
                        var material = wsii[i].material;
                        if (material == null) {
                            continue;
                        }

                        var overrideMaterial = { };
                        if (customMaterialOverride.tryGetValue(material, overrideMaterial)) {
                            wsii[i].material = overrideMaterial.v;
                        }
                    }
                },
                /*Spine.Unity.MeshGenerator.TryReplaceMaterials:static end.*/

                /*Spine.Unity.MeshGenerator.SolveTangents2DEnsureSize:static start.*/
                /**
                 * Step 1 of solving tangents. Ensure you have buffers of the correct size.
                 *
                 * @static
                 * @this Spine.Unity.MeshGenerator
                 * @memberof Spine.Unity.MeshGenerator
                 * @param   {UnityEngine.Vector4}    tangentBuffer         Eventual Vector4[] tangent buffer to assign to Mesh.tangents.
                 * @param   {UnityEngine.Vector2}    tempTanBuffer         Temporary Vector2 buffer for calculating directions.
                 * @param   {number}                 vertexCount           Number of vertices that require tangents (or the size of the vertex array)
                 * @param   {number}                 vertexBufferLength
                 * @return  {void}
                 */
                SolveTangents2DEnsureSize: function (tangentBuffer, tempTanBuffer, vertexCount, vertexBufferLength) {
                    if (tangentBuffer.v == null || tangentBuffer.v.length !== vertexBufferLength) {
                        tangentBuffer.v = System.Array.init(vertexBufferLength, function (){
                            return new UnityEngine.Vector4();
                        }, UnityEngine.Vector4);
                    }

                    if (tempTanBuffer.v == null || tempTanBuffer.v.length < Bridge.Int.mul(vertexCount, 2)) {
                        tempTanBuffer.v = System.Array.init(Bridge.Int.mul(vertexCount, 2), function (){
                            return new UnityEngine.Vector2();
                        }, UnityEngine.Vector2);
                    } // two arrays in one.
                },
                /*Spine.Unity.MeshGenerator.SolveTangents2DEnsureSize:static end.*/

                /*Spine.Unity.MeshGenerator.SolveTangents2DTriangles:static start.*/
                /**
                 * Step 2 of solving tangents. Fills (part of) a temporary tangent-solution buffer based on the vertices and uvs defined by a submesh's triangle buffer. Only needs to be called once for single-submesh meshes.
                 *
                 * @static
                 * @this Spine.Unity.MeshGenerator
                 * @memberof Spine.Unity.MeshGenerator
                 * @param   {Array.<UnityEngine.Vector2>}    tempTanBuffer    A temporary Vector3[] for calculating tangents.
                 * @param   {Array.<number>}                 triangles        The mesh's current triangles buffer.
                 * @param   {number}                         triangleCount    The number of triangle indexes in the triangle array to be used.
                 * @param   {Array.<UnityEngine.Vector3>}    vertices         The mesh's current vertex position buffer.
                 * @param   {Array.<UnityEngine.Vector2>}    uvs              The mesh's current uvs buffer.
                 * @param   {number}                         vertexCount      Number of vertices that require tangents (or the size of the vertex array)
                 * @return  {void}
                 */
                SolveTangents2DTriangles: function (tempTanBuffer, triangles, triangleCount, vertices, uvs, vertexCount) {
                    var $t, $t1;
                    var sdir = new UnityEngine.Vector2();
                    var tdir = new UnityEngine.Vector2();
                    for (var t = 0; t < triangleCount; t = (t + 3) | 0) {
                        var i1 = triangles[((t + 0) | 0)];
                        var i2 = triangles[((t + 1) | 0)];
                        var i3 = triangles[((t + 2) | 0)];

                        var v1 = vertices[i1].$clone();
                        var v2 = vertices[i2].$clone();
                        var v3 = vertices[i3].$clone();

                        var w1 = uvs[i1].$clone();
                        var w2 = uvs[i2].$clone();
                        var w3 = uvs[i3].$clone();

                        var x1 = v2.x - v1.x;
                        var x2 = v3.x - v1.x;
                        var y1 = v2.y - v1.y;
                        var y2 = v3.y - v1.y;

                        var s1 = w2.x - w1.x;
                        var s2 = w3.x - w1.x;
                        var t1 = w2.y - w1.y;
                        var t2 = w3.y - w1.y;

                        var div = s1 * t2 - s2 * t1;
                        var r = (div === 0.0) ? 0.0 : 1.0 / div;

                        sdir.x = (t2 * x1 - t1 * x2) * r;
                        sdir.y = (t2 * y1 - t1 * y2) * r;
                        tempTanBuffer[i1] = ($t = (tempTanBuffer[i3] = sdir.$clone(), sdir.$clone()), tempTanBuffer[i2] = $t.$clone(), $t);

                        tdir.x = (s1 * x2 - s2 * x1) * r;
                        tdir.y = (s1 * y2 - s2 * y1) * r;
                        tempTanBuffer[((vertexCount + i1) | 0)] = ($t1 = (tempTanBuffer[((vertexCount + i3) | 0)] = tdir.$clone(), tdir.$clone()), tempTanBuffer[((vertexCount + i2) | 0)] = $t1.$clone(), $t1);
                    }
                },
                /*Spine.Unity.MeshGenerator.SolveTangents2DTriangles:static end.*/

                /*Spine.Unity.MeshGenerator.SolveTangents2DBuffer:static start.*/
                /**
                 * Step 3 of solving tangents. Fills a Vector4[] tangents array according to values calculated in step 2.
                 *
                 * @static
                 * @this Spine.Unity.MeshGenerator
                 * @memberof Spine.Unity.MeshGenerator
                 * @param   {Array.<UnityEngine.Vector4>}    tangents         A Vector4[] that will eventually be used to set Mesh.tangents
                 * @param   {Array.<UnityEngine.Vector2>}    tempTanBuffer    A temporary Vector3[] for calculating tangents.
                 * @param   {number}                         vertexCount      Number of vertices that require tangents (or the size of the vertex array)
                 * @return  {void}
                 */
                SolveTangents2DBuffer: function (tangents, tempTanBuffer, vertexCount) {
                    var tangent = new UnityEngine.Vector4();
                    tangent.z = 0;
                    for (var i = 0; i < vertexCount; i = (i + 1) | 0) {
                        var t = tempTanBuffer[i].$clone();

                        // t.Normalize() (aggressively inlined). Even better if offloaded to GPU via vertex shader.
                        var magnitude = Math.sqrt(t.x * t.x + t.y * t.y);
                        if (magnitude > 1E-05) {
                            var reciprocalMagnitude = 1.0 / magnitude;
                            t.x *= reciprocalMagnitude;
                            t.y *= reciprocalMagnitude;
                        }

                        var t2 = tempTanBuffer[((vertexCount + i) | 0)].$clone();
                        tangent.x = t.x;
                        tangent.y = t.y;
                        //tangent.z = 0;
                        tangent.w = (t.y * t2.x > t.x * t2.y) ? 1 : -1; // 2D direction calculation. Used for binormals.
                        tangents[i] = tangent.$clone();
                    }
                },
                /*Spine.Unity.MeshGenerator.SolveTangents2DBuffer:static end.*/

                /*Spine.Unity.MeshGenerator.FillMeshLocal$1:static start.*/
                /**
                 * Fills mesh vertex data to render a RegionAttachment.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.MeshGenerator
                 * @memberof Spine.Unity.MeshGenerator
                 * @param   {UnityEngine.Mesh}          mesh                
                 * @param   {Spine.RegionAttachment}    regionAttachment
                 * @return  {void}
                 */
                FillMeshLocal$1: function (mesh, regionAttachment) {
                    if (mesh == null) {
                        return;
                    }
                    if (regionAttachment == null) {
                        return;
                    }

                    Spine.Unity.MeshGenerator.AttachmentVerts.clear();
                    var offsets = regionAttachment.offset;
                    Spine.Unity.MeshGenerator.AttachmentVerts.add(new pc.Vec3( offsets[0], offsets[1], 0 ));
                    Spine.Unity.MeshGenerator.AttachmentVerts.add(new pc.Vec3( offsets[2], offsets[3], 0 ));
                    Spine.Unity.MeshGenerator.AttachmentVerts.add(new pc.Vec3( offsets[4], offsets[5], 0 ));
                    Spine.Unity.MeshGenerator.AttachmentVerts.add(new pc.Vec3( offsets[6], offsets[7], 0 ));

                    Spine.Unity.MeshGenerator.AttachmentUVs.clear();
                    var uvs = regionAttachment.uvs;
                    Spine.Unity.MeshGenerator.AttachmentUVs.add(new pc.Vec2( uvs[2], uvs[3] ));
                    Spine.Unity.MeshGenerator.AttachmentUVs.add(new pc.Vec2( uvs[4], uvs[5] ));
                    Spine.Unity.MeshGenerator.AttachmentUVs.add(new pc.Vec2( uvs[6], uvs[7] ));
                    Spine.Unity.MeshGenerator.AttachmentUVs.add(new pc.Vec2( uvs[0], uvs[1] ));

                    Spine.Unity.MeshGenerator.AttachmentColors32.clear();
                    var c = UnityEngine.Color32.op_Implicit$1((new pc.Color( regionAttachment.color.r, regionAttachment.color.g, regionAttachment.color.b, regionAttachment.color.a )));
                    for (var i = 0; i < 4; i = (i + 1) | 0) {
                        Spine.Unity.MeshGenerator.AttachmentColors32.add(c.$clone());
                    }

                    Spine.Unity.MeshGenerator.AttachmentIndices.clear();
                    Spine.Unity.MeshGenerator.AttachmentIndices.AddRange(System.Array.init([0, 2, 1, 0, 3, 2], System.Int32));

                    mesh.Clear();
                    mesh.name = regionAttachment.name;
                    mesh.SetVertices(Spine.Unity.MeshGenerator.AttachmentVerts);
                    mesh.SetUVs(0, Spine.Unity.MeshGenerator.AttachmentUVs);
                    mesh.SetColors$1(Spine.Unity.MeshGenerator.AttachmentColors32);
                    mesh.SetTriangles(Spine.Unity.MeshGenerator.AttachmentIndices, 0);
                    mesh.RecalculateBounds();

                    Spine.Unity.MeshGenerator.AttachmentVerts.clear();
                    Spine.Unity.MeshGenerator.AttachmentUVs.clear();
                    Spine.Unity.MeshGenerator.AttachmentColors32.clear();
                    Spine.Unity.MeshGenerator.AttachmentIndices.clear();
                },
                /*Spine.Unity.MeshGenerator.FillMeshLocal$1:static end.*/

                /*Spine.Unity.MeshGenerator.FillMeshLocal:static start.*/
                FillMeshLocal: function (mesh, meshAttachment, skeletonData) {
                    var $t;
                    if (mesh == null) {
                        return;
                    }
                    if (meshAttachment == null) {
                        return;
                    }
                    var vertexCount = (Bridge.Int.div(meshAttachment.worldVerticesLength, 2)) | 0;

                    Spine.Unity.MeshGenerator.AttachmentVerts.clear();
                    if (Spine.SpineSkeletonExtensions.IsWeighted(meshAttachment)) {
                        var count = meshAttachment.worldVerticesLength;
                        var meshAttachmentBones = meshAttachment.bones;
                        var v = 0;

                        var vertices = meshAttachment.vertices;
                        for (var w = 0, b = 0; w < count; w = (w + 2) | 0) {
                            var wx = 0, wy = 0;
                            var n = meshAttachmentBones[Bridge.identity(v, ((v = (v + 1) | 0)))];
                            n = (n + v) | 0;
                            for (; v < n; v = (v + 1) | 0, b = (b + 3) | 0) {
                                var bm = Spine.BoneMatrix.CalculateSetupWorld(($t = skeletonData.Bones.Items)[meshAttachmentBones[v]]);
                                var vx = vertices[b], vy = vertices[((b + 1) | 0)], weight = vertices[((b + 2) | 0)];
                                wx += (vx * bm.a + vy * bm.b + bm.x) * weight;
                                wy += (vx * bm.c + vy * bm.d + bm.y) * weight;
                            }
                            Spine.Unity.MeshGenerator.AttachmentVerts.add(new pc.Vec3( wx, wy, 0 ));
                        }
                    } else {
                        var localVerts = meshAttachment.vertices;
                        var pos = Bridge.getDefaultValue(UnityEngine.Vector3);
                        for (var i = 0; i < vertexCount; i = (i + 1) | 0) {
                            var ii = Bridge.Int.mul(i, 2);
                            pos.x = localVerts[ii];
                            pos.y = localVerts[((ii + 1) | 0)];
                            Spine.Unity.MeshGenerator.AttachmentVerts.add(pos.$clone());
                        }
                    }

                    var uvs = meshAttachment.uvs;
                    var uv = Bridge.getDefaultValue(UnityEngine.Vector2);
                    var c = UnityEngine.Color32.op_Implicit$1((new pc.Color( meshAttachment.color.r, meshAttachment.color.g, meshAttachment.color.b, meshAttachment.color.a )));
                    Spine.Unity.MeshGenerator.AttachmentUVs.clear();
                    Spine.Unity.MeshGenerator.AttachmentColors32.clear();
                    for (var i1 = 0; i1 < vertexCount; i1 = (i1 + 1) | 0) {
                        var ii1 = Bridge.Int.mul(i1, 2);
                        uv.x = uvs[ii1];
                        uv.y = uvs[((ii1 + 1) | 0)];
                        Spine.Unity.MeshGenerator.AttachmentUVs.add(uv.$clone());

                        Spine.Unity.MeshGenerator.AttachmentColors32.add(c.$clone());
                    }

                    Spine.Unity.MeshGenerator.AttachmentIndices.clear();
                    Spine.Unity.MeshGenerator.AttachmentIndices.AddRange(meshAttachment.triangles);

                    mesh.Clear();
                    mesh.name = meshAttachment.name;
                    mesh.SetVertices(Spine.Unity.MeshGenerator.AttachmentVerts);
                    mesh.SetUVs(0, Spine.Unity.MeshGenerator.AttachmentUVs);
                    mesh.SetColors$1(Spine.Unity.MeshGenerator.AttachmentColors32);
                    mesh.SetTriangles(Spine.Unity.MeshGenerator.AttachmentIndices, 0);
                    mesh.RecalculateBounds();

                    Spine.Unity.MeshGenerator.AttachmentVerts.clear();
                    Spine.Unity.MeshGenerator.AttachmentUVs.clear();
                    Spine.Unity.MeshGenerator.AttachmentColors32.clear();
                    Spine.Unity.MeshGenerator.AttachmentIndices.clear();
                },
                /*Spine.Unity.MeshGenerator.FillMeshLocal:static end.*/


            }
        },
        fields: {
            settings: null,
            vertexBuffer: null,
            uvBuffer: null,
            colorBuffer: null,
            submeshes: null,
            meshBoundsMin: null,
            meshBoundsMax: null,
            meshBoundsThickness: 0,
            submeshIndex: 0,
            clipper: null,
            tempVerts: null,
            regionTriangles: null,
            normals: null,
            tangents: null,
            tempTanBuffer: null,
            uv2: null,
            uv3: null
        },
        props: {
            VertexCount: {
                get: function () {
                    return this.vertexBuffer.Count;
                }
            },
            /**
             * A set of mesh arrays whose values are modifiable by the user. Modify these values before they are passed to the UnityEngine mesh object in order to see the effect.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Unity.MeshGenerator
             * @function Buffers
             * @type Spine.Unity.MeshGeneratorBuffers
             */
            Buffers: {
                get: function () {
                    var $t;
                    return ($t = new Spine.Unity.MeshGeneratorBuffers(), $t.vertexCount = this.VertexCount, $t.vertexBuffer = this.vertexBuffer.Items, $t.uvBuffer = this.uvBuffer.Items, $t.colorBuffer = this.colorBuffer.Items, $t.meshGenerator = this, $t);
                }
            }
        },
        ctors: {
            init: function () {
                this.settings = new Spine.Unity.MeshGenerator.Settings();
                this.meshBoundsMin = new UnityEngine.Vector2();
                this.meshBoundsMax = new UnityEngine.Vector2();
                this.settings = Spine.Unity.MeshGenerator.Settings.Default.$clone();
                this.vertexBuffer = new (Spine.ExposedList$1(UnityEngine.Vector3)).$ctor3(4);
                this.uvBuffer = new (Spine.ExposedList$1(UnityEngine.Vector2)).$ctor3(4);
                this.colorBuffer = new (Spine.ExposedList$1(UnityEngine.Color32)).$ctor3(4);
                this.submeshes = function (_o1) {
                        _o1.Add(new (Spine.ExposedList$1(System.Int32)).$ctor3(6));
                        return _o1;
                    }(new (Spine.ExposedList$1(Spine.ExposedList$1(System.Int32))).ctor());
                this.submeshIndex = 0;
                this.clipper = new Spine.SkeletonClipping();
                this.tempVerts = System.Array.init(8, 0, System.Single);
                this.regionTriangles = System.Array.init([
                    0, 
                    1, 
                    2, 
                    2, 
                    3, 
                    0
                ], System.Int32);
            },
            ctor: function () {
                this.$initialize();
                this.submeshes.TrimExcess();
            }
        },
        methods: {
            /*Spine.Unity.MeshGenerator.SubmeshIndexCount start.*/
            SubmeshIndexCount: function (submeshIndex) {
                var $t;
                return ($t = this.submeshes.Items)[submeshIndex].Count;
            },
            /*Spine.Unity.MeshGenerator.SubmeshIndexCount end.*/

            /*Spine.Unity.MeshGenerator.Begin start.*/
            Begin: function () {
                this.vertexBuffer.Clear(false);
                this.colorBuffer.Clear(false);
                this.uvBuffer.Clear(false);
                this.clipper.clipEnd();

                {
                    this.meshBoundsMin.x = Spine.Unity.MeshGenerator.BoundsMinDefault;
                    this.meshBoundsMin.y = Spine.Unity.MeshGenerator.BoundsMinDefault;
                    this.meshBoundsMax.x = Spine.Unity.MeshGenerator.BoundsMaxDefault;
                    this.meshBoundsMax.y = Spine.Unity.MeshGenerator.BoundsMaxDefault;
                    this.meshBoundsThickness = 0.0;
                }

                this.submeshIndex = 0;
                this.submeshes.Count = 1;
                //submeshes.Items[0].Clear(false);
            },
            /*Spine.Unity.MeshGenerator.Begin end.*/

            /*Spine.Unity.MeshGenerator.AddSubmesh start.*/
            AddSubmesh: function (instruction, updateTriangles) {
                var $t, $t1, $t2;
                if (updateTriangles === void 0) { updateTriangles = true; }
                var settings = this.settings.$clone();

                var newSubmeshCount = (this.submeshIndex + 1) | 0;
                if (this.submeshes.Items.length < newSubmeshCount) {
                    this.submeshes.Resize(newSubmeshCount);
                }
                this.submeshes.Count = newSubmeshCount;
                var submesh = ($t = this.submeshes.Items)[this.submeshIndex];
                if (submesh == null) {
                    ($t1 = this.submeshes.Items)[this.submeshIndex] = (submesh = new (Spine.ExposedList$1(System.Int32)).ctor());
                }
                submesh.Clear(false);

                var skeleton = instruction.skeleton;
                var drawOrderItems = skeleton.DrawOrder.Items;

                var color = Bridge.getDefaultValue(UnityEngine.Color32);
                var skeletonA = skeleton.color.a, skeletonR = skeleton.color.r, skeletonG = skeleton.color.g, skeletonB = skeleton.color.b;
                var meshBoundsMin = this.meshBoundsMin.$clone(), meshBoundsMax = this.meshBoundsMax.$clone();

                // Settings
                var zSpacing = settings.zSpacing;
                var pmaVertexColors = settings.pmaVertexColors;
                var tintBlack = settings.tintBlack;
                var useClipping = settings.useClipping && instruction.hasClipping;
                var canvasGroupTintBlack = settings.tintBlack && settings.canvasGroupTintBlack;

                if (useClipping) {
                    if (instruction.preActiveClippingSlotSource >= 0) {
                        var slot = drawOrderItems[instruction.preActiveClippingSlotSource];
                        this.clipper.clipStart(slot, Bridge.as(slot.getAttachment(), spine.ClippingAttachment));
                    }
                }

                for (var slotIndex = instruction.startSlot; slotIndex < instruction.endSlot; slotIndex = (slotIndex + 1) | 0) {
                    var slot1 = drawOrderItems[slotIndex];
                    if (!slot1.bone.isActive()) {
                        this.clipper.clipEndWithSlot( slot1 );
                        continue;
                    }
                    var attachment = slot1.getAttachment();
                    var z = zSpacing * slotIndex;

                    var workingVerts = this.tempVerts;
                    var uvs;
                    var attachmentTriangleIndices;
                    var attachmentVertexCount;
                    var attachmentIndexCount;

                    var c = Bridge.getDefaultValue(UnityEngine.Color);

                    // Identify and prepare values.
                    var region = Bridge.as(attachment, Spine.RegionAttachment);
                    if (region != null) {
                        region.computeWorldVertices(slot1, workingVerts, 0);
                        uvs = region.uvs;
                        attachmentTriangleIndices = this.regionTriangles;
                        c.r = region.color.r;
                        c.g = region.color.g;
                        c.b = region.color.b;
                        c.a = region.color.a;
                        attachmentVertexCount = 4;
                        attachmentIndexCount = 6;
                    } else {
                        var mesh = Bridge.as(attachment, Spine.MeshAttachment);
                        if (mesh != null) {
                            var meshVerticesLength = mesh.worldVerticesLength;
                            if (workingVerts.length < meshVerticesLength) {
                                workingVerts = System.Array.init(meshVerticesLength, 0, System.Single);
                                this.tempVerts = workingVerts;
                            }
                            mesh.computeWorldVertices( slot1, 0, meshVerticesLength, workingVerts, 0, 2 || 2 ); //meshAttachment.ComputeWorldVertices(slot, tempVerts);
                            uvs = mesh.uvs;
                            attachmentTriangleIndices = mesh.triangles;
                            c.r = mesh.color.r;
                            c.g = mesh.color.g;
                            c.b = mesh.color.b;
                            c.a = mesh.color.a;
                            attachmentVertexCount = meshVerticesLength >> 1; // meshVertexCount / 2;
                            attachmentIndexCount = mesh.triangles.length;
                        } else {
                            if (useClipping) {
                                var clippingAttachment = Bridge.as(attachment, spine.ClippingAttachment);
                                if (clippingAttachment != null) {
                                    this.clipper.clipStart(slot1, clippingAttachment);
                                    continue;
                                }
                            }

                            // If not any renderable attachment.
                            this.clipper.clipEndWithSlot( slot1 );
                            continue;
                        }
                    }

                    var tintBlackAlpha = 1.0;
                    if (pmaVertexColors) {
                        var colorA = skeletonA * slot1.color.a * c.a;
                        color.a = Bridge.Int.clipu8(colorA * 255);
                        color.r = Bridge.Int.clipu8(skeletonR * slot1.color.r * c.r * color.a);
                        color.g = Bridge.Int.clipu8(skeletonG * slot1.color.g * c.g * color.a);
                        color.b = Bridge.Int.clipu8(skeletonB * slot1.color.b * c.b * color.a);
                        if (slot1.data.blendMode === spine.BlendMode.Additive) {
                            if (canvasGroupTintBlack) {
                                tintBlackAlpha = 0;
                            } else {
                                color.a = 0;
                            }
                        } else if (canvasGroupTintBlack) { // other blend modes
                            tintBlackAlpha = colorA;
                        }
                    } else {
                        color.a = Bridge.Int.clipu8(skeletonA * slot1.color.a * c.a * 255);
                        color.r = Bridge.Int.clipu8(skeletonR * slot1.color.r * c.r * 255);
                        color.g = Bridge.Int.clipu8(skeletonG * slot1.color.g * c.g * 255);
                        color.b = Bridge.Int.clipu8(skeletonB * slot1.color.b * c.b * 255);
                    }

                    if (useClipping && this.clipper.isClipping()) {
                        this.clipper.ClipTriangles(workingVerts, attachmentVertexCount << 1, attachmentTriangleIndices, attachmentIndexCount, uvs);
                        workingVerts = this.clipper.ClippedVertices.Items;
                        attachmentVertexCount = this.clipper.ClippedVertices.Count >> 1;
                        attachmentTriangleIndices = this.clipper.ClippedTriangles.Items;
                        attachmentIndexCount = this.clipper.ClippedTriangles.Count;
                        uvs = this.clipper.ClippedUVs.Items;
                    }

                    // Actually add slot/attachment data into buffers.
                    if (attachmentVertexCount !== 0 && attachmentIndexCount !== 0) {
                        if (tintBlack) {
                            var r2 = slot1.darkColor.r || 0;
                            var g2 = slot1.darkColor.g || 0;
                            var b2 = slot1.darkColor.b || 0;
                            if (pmaVertexColors) {
                                var alpha = skeletonA * slot1.color.a * c.a;
                                r2 *= alpha;
                                g2 *= alpha;
                                b2 *= alpha;
                            }
                            this.AddAttachmentTintBlack(r2, g2, b2, tintBlackAlpha, attachmentVertexCount);
                        }

                        //AddAttachment(workingVerts, uvs, color, attachmentTriangleIndices, attachmentVertexCount, attachmentIndexCount, ref meshBoundsMin, ref meshBoundsMax, z);
                        var ovc = this.vertexBuffer.Count;
                        // Add data to vertex buffers
                        {
                            var newVertexCount = (ovc + attachmentVertexCount) | 0;
                            var oldArraySize = this.vertexBuffer.Items.length;
                            if (newVertexCount > oldArraySize) {
                                var newArraySize = Bridge.Int.clip32(oldArraySize * 1.3);
                                if (newArraySize < newVertexCount) {
                                    newArraySize = newVertexCount;
                                }
                                System.Array.resize(Bridge.ref(this.vertexBuffer, "Items"), newArraySize, function () {
                                    return Bridge.getDefaultValue(UnityEngine.Vector3);
                                }, UnityEngine.Vector3);
                                System.Array.resize(Bridge.ref(this.uvBuffer, "Items"), newArraySize, function () {
                                    return Bridge.getDefaultValue(UnityEngine.Vector2);
                                }, UnityEngine.Vector2);
                                System.Array.resize(Bridge.ref(this.colorBuffer, "Items"), newArraySize, function () {
                                    return Bridge.getDefaultValue(UnityEngine.Color32);
                                }, UnityEngine.Color32);
                            }
                            this.vertexBuffer.Count = ($t2 = (this.colorBuffer.Count = newVertexCount, newVertexCount), this.uvBuffer.Count = $t2, $t2);
                        }

                        var vbi = this.vertexBuffer.Items;
                        var ubi = this.uvBuffer.Items;
                        var cbi = this.colorBuffer.Items;
                        if (ovc === 0) {
                            for (var i = 0; i < attachmentVertexCount; i = (i + 1) | 0) {
                                var vi = (ovc + i) | 0;
                                var i2 = i << 1; // i * 2
                                var x = workingVerts[i2];
                                var y = workingVerts[((i2 + 1) | 0)];

                                vbi[vi].x = x;
                                vbi[vi].y = y;
                                vbi[vi].z = z;
                                ubi[vi].x = uvs[i2];
                                ubi[vi].y = uvs[((i2 + 1) | 0)];
                                cbi[vi] = color.$clone();

                                // Calculate bounds.
                                if (x < meshBoundsMin.x) {
                                    meshBoundsMin.x = x;
                                }
                                if (x > meshBoundsMax.x) {
                                    meshBoundsMax.x = x;
                                }
                                if (y < meshBoundsMin.y) {
                                    meshBoundsMin.y = y;
                                }
                                if (y > meshBoundsMax.y) {
                                    meshBoundsMax.y = y;
                                }
                            }
                        } else {
                            for (var i1 = 0; i1 < attachmentVertexCount; i1 = (i1 + 1) | 0) {
                                var vi1 = (ovc + i1) | 0;
                                var i21 = i1 << 1; // i * 2
                                var x1 = workingVerts[i21];
                                var y1 = workingVerts[((i21 + 1) | 0)];

                                vbi[vi1].x = x1;
                                vbi[vi1].y = y1;
                                vbi[vi1].z = z;
                                ubi[vi1].x = uvs[i21];
                                ubi[vi1].y = uvs[((i21 + 1) | 0)];
                                cbi[vi1] = color.$clone();

                                // Calculate bounds.
                                if (x1 < meshBoundsMin.x) {
                                    meshBoundsMin.x = x1;
                                } else {
                                    if (x1 > meshBoundsMax.x) {
                                        meshBoundsMax.x = x1;
                                    }
                                }
                                if (y1 < meshBoundsMin.y) {
                                    meshBoundsMin.y = y1;
                                } else {
                                    if (y1 > meshBoundsMax.y) {
                                        meshBoundsMax.y = y1;
                                    }
                                }
                            }
                        }


                        // Add data to triangle buffer
                        if (updateTriangles) {
                            var oldTriangleCount = submesh.Count;
                            { //submesh.Resize(oldTriangleCount + attachmentIndexCount);
                                var newTriangleCount = (oldTriangleCount + attachmentIndexCount) | 0;
                                if (newTriangleCount > submesh.Items.length) {
                                    System.Array.resize(Bridge.ref(submesh, "Items"), newTriangleCount, 0, System.Int32);
                                }
                                submesh.Count = newTriangleCount;
                            }
                            var submeshItems = submesh.Items;
                            for (var i2 = 0; i2 < attachmentIndexCount; i2 = (i2 + 1) | 0) {
                                submeshItems[((oldTriangleCount + i2) | 0)] = (attachmentTriangleIndices[i2] + ovc) | 0;
                            }
                        }
                    }

                    this.clipper.clipEndWithSlot( slot1 );
                }
                this.clipper.clipEnd();

                this.meshBoundsMin = meshBoundsMin.$clone();
                this.meshBoundsMax = meshBoundsMax.$clone();
                this.meshBoundsThickness = instruction.endSlot * zSpacing;

                // Trim or zero submesh triangles.
                var currentSubmeshItems = submesh.Items;
                for (var i3 = submesh.Count, n = currentSubmeshItems.length; i3 < n; i3 = (i3 + 1) | 0) {
                    currentSubmeshItems[i3] = 0;
                }

                this.submeshIndex = (this.submeshIndex + 1) | 0; // Next AddSubmesh will use a new submeshIndex value.
            },
            /*Spine.Unity.MeshGenerator.AddSubmesh end.*/

            /*Spine.Unity.MeshGenerator.BuildMesh start.*/
            BuildMesh: function (instruction, updateTriangles) {
                var wsii = instruction.submeshInstructions.Items;
                for (var i = 0, n = instruction.submeshInstructions.Count; i < n; i = (i + 1) | 0) {
                    this.AddSubmesh(wsii[i].$clone(), updateTriangles);
                }
            },
            /*Spine.Unity.MeshGenerator.BuildMesh end.*/

            /*Spine.Unity.MeshGenerator.BuildMeshWithArrays start.*/
            BuildMeshWithArrays: function (instruction, updateTriangles) {
                var $t, $t1, $t2, $t3, $t4;
                var settings = this.settings.$clone();
                var canvasGroupTintBlack = settings.tintBlack && settings.canvasGroupTintBlack;
                var totalVertexCount = instruction.rawVertexCount;

                // Add data to vertex buffers
                {
                    if (totalVertexCount > this.vertexBuffer.Items.length) { // Manual ExposedList.Resize()
                        System.Array.resize(Bridge.ref(this.vertexBuffer, "Items"), totalVertexCount, function () {
                            return Bridge.getDefaultValue(UnityEngine.Vector3);
                        }, UnityEngine.Vector3);
                        System.Array.resize(Bridge.ref(this.uvBuffer, "Items"), totalVertexCount, function () {
                            return Bridge.getDefaultValue(UnityEngine.Vector2);
                        }, UnityEngine.Vector2);
                        System.Array.resize(Bridge.ref(this.colorBuffer, "Items"), totalVertexCount, function () {
                            return Bridge.getDefaultValue(UnityEngine.Color32);
                        }, UnityEngine.Color32);
                    }
                    this.vertexBuffer.Count = ($t = (this.colorBuffer.Count = totalVertexCount, totalVertexCount), this.uvBuffer.Count = $t, $t);
                }

                // Populate Verts
                var color = Bridge.getDefaultValue(UnityEngine.Color32);

                var vertexIndex = 0;
                var tempVerts = this.tempVerts;
                var bmin = this.meshBoundsMin.$clone();
                var bmax = this.meshBoundsMax.$clone();

                var vbi = this.vertexBuffer.Items;
                var ubi = this.uvBuffer.Items;
                var cbi = this.colorBuffer.Items;
                var lastSlotIndex = 0;

                // drawOrder[endSlot] is excluded
                for (var si = 0, n = instruction.submeshInstructions.Count; si < n; si = (si + 1) | 0) {
                    var submesh = ($t1 = instruction.submeshInstructions.Items)[si].$clone();
                    var skeleton = submesh.skeleton;
                    var drawOrderItems = skeleton.DrawOrder.Items;
                    var a = skeleton.color.a, r = skeleton.color.r, g = skeleton.color.g, b = skeleton.color.b;

                    var endSlot = submesh.endSlot;
                    var startSlot = submesh.startSlot;
                    lastSlotIndex = endSlot;

                    if (settings.tintBlack) {
                        var rg = new UnityEngine.Vector2(), b2 = new UnityEngine.Vector2();
                        var vi = vertexIndex;
                        b2.y = 1.0;

                        {
                            if (this.uv2 == null) {
                                this.uv2 = new (Spine.ExposedList$1(UnityEngine.Vector2)).ctor();
                                this.uv3 = new (Spine.ExposedList$1(UnityEngine.Vector2)).ctor();
                            }
                            if (totalVertexCount > this.uv2.Items.length) { // Manual ExposedList.Resize()
                                System.Array.resize(Bridge.ref(this.uv2, "Items"), totalVertexCount, function () {
                                    return Bridge.getDefaultValue(UnityEngine.Vector2);
                                }, UnityEngine.Vector2);
                                System.Array.resize(Bridge.ref(this.uv3, "Items"), totalVertexCount, function () {
                                    return Bridge.getDefaultValue(UnityEngine.Vector2);
                                }, UnityEngine.Vector2);
                            }
                            this.uv2.Count = (this.uv3.Count = totalVertexCount, totalVertexCount);
                        }

                        var uv2i = this.uv2.Items;
                        var uv3i = this.uv3.Items;

                        for (var slotIndex = startSlot; slotIndex < endSlot; slotIndex = (slotIndex + 1) | 0) {
                            var slot = drawOrderItems[slotIndex];
                            if (!slot.bone.isActive()) {
                                continue;
                            }
                            var attachment = slot.getAttachment();

                            rg.x = slot.darkColor.r || 0; //r
                            rg.y = slot.darkColor.g || 0; //g
                            b2.x = slot.darkColor.b || 0; //b
                            b2.y = 1.0;

                            var regionAttachment = Bridge.as(attachment, Spine.RegionAttachment);
                            if (regionAttachment != null) {
                                if (settings.pmaVertexColors) {
                                    var alpha = a * slot.color.a * regionAttachment.color.a;
                                    rg.x *= alpha;
                                    rg.y *= alpha;
                                    b2.x *= alpha;
                                    b2.y = slot.data.blendMode === spine.BlendMode.Additive ? 0 : alpha;
                                }
                                uv2i[vi] = rg.$clone();
                                uv2i[((vi + 1) | 0)] = rg.$clone();
                                uv2i[((vi + 2) | 0)] = rg.$clone();
                                uv2i[((vi + 3) | 0)] = rg.$clone();
                                uv3i[vi] = b2.$clone();
                                uv3i[((vi + 1) | 0)] = b2.$clone();
                                uv3i[((vi + 2) | 0)] = b2.$clone();
                                uv3i[((vi + 3) | 0)] = b2.$clone();
                                vi = (vi + 4) | 0;
                            } else { //} if (settings.renderMeshes) {
                                var meshAttachment = Bridge.as(attachment, Spine.MeshAttachment);
                                if (meshAttachment != null) {
                                    if (settings.pmaVertexColors) {
                                        var alpha1 = a * slot.color.a * meshAttachment.color.a;
                                        rg.x *= alpha1;
                                        rg.y *= alpha1;
                                        b2.x *= alpha1;
                                        b2.y = slot.data.blendMode === spine.BlendMode.Additive ? 0 : alpha1;
                                    }
                                    var verticesArrayLength = meshAttachment.worldVerticesLength;
                                    for (var iii = 0; iii < verticesArrayLength; iii = (iii + 2) | 0) {
                                        uv2i[vi] = rg.$clone();
                                        uv3i[vi] = b2.$clone();
                                        vi = (vi + 1) | 0;
                                    }
                                }
                            }
                        }
                    }

                    for (var slotIndex1 = startSlot; slotIndex1 < endSlot; slotIndex1 = (slotIndex1 + 1) | 0) {
                        var slot1 = drawOrderItems[slotIndex1];
                        if (!slot1.bone.isActive()) {
                            continue;
                        }
                        var attachment1 = slot1.getAttachment();
                        var z = slotIndex1 * settings.zSpacing;

                        var regionAttachment1 = Bridge.as(attachment1, Spine.RegionAttachment);
                        if (regionAttachment1 != null) {
                            regionAttachment1.computeWorldVertices(slot1, tempVerts, 0);

                            var x1 = tempVerts[0], y1 = tempVerts[1];
                            var x2 = tempVerts[2], y2 = tempVerts[3];
                            var x3 = tempVerts[4], y3 = tempVerts[5];
                            var x4 = tempVerts[6], y4 = tempVerts[7];
                            vbi[vertexIndex].x = x1;
                            vbi[vertexIndex].y = y1;
                            vbi[vertexIndex].z = z;
                            vbi[((vertexIndex + 1) | 0)].x = x4;
                            vbi[((vertexIndex + 1) | 0)].y = y4;
                            vbi[((vertexIndex + 1) | 0)].z = z;
                            vbi[((vertexIndex + 2) | 0)].x = x2;
                            vbi[((vertexIndex + 2) | 0)].y = y2;
                            vbi[((vertexIndex + 2) | 0)].z = z;
                            vbi[((vertexIndex + 3) | 0)].x = x3;
                            vbi[((vertexIndex + 3) | 0)].y = y3;
                            vbi[((vertexIndex + 3) | 0)].z = z;

                            if (settings.pmaVertexColors) {
                                color.a = Bridge.Int.clipu8(a * slot1.color.a * regionAttachment1.color.a * 255);
                                color.r = Bridge.Int.clipu8(r * slot1.color.r * regionAttachment1.color.r * color.a);
                                color.g = Bridge.Int.clipu8(g * slot1.color.g * regionAttachment1.color.g * color.a);
                                color.b = Bridge.Int.clipu8(b * slot1.color.b * regionAttachment1.color.b * color.a);
                                if (slot1.data.blendMode === spine.BlendMode.Additive && !canvasGroupTintBlack) {
                                    color.a = 0;
                                }
                            } else {
                                color.a = Bridge.Int.clipu8(a * slot1.color.a * regionAttachment1.color.a * 255);
                                color.r = Bridge.Int.clipu8(r * slot1.color.r * regionAttachment1.color.r * 255);
                                color.g = Bridge.Int.clipu8(g * slot1.color.g * regionAttachment1.color.g * 255);
                                color.b = Bridge.Int.clipu8(b * slot1.color.b * regionAttachment1.color.b * 255);
                            }

                            cbi[vertexIndex] = color.$clone();
                            cbi[((vertexIndex + 1) | 0)] = color.$clone();
                            cbi[((vertexIndex + 2) | 0)] = color.$clone();
                            cbi[((vertexIndex + 3) | 0)] = color.$clone();

                            var regionUVs = regionAttachment1.uvs;
                            ubi[vertexIndex].x = regionUVs[0];
                            ubi[vertexIndex].y = regionUVs[1];
                            ubi[((vertexIndex + 1) | 0)].x = regionUVs[6];
                            ubi[((vertexIndex + 1) | 0)].y = regionUVs[7];
                            ubi[((vertexIndex + 2) | 0)].x = regionUVs[2];
                            ubi[((vertexIndex + 2) | 0)].y = regionUVs[3];
                            ubi[((vertexIndex + 3) | 0)].x = regionUVs[4];
                            ubi[((vertexIndex + 3) | 0)].y = regionUVs[5];

                            if (x1 < bmin.x) {
                                bmin.x = x1;
                            } // Potential first attachment bounds initialization. Initial min should not block initial max. Same for Y below.
                            if (x1 > bmax.x) {
                                bmax.x = x1;
                            }
                            if (x2 < bmin.x) {
                                bmin.x = x2;
                            } else {
                                if (x2 > bmax.x) {
                                    bmax.x = x2;
                                }
                            }
                            if (x3 < bmin.x) {
                                bmin.x = x3;
                            } else {
                                if (x3 > bmax.x) {
                                    bmax.x = x3;
                                }
                            }
                            if (x4 < bmin.x) {
                                bmin.x = x4;
                            } else {
                                if (x4 > bmax.x) {
                                    bmax.x = x4;
                                }
                            }

                            if (y1 < bmin.y) {
                                bmin.y = y1;
                            }
                            if (y1 > bmax.y) {
                                bmax.y = y1;
                            }
                            if (y2 < bmin.y) {
                                bmin.y = y2;
                            } else {
                                if (y2 > bmax.y) {
                                    bmax.y = y2;
                                }
                            }
                            if (y3 < bmin.y) {
                                bmin.y = y3;
                            } else {
                                if (y3 > bmax.y) {
                                    bmax.y = y3;
                                }
                            }
                            if (y4 < bmin.y) {
                                bmin.y = y4;
                            } else {
                                if (y4 > bmax.y) {
                                    bmax.y = y4;
                                }
                            }

                            vertexIndex = (vertexIndex + 4) | 0;
                        } else { //if (settings.renderMeshes) {
                            var meshAttachment1 = Bridge.as(attachment1, Spine.MeshAttachment);
                            if (meshAttachment1 != null) {
                                var verticesArrayLength1 = meshAttachment1.worldVerticesLength;
                                if (tempVerts.length < verticesArrayLength1) {
                                    this.tempVerts = (tempVerts = System.Array.init(verticesArrayLength1, 0, System.Single));
                                }
                                meshAttachment1.computeWorldVertices( slot1, 0, meshAttachment1.worldVerticesLength, tempVerts, 0, 2 );

                                if (settings.pmaVertexColors) {
                                    color.a = Bridge.Int.clipu8(a * slot1.color.a * meshAttachment1.color.a * 255);
                                    color.r = Bridge.Int.clipu8(r * slot1.color.r * meshAttachment1.color.r * color.a);
                                    color.g = Bridge.Int.clipu8(g * slot1.color.g * meshAttachment1.color.g * color.a);
                                    color.b = Bridge.Int.clipu8(b * slot1.color.b * meshAttachment1.color.b * color.a);
                                    if (slot1.data.blendMode === spine.BlendMode.Additive && !canvasGroupTintBlack) {
                                        color.a = 0;
                                    }
                                } else {
                                    color.a = Bridge.Int.clipu8(a * slot1.color.a * meshAttachment1.color.a * 255);
                                    color.r = Bridge.Int.clipu8(r * slot1.color.r * meshAttachment1.color.r * 255);
                                    color.g = Bridge.Int.clipu8(g * slot1.color.g * meshAttachment1.color.g * 255);
                                    color.b = Bridge.Int.clipu8(b * slot1.color.b * meshAttachment1.color.b * 255);
                                }

                                var attachmentUVs = meshAttachment1.uvs;

                                // Potential first attachment bounds initialization. See conditions in RegionAttachment logic.
                                if (vertexIndex === 0) {
                                    // Initial min should not block initial max.
                                    // vi == vertexIndex does not always mean the bounds are fresh. It could be a submesh. Do not nuke old values by omitting the check.
                                    // Should know that this is the first attachment in the submesh. slotIndex == startSlot could be an empty slot.
                                    var fx = tempVerts[0], fy = tempVerts[1];
                                    if (fx < bmin.x) {
                                        bmin.x = fx;
                                    }
                                    if (fx > bmax.x) {
                                        bmax.x = fx;
                                    }
                                    if (fy < bmin.y) {
                                        bmin.y = fy;
                                    }
                                    if (fy > bmax.y) {
                                        bmax.y = fy;
                                    }
                                }

                                for (var iii1 = 0; iii1 < verticesArrayLength1; iii1 = (iii1 + 2) | 0) {
                                    var x = tempVerts[iii1], y = tempVerts[((iii1 + 1) | 0)];
                                    vbi[vertexIndex].x = x;
                                    vbi[vertexIndex].y = y;
                                    vbi[vertexIndex].z = z;
                                    cbi[vertexIndex] = color.$clone();
                                    ubi[vertexIndex].x = attachmentUVs[iii1];
                                    ubi[vertexIndex].y = attachmentUVs[((iii1 + 1) | 0)];

                                    if (x < bmin.x) {
                                        bmin.x = x;
                                    } else {
                                        if (x > bmax.x) {
                                            bmax.x = x;
                                        }
                                    }

                                    if (y < bmin.y) {
                                        bmin.y = y;
                                    } else {
                                        if (y > bmax.y) {
                                            bmax.y = y;
                                        }
                                    }

                                    vertexIndex = (vertexIndex + 1) | 0;
                                }
                            }
                        }
                    }
                }

                this.meshBoundsMin = bmin.$clone();
                this.meshBoundsMax = bmax.$clone();
                this.meshBoundsThickness = lastSlotIndex * settings.zSpacing;

                var submeshInstructionCount = instruction.submeshInstructions.Count;
                this.submeshes.Count = submeshInstructionCount;

                // Add triangles
                if (updateTriangles) {
                    // Match submesh buffers count with submeshInstruction count.
                    if (this.submeshes.Items.length < submeshInstructionCount) {
                        this.submeshes.Resize(submeshInstructionCount);
                        for (var i = 0, n1 = submeshInstructionCount; i < n1; i = (i + 1) | 0) {
                            var submeshBuffer = ($t2 = this.submeshes.Items)[i];
                            if (submeshBuffer == null) {
                                ($t3 = this.submeshes.Items)[i] = new (Spine.ExposedList$1(System.Int32)).ctor();
                            } else {
                                submeshBuffer.Clear(false);
                            }
                        }
                    }

                    var submeshInstructionsItems = instruction.submeshInstructions.Items; // This relies on the resize above.

                    // Fill the buffers.
                    var attachmentFirstVertex = 0;
                    for (var smbi = 0; smbi < submeshInstructionCount; smbi = (smbi + 1) | 0) {
                        var submeshInstruction = submeshInstructionsItems[smbi].$clone();
                        var currentSubmeshBuffer = ($t4 = this.submeshes.Items)[smbi];
                        { //submesh.Resize(submesh.rawTriangleCount);
                            var newTriangleCount = submeshInstruction.rawTriangleCount;
                            if (newTriangleCount > currentSubmeshBuffer.Items.length) {
                                System.Array.resize(Bridge.ref(currentSubmeshBuffer, "Items"), newTriangleCount, 0, System.Int32);
                            } else {
                                if (newTriangleCount < currentSubmeshBuffer.Items.length) {
                                    // Zero the extra.
                                    var sbi = currentSubmeshBuffer.Items;
                                    for (var ei = newTriangleCount, nn = sbi.length; ei < nn; ei = (ei + 1) | 0) {
                                        sbi[ei] = 0;
                                    }
                                }
                            }
                            currentSubmeshBuffer.Count = newTriangleCount;
                        }

                        var tris = currentSubmeshBuffer.Items;
                        var triangleIndex = 0;
                        var skeleton1 = submeshInstruction.skeleton;
                        var drawOrderItems1 = skeleton1.DrawOrder.Items;
                        for (var slotIndex2 = submeshInstruction.startSlot, endSlot1 = submeshInstruction.endSlot; slotIndex2 < endSlot1; slotIndex2 = (slotIndex2 + 1) | 0) {
                            var slot2 = drawOrderItems1[slotIndex2];
                            if (!slot2.bone.isActive()) {
                                continue;
                            }

                            var attachment2 = drawOrderItems1[slotIndex2].getAttachment();
                            if (Bridge.is(attachment2, Spine.RegionAttachment)) {
                                tris[triangleIndex] = attachmentFirstVertex;
                                tris[((triangleIndex + 1) | 0)] = (attachmentFirstVertex + 2) | 0;
                                tris[((triangleIndex + 2) | 0)] = (attachmentFirstVertex + 1) | 0;
                                tris[((triangleIndex + 3) | 0)] = (attachmentFirstVertex + 2) | 0;
                                tris[((triangleIndex + 4) | 0)] = (attachmentFirstVertex + 3) | 0;
                                tris[((triangleIndex + 5) | 0)] = (attachmentFirstVertex + 1) | 0;
                                triangleIndex = (triangleIndex + 6) | 0;
                                attachmentFirstVertex = (attachmentFirstVertex + 4) | 0;
                                continue;
                            }
                            var meshAttachment2 = Bridge.as(attachment2, Spine.MeshAttachment);
                            if (meshAttachment2 != null) {
                                var attachmentTriangles = meshAttachment2.triangles;
                                for (var ii = 0, nn1 = attachmentTriangles.length; ii < nn1; ii = (ii + 1) | 0, triangleIndex = (triangleIndex + 1) | 0) {
                                    tris[triangleIndex] = (attachmentFirstVertex + attachmentTriangles[ii]) | 0;
                                }
                                attachmentFirstVertex = (attachmentFirstVertex + (meshAttachment2.worldVerticesLength >> 1)) | 0; // length/2;
                            }
                        }
                    }
                }
            },
            /*Spine.Unity.MeshGenerator.BuildMeshWithArrays end.*/

            /*Spine.Unity.MeshGenerator.ScaleVertexData start.*/
            ScaleVertexData: function (scale) {
                var vbi = this.vertexBuffer.Items;
                for (var i = 0, n = this.vertexBuffer.Count; i < n; i = (i + 1) | 0) {
                    vbi[i] = vbi[i].$clone().clone().scale( scale ); // vbi[i].x *= scale; vbi[i].y *= scale;
                }

                this.meshBoundsMin = this.meshBoundsMin.$clone().scale( scale );
                this.meshBoundsMax = this.meshBoundsMax.$clone().scale( scale );
                this.meshBoundsThickness *= scale;
            },
            /*Spine.Unity.MeshGenerator.ScaleVertexData end.*/

            /*Spine.Unity.MeshGenerator.GetMeshBounds start.*/
            GetMeshBounds: function () {
                var $t;
                if ((Math.abs(this.meshBoundsMin.x) === Number.POSITIVE_INFINITY)) { // meshBoundsMin.x == BoundsMinDefault // == doesn't work on float Infinity constants.
                    return new pc.BoundingBox.ctor();
                } else {
                    //mesh.bounds = ArraysMeshGenerator.ToBounds(meshBoundsMin, meshBoundsMax);
                    var halfWidth = (this.meshBoundsMax.x - this.meshBoundsMin.x) * 0.5;
                    var halfHeight = (this.meshBoundsMax.y - this.meshBoundsMin.y) * 0.5;
                    return ($t = new pc.BoundingBox.ctor(), $t.center = new pc.Vec3( this.meshBoundsMin.x + halfWidth, this.meshBoundsMin.y + halfHeight, 0 ), $t.halfExtents = new pc.Vec3( halfWidth, halfHeight, this.meshBoundsThickness * 0.5 ), $t);
                }
            },
            /*Spine.Unity.MeshGenerator.GetMeshBounds end.*/

            /*Spine.Unity.MeshGenerator.AddAttachmentTintBlack start.*/
            AddAttachmentTintBlack: function (r2, g2, b2, a, vertexCount) {
                var rg = new pc.Vec2( r2, g2 );
                var bo = new pc.Vec2( b2, a );

                var ovc = this.vertexBuffer.Count;
                var newVertexCount = (ovc + vertexCount) | 0;
                {
                    if (this.uv2 == null) {
                        this.uv2 = new (Spine.ExposedList$1(UnityEngine.Vector2)).ctor();
                        this.uv3 = new (Spine.ExposedList$1(UnityEngine.Vector2)).ctor();
                    }
                    if (newVertexCount > this.uv2.Items.length) { // Manual ExposedList.Resize()
                        System.Array.resize(Bridge.ref(this.uv2, "Items"), newVertexCount, function () {
                            return Bridge.getDefaultValue(UnityEngine.Vector2);
                        }, UnityEngine.Vector2);
                        System.Array.resize(Bridge.ref(this.uv3, "Items"), newVertexCount, function () {
                            return Bridge.getDefaultValue(UnityEngine.Vector2);
                        }, UnityEngine.Vector2);
                    }
                    this.uv2.Count = (this.uv3.Count = newVertexCount, newVertexCount);
                }

                var uv2i = this.uv2.Items;
                var uv3i = this.uv3.Items;
                for (var i = 0; i < vertexCount; i = (i + 1) | 0) {
                    uv2i[((ovc + i) | 0)] = rg.$clone();
                    uv3i[((ovc + i) | 0)] = bo.$clone();
                }
            },
            /*Spine.Unity.MeshGenerator.AddAttachmentTintBlack end.*/

            /*Spine.Unity.MeshGenerator.FillVertexData start.*/
            FillVertexData: function (mesh) {
                var vbi = this.vertexBuffer.Items;
                var ubi = this.uvBuffer.Items;
                var cbi = this.colorBuffer.Items;
                var vbiLength = vbi.length;

                // Zero the extra.
                {
                    var listCount = this.vertexBuffer.Count;
                    var vector3zero = pc.Vec3.ZERO.clone();
                    for (var i = listCount; i < vbiLength; i = (i + 1) | 0) {
                        vbi[i] = vector3zero.$clone();
                    }
                }

                // Set the vertex buffer.
                {
                    mesh.vertices = vbi;
                    mesh.uv = ubi;
                    mesh.colors32 = cbi;
                    mesh.bounds = this.GetMeshBounds();
                }

                {
                    if (this.settings.addNormals) {
                        var oldLength = 0;

                        if (this.normals == null) {
                            this.normals = System.Array.init(vbiLength, function (){
                                return new UnityEngine.Vector3();
                            }, UnityEngine.Vector3);
                        } else {
                            oldLength = this.normals.length;
                        }

                        if (oldLength !== vbiLength) {
                            System.Array.resize(Bridge.ref(this, "normals"), vbiLength, function () {
                                return Bridge.getDefaultValue(UnityEngine.Vector3);
                            }, UnityEngine.Vector3);
                            var localNormals = this.normals;
                            for (var i1 = oldLength; i1 < vbiLength; i1 = (i1 + 1) | 0) {
                                localNormals[i1] = new pc.Vec3( 0, 0, -1 );
                            }
                        }
                        mesh.normals = this.normals;
                    }

                    if (this.settings.tintBlack) {
                        if (this.uv2 != null) {
                            // Sometimes, the vertex buffer becomes smaller. We need to trim the size of the tint black buffers to match.
                            if (vbiLength !== this.uv2.Items.length) {
                                System.Array.resize(Bridge.ref(this.uv2, "Items"), vbiLength, function () {
                                    return Bridge.getDefaultValue(UnityEngine.Vector2);
                                }, UnityEngine.Vector2);
                                System.Array.resize(Bridge.ref(this.uv3, "Items"), vbiLength, function () {
                                    return Bridge.getDefaultValue(UnityEngine.Vector2);
                                }, UnityEngine.Vector2);
                                this.uv2.Count = (this.uv3.Count = vbiLength, vbiLength);
                            }
                            mesh.uv2 = this.uv2.Items;
                            mesh.uv3 = this.uv3.Items;
                        }
                    }
                }
            },
            /*Spine.Unity.MeshGenerator.FillVertexData end.*/

            /*Spine.Unity.MeshGenerator.FillLateVertexData start.*/
            FillLateVertexData: function (mesh) {
                if (this.settings.calculateTangents) {
                    var vertexCount = this.vertexBuffer.Count;
                    var sbi = this.submeshes.Items;
                    var submeshCount = this.submeshes.Count;
                    var vbi = this.vertexBuffer.Items;
                    var ubi = this.uvBuffer.Items;

                    Spine.Unity.MeshGenerator.SolveTangents2DEnsureSize(Bridge.ref(this, "tangents"), Bridge.ref(this, "tempTanBuffer"), vertexCount, vbi.length);
                    for (var i = 0; i < submeshCount; i = (i + 1) | 0) {
                        var submesh = sbi[i].Items;
                        var triangleCount = sbi[i].Count;
                        Spine.Unity.MeshGenerator.SolveTangents2DTriangles(this.tempTanBuffer, submesh, triangleCount, vbi, ubi, vertexCount);
                    }
                    Spine.Unity.MeshGenerator.SolveTangents2DBuffer(this.tangents, this.tempTanBuffer, vertexCount);
                    mesh.tangents = this.tangents;
                }
            },
            /*Spine.Unity.MeshGenerator.FillLateVertexData end.*/

            /*Spine.Unity.MeshGenerator.FillTriangles start.*/
            FillTriangles: function (mesh) {
                var submeshCount = this.submeshes.Count;
                var submeshesItems = this.submeshes.Items;
                mesh.subMeshCount = submeshCount;

                for (var i = 0; i < submeshCount; i = (i + 1) | 0) {
                    mesh.SetTriangles$4(submeshesItems[i].Items, 0, submeshesItems[i].Count, i, false);
                }
            },
            /*Spine.Unity.MeshGenerator.FillTriangles end.*/

            /*Spine.Unity.MeshGenerator.EnsureVertexCapacity start.*/
            EnsureVertexCapacity: function (minimumVertexCount, inlcudeTintBlack, includeTangents, includeNormals) {
                if (inlcudeTintBlack === void 0) { inlcudeTintBlack = false; }
                if (includeTangents === void 0) { includeTangents = false; }
                if (includeNormals === void 0) { includeNormals = false; }
                if (minimumVertexCount > this.vertexBuffer.Items.length) {
                    System.Array.resize(Bridge.ref(this.vertexBuffer, "Items"), minimumVertexCount, function () {
                        return Bridge.getDefaultValue(UnityEngine.Vector3);
                    }, UnityEngine.Vector3);
                    System.Array.resize(Bridge.ref(this.uvBuffer, "Items"), minimumVertexCount, function () {
                        return Bridge.getDefaultValue(UnityEngine.Vector2);
                    }, UnityEngine.Vector2);
                    System.Array.resize(Bridge.ref(this.colorBuffer, "Items"), minimumVertexCount, function () {
                        return Bridge.getDefaultValue(UnityEngine.Color32);
                    }, UnityEngine.Color32);

                    if (inlcudeTintBlack) {
                        if (this.uv2 == null) {
                            this.uv2 = new (Spine.ExposedList$1(UnityEngine.Vector2)).$ctor3(minimumVertexCount);
                            this.uv3 = new (Spine.ExposedList$1(UnityEngine.Vector2)).$ctor3(minimumVertexCount);
                        }
                        this.uv2.Resize(minimumVertexCount);
                        this.uv3.Resize(minimumVertexCount);
                    }

                    if (includeNormals) {
                        if (this.normals == null) {
                            this.normals = System.Array.init(minimumVertexCount, function (){
                                return new UnityEngine.Vector3();
                            }, UnityEngine.Vector3);
                        } else {
                            System.Array.resize(Bridge.ref(this, "normals"), minimumVertexCount, function () {
                                return Bridge.getDefaultValue(UnityEngine.Vector3);
                            }, UnityEngine.Vector3);
                        }

                    }

                    if (includeTangents) {
                        if (this.tangents == null) {
                            this.tangents = System.Array.init(minimumVertexCount, function (){
                                return new UnityEngine.Vector4();
                            }, UnityEngine.Vector4);
                        } else {
                            System.Array.resize(Bridge.ref(this, "tangents"), minimumVertexCount, function () {
                                return Bridge.getDefaultValue(UnityEngine.Vector4);
                            }, UnityEngine.Vector4);
                        }
                    }
                }
            },
            /*Spine.Unity.MeshGenerator.EnsureVertexCapacity end.*/

            /*Spine.Unity.MeshGenerator.TrimExcess start.*/
            /**
             * Trims internal buffers to reduce the resulting mesh data stream size.
             *
             * @instance
             * @public
             * @this Spine.Unity.MeshGenerator
             * @memberof Spine.Unity.MeshGenerator
             * @return  {void}
             */
            TrimExcess: function () {
                this.vertexBuffer.TrimExcess();
                this.uvBuffer.TrimExcess();
                this.colorBuffer.TrimExcess();

                if (this.uv2 != null) {
                    this.uv2.TrimExcess();
                }
                if (this.uv3 != null) {
                    this.uv3.TrimExcess();
                }

                var vbiLength = this.vertexBuffer.Items.length;
                if (this.normals != null) {
                    System.Array.resize(Bridge.ref(this, "normals"), vbiLength, function () {
                        return Bridge.getDefaultValue(UnityEngine.Vector3);
                    }, UnityEngine.Vector3);
                }
                if (this.tangents != null) {
                    System.Array.resize(Bridge.ref(this, "tangents"), vbiLength, function () {
                        return Bridge.getDefaultValue(UnityEngine.Vector4);
                    }, UnityEngine.Vector4);
                }
            },
            /*Spine.Unity.MeshGenerator.TrimExcess end.*/


        }
    });
    /*Spine.Unity.MeshGenerator end.*/

    /*Spine.Unity.MeshGenerator+Settings start.*/
    Bridge.define("Spine.Unity.MeshGenerator.Settings", {
        $kind: 1004,
        statics: {
            props: {
                Default: {
                    get: function () {
                        var $t;
                        return ($t = new Spine.Unity.MeshGenerator.Settings(), $t.pmaVertexColors = true, $t.zSpacing = 0.0, $t.useClipping = true, $t.tintBlack = false, $t.calculateTangents = false, $t.addNormals = false, $t.immutableTriangles = false, $t);
                    }
                }
            },
            methods: {
                getDefaultValue: function () { return new Spine.Unity.MeshGenerator.Settings(); }
            }
        },
        fields: {
            useClipping: false,
            zSpacing: 0,
            pmaVertexColors: false,
            tintBlack: false,
            canvasGroupTintBlack: false,
            calculateTangents: false,
            addNormals: false,
            immutableTriangles: false
        },
        ctors: {
            ctor: function () {
                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
                var h = Bridge.addHash([3889943484, this.useClipping, this.zSpacing, this.pmaVertexColors, this.tintBlack, this.canvasGroupTintBlack, this.calculateTangents, this.addNormals, this.immutableTriangles]);
                return h;
            },
            equals: function (o) {
                if (!Bridge.is(o, Spine.Unity.MeshGenerator.Settings)) {
                    return false;
                }
                return Bridge.equals(this.useClipping, o.useClipping) && Bridge.equals(this.zSpacing, o.zSpacing) && Bridge.equals(this.pmaVertexColors, o.pmaVertexColors) && Bridge.equals(this.tintBlack, o.tintBlack) && Bridge.equals(this.canvasGroupTintBlack, o.canvasGroupTintBlack) && Bridge.equals(this.calculateTangents, o.calculateTangents) && Bridge.equals(this.addNormals, o.addNormals) && Bridge.equals(this.immutableTriangles, o.immutableTriangles);
            },
            $clone: function (to) {
                var s = to || new Spine.Unity.MeshGenerator.Settings();
                s.useClipping = this.useClipping;
                s.zSpacing = this.zSpacing;
                s.pmaVertexColors = this.pmaVertexColors;
                s.tintBlack = this.tintBlack;
                s.canvasGroupTintBlack = this.canvasGroupTintBlack;
                s.calculateTangents = this.calculateTangents;
                s.addNormals = this.addNormals;
                s.immutableTriangles = this.immutableTriangles;
                return s;
            }
        }
    });
    /*Spine.Unity.MeshGenerator+Settings end.*/

    /*Spine.Unity.MeshGeneratorBuffers start.*/
    Bridge.define("Spine.Unity.MeshGeneratorBuffers", {
        $kind: 4,
        statics: {
            methods: {
                getDefaultValue: function () { return new Spine.Unity.MeshGeneratorBuffers(); }
            }
        },
        fields: {
            /**
             * The vertex count that will actually be used for the mesh. The Lengths of the buffer arrays may be larger than this number.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.MeshGeneratorBuffers
             * @type number
             */
            vertexCount: 0,
            /**
             * Vertex positions. To be used for UnityEngine.Mesh.vertices.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.MeshGeneratorBuffers
             * @type Array.<UnityEngine.Vector3>
             */
            vertexBuffer: null,
            /**
             * Vertex UVs. To be used for UnityEngine.Mesh.uvs.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.MeshGeneratorBuffers
             * @type Array.<UnityEngine.Vector2>
             */
            uvBuffer: null,
            /**
             * Vertex colors. To be used for UnityEngine.Mesh.colors32.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.MeshGeneratorBuffers
             * @type Array.<UnityEngine.Color32>
             */
            colorBuffer: null,
            /**
             * The Spine rendering component's MeshGenerator.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.MeshGeneratorBuffers
             * @type Spine.Unity.MeshGenerator
             */
            meshGenerator: null
        },
        ctors: {
            ctor: function () {
                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
                var h = Bridge.addHash([8979862494, this.vertexCount, this.vertexBuffer, this.uvBuffer, this.colorBuffer, this.meshGenerator]);
                return h;
            },
            equals: function (o) {
                if (!Bridge.is(o, Spine.Unity.MeshGeneratorBuffers)) {
                    return false;
                }
                return Bridge.equals(this.vertexCount, o.vertexCount) && Bridge.equals(this.vertexBuffer, o.vertexBuffer) && Bridge.equals(this.uvBuffer, o.uvBuffer) && Bridge.equals(this.colorBuffer, o.colorBuffer) && Bridge.equals(this.meshGenerator, o.meshGenerator);
            },
            $clone: function (to) {
                var s = to || new Spine.Unity.MeshGeneratorBuffers();
                s.vertexCount = this.vertexCount;
                s.vertexBuffer = this.vertexBuffer;
                s.uvBuffer = this.uvBuffer;
                s.colorBuffer = this.colorBuffer;
                s.meshGenerator = this.meshGenerator;
                return s;
            }
        }
    });
    /*Spine.Unity.MeshGeneratorBuffers end.*/

    /*Spine.Unity.MeshRendererBuffers start.*/
    /**
     * A double-buffered Mesh, and a shared material array, bundled for use by Spine components that need to push a Mesh and materials to a Unity MeshRenderer and MeshFilter.
     *
     * @public
     * @class Spine.Unity.MeshRendererBuffers
     * @implements  System.IDisposable
     */
    Bridge.define("Spine.Unity.MeshRendererBuffers", {
        inherits: [System.IDisposable],
        fields: {
            doubleBufferedMesh: null,
            submeshMaterials: null,
            sharedMaterials: null
        },
        alias: ["Dispose", "System$IDisposable$Dispose"],
        ctors: {
            init: function () {
                this.submeshMaterials = new (Spine.ExposedList$1(UnityEngine.Material)).ctor();
                this.sharedMaterials = System.Array.init(0, null, UnityEngine.Material);
            }
        },
        methods: {
            /*Spine.Unity.MeshRendererBuffers.Initialize start.*/
            Initialize: function () {
                if (this.doubleBufferedMesh != null) {
                    this.doubleBufferedMesh.GetNext().Clear();
                    this.doubleBufferedMesh.GetNext().Clear();
                    this.submeshMaterials.Clear();
                } else {
                    this.doubleBufferedMesh = new (Spine.Unity.DoubleBuffered$1(Spine.Unity.MeshRendererBuffers.SmartMesh))();
                }
            },
            /*Spine.Unity.MeshRendererBuffers.Initialize end.*/

            /*Spine.Unity.MeshRendererBuffers.GetUpdatedSharedMaterialsArray start.*/
            /**
             * Returns a sharedMaterials array for use on a MeshRenderer.
             *
             * @instance
             * @public
             * @this Spine.Unity.MeshRendererBuffers
             * @memberof Spine.Unity.MeshRendererBuffers
             * @return  {Array.<UnityEngine.Material>}
             */
            GetUpdatedSharedMaterialsArray: function () {
                if (this.submeshMaterials.Count === this.sharedMaterials.length) {
                    this.submeshMaterials.CopyTo(this.sharedMaterials);
                } else {
                    this.sharedMaterials = this.submeshMaterials.ToArray();
                }

                return this.sharedMaterials;
            },
            /*Spine.Unity.MeshRendererBuffers.GetUpdatedSharedMaterialsArray end.*/

            /*Spine.Unity.MeshRendererBuffers.MaterialsChangedInLastUpdate start.*/
            /**
             * Returns true if the materials were modified since the buffers were last updated.
             *
             * @instance
             * @public
             * @this Spine.Unity.MeshRendererBuffers
             * @memberof Spine.Unity.MeshRendererBuffers
             * @return  {boolean}
             */
            MaterialsChangedInLastUpdate: function () {
                var newSubmeshMaterials = this.submeshMaterials.Count;
                var sharedMaterials = this.sharedMaterials;
                if (newSubmeshMaterials !== sharedMaterials.length) {
                    return true;
                }

                var submeshMaterialsItems = this.submeshMaterials.Items;
                for (var i = 0; i < newSubmeshMaterials; i = (i + 1) | 0) {
                    if (!Bridge.referenceEquals(submeshMaterialsItems[i], sharedMaterials[i])) {
                        return true;
                    }
                } //if (submeshMaterialsItems[i].GetInstanceID() != sharedMaterials[i].GetInstanceID()) return true;

                return false;
            },
            /*Spine.Unity.MeshRendererBuffers.MaterialsChangedInLastUpdate end.*/

            /*Spine.Unity.MeshRendererBuffers.UpdateSharedMaterials start.*/
            /**
             * Updates the internal shared materials array with the given instruction list.
             *
             * @instance
             * @public
             * @this Spine.Unity.MeshRendererBuffers
             * @memberof Spine.Unity.MeshRendererBuffers
             * @param   {Spine.ExposedList$1}    instructions
             * @return  {void}
             */
            UpdateSharedMaterials: function (instructions) {
                var newSize = instructions.Count;
                { //submeshMaterials.Resize(instructions.Count);
                    if (newSize > this.submeshMaterials.Items.length) {
                        System.Array.resize(Bridge.ref(this.submeshMaterials, "Items"), newSize, null, UnityEngine.Material);
                    }
                    this.submeshMaterials.Count = newSize;
                }

                var submeshMaterialsItems = this.submeshMaterials.Items;
                var instructionsItems = instructions.Items;
                for (var i = 0; i < newSize; i = (i + 1) | 0) {
                    submeshMaterialsItems[i] = instructionsItems[i].material;
                }
            },
            /*Spine.Unity.MeshRendererBuffers.UpdateSharedMaterials end.*/

            /*Spine.Unity.MeshRendererBuffers.GetNextMesh start.*/
            GetNextMesh: function () {
                return this.doubleBufferedMesh.GetNext();
            },
            /*Spine.Unity.MeshRendererBuffers.GetNextMesh end.*/

            /*Spine.Unity.MeshRendererBuffers.Clear start.*/
            Clear: function () {
                this.sharedMaterials = System.Array.init(0, null, UnityEngine.Material);
                this.submeshMaterials.Clear();
            },
            /*Spine.Unity.MeshRendererBuffers.Clear end.*/

            /*Spine.Unity.MeshRendererBuffers.Dispose start.*/
            Dispose: function () {
                if (this.doubleBufferedMesh == null) {
                    return;
                }
                this.doubleBufferedMesh.GetNext().Dispose();
                this.doubleBufferedMesh.GetNext().Dispose();
                this.doubleBufferedMesh = null;
            },
            /*Spine.Unity.MeshRendererBuffers.Dispose end.*/


        }
    });
    /*Spine.Unity.MeshRendererBuffers end.*/

    /*Spine.Unity.MeshRendererBuffers+SmartMesh start.*/
    /**
     * This is a Mesh that also stores the instructions SkeletonRenderer generated for it.
     *
     * @public
     * @class Spine.Unity.MeshRendererBuffers.SmartMesh
     * @implements  System.IDisposable
     */
    Bridge.define("Spine.Unity.MeshRendererBuffers.SmartMesh", {
        inherits: [System.IDisposable],
        $kind: 1002,
        fields: {
            mesh: null,
            instructionUsed: null
        },
        alias: ["Dispose", "System$IDisposable$Dispose"],
        ctors: {
            init: function () {
                this.mesh = Spine.Unity.SpineMesh.NewSkeletonMesh();
                this.instructionUsed = new Spine.Unity.SkeletonRendererInstruction();
            }
        },
        methods: {
            /*Spine.Unity.MeshRendererBuffers+SmartMesh.Clear start.*/
            Clear: function () {
                this.mesh.Clear();
                this.instructionUsed.Clear();
            },
            /*Spine.Unity.MeshRendererBuffers+SmartMesh.Clear end.*/

            /*Spine.Unity.MeshRendererBuffers+SmartMesh.Dispose start.*/
            Dispose: function () {
                if (this.mesh != null) {
                    UnityEngine.Object.Destroy(this.mesh);
                }
                this.mesh = null;
            },
            /*Spine.Unity.MeshRendererBuffers+SmartMesh.Dispose end.*/


        }
    });
    /*Spine.Unity.MeshRendererBuffers+SmartMesh end.*/

    /*Spine.Unity.NoOpTextureLoader start.*/
    Bridge.define("Spine.Unity.NoOpTextureLoader", {
        inherits: [Spine.TextureLoader],
        alias: [
            "Load", "Spine$TextureLoader$Load",
            "Unload", "Spine$TextureLoader$Unload"
        ],
        methods: {
            /*Spine.Unity.NoOpTextureLoader.Load start.*/
            Load: function (page, path) { },
            /*Spine.Unity.NoOpTextureLoader.Load end.*/

            /*Spine.Unity.NoOpTextureLoader.Unload start.*/
            Unload: function (texture) { },
            /*Spine.Unity.NoOpTextureLoader.Unload end.*/


        }
    });
    /*Spine.Unity.NoOpTextureLoader end.*/

    /*Spine.Unity.OnDemandTextureLoader start.*/
    Bridge.define("Spine.Unity.OnDemandTextureLoader", {
        inherits: [UnityEngine.ScriptableObject],
        fields: {
            atlasAsset: null
        },
        events: {
            onTextureRequested: null,
            onTextureLoaded: null,
            onTextureUnloaded: null
        },
        methods: {
            addTextureRequested: function (value) {
                this.addonTextureRequested(value);
            },
            removeTextureRequested: function (value) {
                this.removeonTextureRequested(value);
            },
            addTextureLoaded: function (value) {
                this.addonTextureLoaded(value);
            },
            removeTextureLoaded: function (value) {
                this.removeonTextureLoaded(value);
            },
            addTextureUnloaded: function (value) {
                this.addonTextureUnloaded(value);
            },
            removeTextureUnloaded: function (value) {
                this.removeonTextureUnloaded(value);
            },
            /*Spine.Unity.OnDemandTextureLoader.HasNullMainTexturesAssigned start.*/
            /**
             * Returns whether any main texture is null at a Material of the associated AtlasAssetBase.
             *
             * @instance
             * @public
             * @this Spine.Unity.OnDemandTextureLoader
             * @memberof Spine.Unity.OnDemandTextureLoader
             * @param   {System.Collections.Generic.List}    nullTextureMaterials    A newly created list of materials which has a null main texture assigned.
             * @return  {boolean}                                                    True, if any null main texture is assigned at a Material of the associated AtlasAssetBase.
             */
            HasNullMainTexturesAssigned: function (nullTextureMaterials) {
                var $t;
                nullTextureMaterials.v = null;
                if (!UnityEngine.Object.op_Implicit(this.atlasAsset)) {
                    return false;
                }

                var anyNullTexture = false;
                $t = Bridge.getEnumerator(this.atlasAsset.Materials, UnityEngine.Material);
                try {
                    while ($t.moveNext()) {
                        var material = $t.Current;
                        if (material.mainTexture == null) {
                            anyNullTexture = true;
                            if (nullTextureMaterials.v == null) {
                                nullTextureMaterials.v = new (System.Collections.Generic.List$1(UnityEngine.Material)).ctor();
                            }
                            nullTextureMaterials.v.add(material);
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                return anyNullTexture;
            },
            /*Spine.Unity.OnDemandTextureLoader.HasNullMainTexturesAssigned end.*/

            /*Spine.Unity.OnDemandTextureLoader.OnTextureRequested start.*/
            OnTextureRequested: function (material, textureIndex) {
                if (!Bridge.staticEquals(this.onTextureRequested, null)) {
                    this.onTextureRequested(this, material, textureIndex);
                }
            },
            /*Spine.Unity.OnDemandTextureLoader.OnTextureRequested end.*/

            /*Spine.Unity.OnDemandTextureLoader.OnTextureLoaded start.*/
            OnTextureLoaded: function (material, textureIndex) {
                if (!Bridge.staticEquals(this.onTextureLoaded, null)) {
                    this.onTextureLoaded(this, material, textureIndex);
                }
            },
            /*Spine.Unity.OnDemandTextureLoader.OnTextureLoaded end.*/

            /*Spine.Unity.OnDemandTextureLoader.OnTextureUnloaded start.*/
            OnTextureUnloaded: function (material, textureIndex) {
                if (!Bridge.staticEquals(this.onTextureUnloaded, null)) {
                    this.onTextureUnloaded(this, material, textureIndex);
                }
            },
            /*Spine.Unity.OnDemandTextureLoader.OnTextureUnloaded end.*/


        }
    });
    /*Spine.Unity.OnDemandTextureLoader end.*/

    /*Spine.Unity.RegionlessAttachmentLoader start.*/
    Bridge.define("Spine.Unity.RegionlessAttachmentLoader", {
        inherits: [Spine.AttachmentLoader],
        statics: {
            fields: {
                emptyRegion: null
            },
            props: {
                EmptyRegion: {
                    get: function () {
                        var $t, $t1, $t2;
                        if (Spine.Unity.RegionlessAttachmentLoader.emptyRegion == null) {
                            Spine.Unity.RegionlessAttachmentLoader.emptyRegion = ($t = new Spine.AtlasRegion(), $t.name = "Empty AtlasRegion", $t.page = ($t1 = new Spine.AtlasPage(), $t1.name = "Empty AtlasPage", $t1.rendererObject = ($t2 = new UnityEngine.Material.$ctor2(UnityEngine.Shader.Find("Spine/Special/HiddenPass")), $t2.name = "NoRender Material", $t2), $t1), $t);
                        }
                        return Spine.Unity.RegionlessAttachmentLoader.emptyRegion;
                    }
                }
            }
        },
        alias: [
            "NewBoundingBoxAttachment", "Spine$AttachmentLoader$NewBoundingBoxAttachment",
            "NewPathAttachment", "Spine$AttachmentLoader$NewPathAttachment",
            "NewPointAttachment", "Spine$AttachmentLoader$NewPointAttachment",
            "NewClippingAttachment", "Spine$AttachmentLoader$NewClippingAttachment"
        ],
        methods: {
            /*Spine.Unity.RegionlessAttachmentLoader.NewRegionAttachment start.*/
            NewRegionAttachment: function (skin, name, path, sequence) {
                var $t;
                var attachment = ($t = new Spine.RegionAttachment(name), $t.region = Spine.Unity.RegionlessAttachmentLoader.EmptyRegion, $t);
                return attachment;
            },
            /*Spine.Unity.RegionlessAttachmentLoader.NewRegionAttachment end.*/

            /*Spine.Unity.RegionlessAttachmentLoader.NewMeshAttachment start.*/
            NewMeshAttachment: function (skin, name, path, sequence) {
                var $t;
                var attachment = ($t = new Spine.MeshAttachment(name), $t.region = Spine.Unity.RegionlessAttachmentLoader.EmptyRegion, $t);
                return attachment;
            },
            /*Spine.Unity.RegionlessAttachmentLoader.NewMeshAttachment end.*/

            /*Spine.Unity.RegionlessAttachmentLoader.NewBoundingBoxAttachment start.*/
            NewBoundingBoxAttachment: function (skin, name) {
                return new spine.BoundingBoxAttachment( name );
            },
            /*Spine.Unity.RegionlessAttachmentLoader.NewBoundingBoxAttachment end.*/

            /*Spine.Unity.RegionlessAttachmentLoader.NewPathAttachment start.*/
            NewPathAttachment: function (skin, name) {
                return new spine.PathAttachment( name );
            },
            /*Spine.Unity.RegionlessAttachmentLoader.NewPathAttachment end.*/

            /*Spine.Unity.RegionlessAttachmentLoader.NewPointAttachment start.*/
            NewPointAttachment: function (skin, name) {
                return new spine.PointAttachment( name );
            },
            /*Spine.Unity.RegionlessAttachmentLoader.NewPointAttachment end.*/

            /*Spine.Unity.RegionlessAttachmentLoader.NewClippingAttachment start.*/
            NewClippingAttachment: function (skin, name) {
                return new spine.ClippingAttachment( name );
            },
            /*Spine.Unity.RegionlessAttachmentLoader.NewClippingAttachment end.*/


        }
    });
    /*Spine.Unity.RegionlessAttachmentLoader end.*/

    /*Spine.Unity.SettingsTriState start.*/
    /**
     * TriState enum which can be used to replace and extend a bool variable by
     a third <pre><code>UseGlobalSettings</code></pre> state. Automatically maps serialized
     bool values to corresponding <pre><code>Disable</code></pre> and <pre><code>Enable</code></pre> states.
     *
     * @public
     * @class Spine.Unity.SettingsTriState
     */
    Bridge.define("Spine.Unity.SettingsTriState", {
        $kind: 6,
        statics: {
            fields: {
                Disable: 0,
                Enable: 1,
                UseGlobalSetting: 2
            }
        }
    });
    /*Spine.Unity.SettingsTriState end.*/

    /*Spine.Unity.SkeletonDataAsset start.*/
    Bridge.define("Spine.Unity.SkeletonDataAsset", {
        inherits: [UnityEngine.ScriptableObject],
        statics: {
            methods: {
                /*Spine.Unity.SkeletonDataAsset.CreateRuntimeInstance:static start.*/
                /**
                 * Creates a runtime SkeletonDataAsset.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonDataAsset
                 * @memberof Spine.Unity.SkeletonDataAsset
                 * @param   {UnityEngine.TextAsset}            skeletonDataFile    
                 * @param   {Spine.Unity.AtlasAssetBase}       atlasAsset          
                 * @param   {boolean}                          initialize          
                 * @param   {number}                           scale
                 * @return  {Spine.Unity.SkeletonDataAsset}
                 */
                CreateRuntimeInstance: function (skeletonDataFile, atlasAsset, initialize, scale) {
                    if (scale === void 0) { scale = 0.01; }
                    return Spine.Unity.SkeletonDataAsset.CreateRuntimeInstance$1(skeletonDataFile, System.Array.init([atlasAsset], Spine.Unity.AtlasAssetBase), initialize, scale);
                },
                /*Spine.Unity.SkeletonDataAsset.CreateRuntimeInstance:static end.*/

                /*Spine.Unity.SkeletonDataAsset.CreateRuntimeInstance$1:static start.*/
                /**
                 * Creates a runtime SkeletonDataAsset.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonDataAsset
                 * @memberof Spine.Unity.SkeletonDataAsset
                 * @param   {UnityEngine.TextAsset}                 skeletonDataFile    
                 * @param   {Array.<Spine.Unity.AtlasAssetBase>}    atlasAssets         
                 * @param   {boolean}                               initialize          
                 * @param   {number}                                scale
                 * @return  {Spine.Unity.SkeletonDataAsset}
                 */
                CreateRuntimeInstance$1: function (skeletonDataFile, atlasAssets, initialize, scale) {
                    if (scale === void 0) { scale = 0.01; }
                    var skeletonDataAsset = UnityEngine.ScriptableObject.CreateInstance(Spine.Unity.SkeletonDataAsset);
                    skeletonDataAsset.Clear();
                    skeletonDataAsset.skeletonJSON = skeletonDataFile;
                    skeletonDataAsset.atlasAssets = atlasAssets;
                    skeletonDataAsset.scale = scale;

                    if (initialize) {
                        skeletonDataAsset.GetSkeletonData(true);
                    }

                    return skeletonDataAsset;
                },
                /*Spine.Unity.SkeletonDataAsset.CreateRuntimeInstance$1:static end.*/

                /*Spine.Unity.SkeletonDataAsset.ReadSkeletonData:static start.*/
                ReadSkeletonData: function (bytes, attachmentLoader, scale) {
                    var $t;
                    var input = new System.IO.MemoryStream.$ctor1(bytes);
                    try {
                        var binary = ($t = new Spine.SkeletonBinary(attachmentLoader), $t.scale = scale, $t);
                        return binary.ReadSkeletonData(input);
                    }
                    finally {
                        if (Bridge.hasValue(input)) {
                            input.System$IDisposable$Dispose();
                        }
                    }
                },
                /*Spine.Unity.SkeletonDataAsset.ReadSkeletonData:static end.*/

                /*Spine.Unity.SkeletonDataAsset.ReadSkeletonData$1:static start.*/
                ReadSkeletonData$1: function (text, attachmentLoader, scale) {
                    var $t;
                    var input = new System.IO.StringReader(text);
                    var json = ($t = new Spine.SkeletonJson(attachmentLoader), $t.scale = scale, $t);
                    return json.ReadSkeletonData(input);
                },
                /*Spine.Unity.SkeletonDataAsset.ReadSkeletonData$1:static end.*/


            }
        },
        fields: {
            atlasAssets: null,
            scale: 0,
            skeletonJSON: null,
            isUpgradingBlendModeMaterials: false,
            blendModeMaterials: null,
            skeletonDataModifiers: null,
            fromAnimation: null,
            toAnimation: null,
            duration: null,
            defaultMix: 0,
            controller: null,
            skeletonData: null,
            stateData: null
        },
        props: {
            IsLoaded: {
                get: function () {
                    return this.skeletonData != null;
                }
            }
        },
        ctors: {
            init: function () {
                this.atlasAssets = System.Array.init(0, null, Spine.Unity.AtlasAssetBase);
                this.scale = 0.01;
                this.isUpgradingBlendModeMaterials = false;
                this.blendModeMaterials = new Spine.Unity.BlendModeMaterials();
                this.skeletonDataModifiers = new (System.Collections.Generic.List$1(Spine.Unity.SkeletonDataModifierAsset)).ctor();
                this.fromAnimation = System.Array.init(0, null, System.String);
                this.toAnimation = System.Array.init(0, null, System.String);
                this.duration = System.Array.init(0, 0, System.Single);
            }
        },
        methods: {
            /*Spine.Unity.SkeletonDataAsset.Reset start.*/
            Reset: function () {
                this.Clear();
            },
            /*Spine.Unity.SkeletonDataAsset.Reset end.*/

            /*Spine.Unity.SkeletonDataAsset.Clear start.*/
            /**
             * Clears the loaded SkeletonData and AnimationStateData. Use this to force a reload for the next time GetSkeletonData is called.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonDataAsset
             * @memberof Spine.Unity.SkeletonDataAsset
             * @return  {void}
             */
            Clear: function () {
                this.skeletonData = null;
                this.stateData = null;
            },
            /*Spine.Unity.SkeletonDataAsset.Clear end.*/

            /*Spine.Unity.SkeletonDataAsset.GetAnimationStateData start.*/
            GetAnimationStateData: function () {
                if (this.stateData != null) {
                    return this.stateData;
                }
                this.GetSkeletonData(false);
                return this.stateData;
            },
            /*Spine.Unity.SkeletonDataAsset.GetAnimationStateData end.*/

            /*Spine.Unity.SkeletonDataAsset.GetSkeletonData start.*/
            /**
             * Loads, caches and returns the SkeletonData from the skeleton data file. Returns the cached SkeletonData after the first time it is called. Pass false to prevent direct errors from being logged.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonDataAsset
             * @memberof Spine.Unity.SkeletonDataAsset
             * @param   {boolean}               quiet
             * @return  {Spine.SkeletonData}
             */
            GetSkeletonData: function (quiet) {
                var $t;
                if (this.skeletonJSON == null) {
                    if (!quiet) {
                        UnityEngine.Debug.LogError$2("Skeleton JSON file not set for SkeletonData asset: " + (this.name || ""), this);
                    }
                    this.Clear();
                    return null;
                }

                // Disabled to support attachmentless/skinless SkeletonData.
                //			if (atlasAssets == null) {
                //				atlasAssets = new AtlasAsset[0];
                //				if (!quiet)
                //					Debug.LogError("Atlas not set for SkeletonData asset: " + name, this);
                //				Clear();
                //				return null;
                //			}
                //			#if !SPINE_TK2D
                //			if (atlasAssets.Length == 0) {
                //				Clear();
                //				return null;
                //			}
                //			#else
                //			if (atlasAssets.Length == 0 && spriteCollection == null) {
                //				Clear();
                //				return null;
                //			}
                //			#endif

                if (this.skeletonData != null) {
                    return this.skeletonData;
                }

                var attachmentLoader;
                var skeletonDataScale;
                var atlasArray = this.GetAtlasArray();

                attachmentLoader = (atlasArray.length === 0) ? Bridge.cast(new Spine.Unity.RegionlessAttachmentLoader(), Spine.AttachmentLoader) : Bridge.cast(new Spine.AtlasAttachmentLoader(atlasArray), Spine.AttachmentLoader);
                skeletonDataScale = this.scale;

                var hasBinaryExtension = System.String.contains(this.skeletonJSON.name.toLowerCase(),".skel");
                var loadedSkeletonData = null;

                try {
                    if (hasBinaryExtension) {
                        loadedSkeletonData = Spine.Unity.SkeletonDataAsset.ReadSkeletonData(this.skeletonJSON.bytes, attachmentLoader, skeletonDataScale);
                    } else {
                        loadedSkeletonData = Spine.Unity.SkeletonDataAsset.ReadSkeletonData$1(this.skeletonJSON.text, attachmentLoader, skeletonDataScale);
                    }
                } catch (ex) {
                    ex = System.Exception.create(ex);
                    if (!quiet) {
                        UnityEngine.Debug.LogError$2("Error reading skeleton JSON file for SkeletonData asset: " + (this.name || "") + "\n" + (ex.Message || "") + "\n" + (ex.StackTrace || ""), this.skeletonJSON);
                    }
                }

                if (loadedSkeletonData == null) {
                    return null;
                }

                if (this.skeletonDataModifiers != null) {
                    $t = Bridge.getEnumerator(this.skeletonDataModifiers);
                    try {
                        while ($t.moveNext()) {
                            var modifier = $t.Current;
                            if (modifier != null && !(this.isUpgradingBlendModeMaterials && Bridge.is(modifier, Spine.Unity.BlendModeMaterialsAsset))) {
                                modifier.Apply(loadedSkeletonData);
                            }
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                }
                if (!this.isUpgradingBlendModeMaterials) {
                    this.blendModeMaterials.ApplyMaterials(loadedSkeletonData);
                }

                this.InitializeWithData(loadedSkeletonData);

                return this.skeletonData;
            },
            /*Spine.Unity.SkeletonDataAsset.GetSkeletonData end.*/

            /*Spine.Unity.SkeletonDataAsset.InitializeWithData start.*/
            InitializeWithData: function (sd) {
                this.skeletonData = sd;
                this.stateData = new spine.AnimationStateData( this.skeletonData );
                this.FillStateData();
            },
            /*Spine.Unity.SkeletonDataAsset.InitializeWithData end.*/

            /*Spine.Unity.SkeletonDataAsset.FillStateData start.*/
            FillStateData: function (quiet) {
                if (quiet === void 0) { quiet = false; }
                if (this.stateData != null) {
                    this.stateData.defaultMix = this.defaultMix;

                    for (var i = 0, n = this.fromAnimation.length; i < n; i = (i + 1) | 0) {
                        var fromAnimationName = this.fromAnimation[i];
                        var toAnimationName = this.toAnimation[i];
                        if (fromAnimationName.length === 0 || toAnimationName.length === 0) {
                            continue;
                        }
                        this.stateData.setMix(fromAnimationName, toAnimationName, this.duration[i]);
                    }
                }
            },
            /*Spine.Unity.SkeletonDataAsset.FillStateData end.*/

            /*Spine.Unity.SkeletonDataAsset.GetAtlasArray start.*/
            GetAtlasArray: function () {
                var returnList = new (System.Collections.Generic.List$1(Spine.Atlas)).$ctor2(this.atlasAssets.length);
                for (var i = 0; i < this.atlasAssets.length; i = (i + 1) | 0) {
                    var aa = this.atlasAssets[i];
                    if (aa == null) {
                        continue;
                    }
                    var a = aa.GetAtlas();
                    if (a == null) {
                        continue;
                    }
                    returnList.add(a);
                }
                return returnList.ToArray();
            },
            /*Spine.Unity.SkeletonDataAsset.GetAtlasArray end.*/


        }
    });
    /*Spine.Unity.SkeletonDataAsset end.*/

    /*Spine.Unity.SkeletonDataCompatibility start.*/
    Bridge.define("Spine.Unity.SkeletonDataCompatibility");
    /*Spine.Unity.SkeletonDataCompatibility end.*/

    /*Spine.Unity.SkeletonDataCompatibility+CompatibilityProblemInfo start.*/
    Bridge.define("Spine.Unity.SkeletonDataCompatibility.CompatibilityProblemInfo", {
        $kind: 1002,
        fields: {
            actualVersion: null,
            compatibleVersions: null,
            explicitProblemDescription: null
        },
        methods: {
            /*Spine.Unity.SkeletonDataCompatibility+CompatibilityProblemInfo.DescriptionString start.*/
            DescriptionString: function () {
                var $t, $t1, $t2;
                if (!System.String.isNullOrEmpty(this.explicitProblemDescription)) {
                    return this.explicitProblemDescription;
                }

                var compatibleVersionString = "";
                var optionalOr = null;
                $t = Bridge.getEnumerator(this.compatibleVersions);
                try {
                    while ($t.moveNext()) {
                        var version = $t.Current;
                        compatibleVersionString = (compatibleVersionString || "") + ((System.String.format("{0}{1}.{2}", optionalOr, Bridge.box(version[0], System.Int32), Bridge.box(version[1], System.Int32))) || "");
                        optionalOr = " or ";
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                return System.String.format("Skeleton data could not be loaded. Data version: {0}. Required version: {1}.\nPlease re-export skeleton data with Spine {1} or change runtime to version {2}.{3}.", this.actualVersion.rawVersion, compatibleVersionString, Bridge.box(($t1 = this.actualVersion.version)[0], System.Int32), Bridge.box(($t2 = this.actualVersion.version)[1], System.Int32));
            },
            /*Spine.Unity.SkeletonDataCompatibility+CompatibilityProblemInfo.DescriptionString end.*/


        }
    });
    /*Spine.Unity.SkeletonDataCompatibility+CompatibilityProblemInfo end.*/

    /*Spine.Unity.SkeletonDataCompatibility+SourceType start.*/
    Bridge.define("Spine.Unity.SkeletonDataCompatibility.SourceType", {
        $kind: 1006,
        statics: {
            fields: {
                Json: 0,
                Binary: 1
            }
        }
    });
    /*Spine.Unity.SkeletonDataCompatibility+SourceType end.*/

    /*Spine.Unity.SkeletonDataCompatibility+VersionInfo start.*/
    Bridge.define("Spine.Unity.SkeletonDataCompatibility.VersionInfo", {
        $kind: 1002,
        fields: {
            rawVersion: null,
            version: null,
            sourceType: 0
        }
    });
    /*Spine.Unity.SkeletonDataCompatibility+VersionInfo end.*/

    /*Spine.Unity.SkeletonExtensions start.*/
    Bridge.define("Spine.Unity.SkeletonExtensions", {
        statics: {
            fields: {
                ByteToFloat: 0
            },
            ctors: {
                init: function () {
                    this.ByteToFloat = 0.003921569;
                }
            },
            methods: {
                /*Spine.Unity.SkeletonExtensions.GetColor$2:static start.*/
                GetColor$2: function (s) {
                    return new pc.Color( s.color.r, s.color.g, s.color.b, s.color.a );
                },
                /*Spine.Unity.SkeletonExtensions.GetColor$2:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetColor$1:static start.*/
                GetColor$1: function (a) {
                    return new pc.Color( a.color.r, a.color.g, a.color.b, a.color.a );
                },
                /*Spine.Unity.SkeletonExtensions.GetColor$1:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetColor:static start.*/
                GetColor: function (a) {
                    return new pc.Color( a.color.r, a.color.g, a.color.b, a.color.a );
                },
                /*Spine.Unity.SkeletonExtensions.GetColor:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetColor$3:static start.*/
                GetColor$3: function (s) {
                    return new pc.Color( s.color.r, s.color.g, s.color.b, s.color.a );
                },
                /*Spine.Unity.SkeletonExtensions.GetColor$3:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetColorTintBlack:static start.*/
                GetColorTintBlack: function (s) {
                    return new pc.Color( s.darkColor.r || 0, s.darkColor.g || 0, s.darkColor.b || 0, 1.0 );
                },
                /*Spine.Unity.SkeletonExtensions.GetColorTintBlack:static end.*/

                /*Spine.Unity.SkeletonExtensions.SetColor$4:static start.*/
                SetColor$4: function (skeleton, color) {
                    skeleton.color.a = color.a;
                    skeleton.color.r = color.r;
                    skeleton.color.g = color.g;
                    skeleton.color.b = color.b;
                },
                /*Spine.Unity.SkeletonExtensions.SetColor$4:static end.*/

                /*Spine.Unity.SkeletonExtensions.SetColor$5:static start.*/
                SetColor$5: function (skeleton, color) {
                    skeleton.color.a = color.a * Spine.Unity.SkeletonExtensions.ByteToFloat;
                    skeleton.color.r = color.r * Spine.Unity.SkeletonExtensions.ByteToFloat;
                    skeleton.color.g = color.g * Spine.Unity.SkeletonExtensions.ByteToFloat;
                    skeleton.color.b = color.b * Spine.Unity.SkeletonExtensions.ByteToFloat;
                },
                /*Spine.Unity.SkeletonExtensions.SetColor$5:static end.*/

                /*Spine.Unity.SkeletonExtensions.SetColor$6:static start.*/
                SetColor$6: function (slot, color) {
                    slot.color.a = color.a;
                    slot.color.r = color.r;
                    slot.color.g = color.g;
                    slot.color.b = color.b;
                },
                /*Spine.Unity.SkeletonExtensions.SetColor$6:static end.*/

                /*Spine.Unity.SkeletonExtensions.SetColor$7:static start.*/
                SetColor$7: function (slot, color) {
                    slot.color.a = color.a * Spine.Unity.SkeletonExtensions.ByteToFloat;
                    slot.color.r = color.r * Spine.Unity.SkeletonExtensions.ByteToFloat;
                    slot.color.g = color.g * Spine.Unity.SkeletonExtensions.ByteToFloat;
                    slot.color.b = color.b * Spine.Unity.SkeletonExtensions.ByteToFloat;
                },
                /*Spine.Unity.SkeletonExtensions.SetColor$7:static end.*/

                /*Spine.Unity.SkeletonExtensions.SetColor$2:static start.*/
                SetColor$2: function (attachment, color) {
                    attachment.color.a = color.a;
                    attachment.color.r = color.r;
                    attachment.color.g = color.g;
                    attachment.color.b = color.b;
                },
                /*Spine.Unity.SkeletonExtensions.SetColor$2:static end.*/

                /*Spine.Unity.SkeletonExtensions.SetColor$3:static start.*/
                SetColor$3: function (attachment, color) {
                    attachment.color.a = color.a * Spine.Unity.SkeletonExtensions.ByteToFloat;
                    attachment.color.r = color.r * Spine.Unity.SkeletonExtensions.ByteToFloat;
                    attachment.color.g = color.g * Spine.Unity.SkeletonExtensions.ByteToFloat;
                    attachment.color.b = color.b * Spine.Unity.SkeletonExtensions.ByteToFloat;
                },
                /*Spine.Unity.SkeletonExtensions.SetColor$3:static end.*/

                /*Spine.Unity.SkeletonExtensions.SetColor:static start.*/
                SetColor: function (attachment, color) {
                    attachment.color.a = color.a;
                    attachment.color.r = color.r;
                    attachment.color.g = color.g;
                    attachment.color.b = color.b;
                },
                /*Spine.Unity.SkeletonExtensions.SetColor:static end.*/

                /*Spine.Unity.SkeletonExtensions.SetColor$1:static start.*/
                SetColor$1: function (attachment, color) {
                    attachment.color.a = color.a * Spine.Unity.SkeletonExtensions.ByteToFloat;
                    attachment.color.r = color.r * Spine.Unity.SkeletonExtensions.ByteToFloat;
                    attachment.color.g = color.g * Spine.Unity.SkeletonExtensions.ByteToFloat;
                    attachment.color.b = color.b * Spine.Unity.SkeletonExtensions.ByteToFloat;
                },
                /*Spine.Unity.SkeletonExtensions.SetColor$1:static end.*/

                /*Spine.Unity.SkeletonExtensions.SetLocalScale:static start.*/
                /**
                 * Sets the Skeleton's local scale using a UnityEngine.Vector2. If only individual components need to be set, set Skeleton.ScaleX or Skeleton.ScaleY.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {Spine.Skeleton}         skeleton    
                 * @param   {UnityEngine.Vector2}    scale
                 * @return  {void}
                 */
                SetLocalScale: function (skeleton, scale) {
                    skeleton.scaleX = scale.x;
                    skeleton.scaleY = scale.y;
                },
                /*Spine.Unity.SkeletonExtensions.SetLocalScale:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetMatrix4x4:static start.*/
                /**
                 * Gets the internal bone matrix as a Unity bonespace-to-skeletonspace transformation matrix.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {Spine.Bone}               bone
                 * @return  {UnityEngine.Matrix4x4}
                 */
                GetMatrix4x4: function (bone) {
                    var $t;
                    return ($t = new pc.Mat4.ctor(), $t.e00 = bone.a, $t.e01 = bone.b, $t.e03 = bone.worldX, $t.e10 = bone.c, $t.e11 = bone.d, $t.e13 = bone.worldY, $t.e33 = 1, $t);
                },
                /*Spine.Unity.SkeletonExtensions.GetMatrix4x4:static end.*/

                /*Spine.Unity.SkeletonExtensions.SetLocalPosition:static start.*/
                /**
                 * Sets the bone's (local) X and Y according to a Vector2
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {Spine.Bone}             bone        
                 * @param   {UnityEngine.Vector2}    position
                 * @return  {void}
                 */
                SetLocalPosition: function (bone, position) {
                    bone.x = position.x;
                    bone.y = position.y;
                },
                /*Spine.Unity.SkeletonExtensions.SetLocalPosition:static end.*/

                /*Spine.Unity.SkeletonExtensions.SetLocalPosition$1:static start.*/
                /**
                 * Sets the bone's (local) X and Y according to a Vector3. The z component is ignored.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {Spine.Bone}             bone        
                 * @param   {UnityEngine.Vector3}    position
                 * @return  {void}
                 */
                SetLocalPosition$1: function (bone, position) {
                    bone.x = position.x;
                    bone.y = position.y;
                },
                /*Spine.Unity.SkeletonExtensions.SetLocalPosition$1:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetLocalPosition:static start.*/
                /**
                 * Gets the bone's local X and Y as a Vector2.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {Spine.Bone}             bone
                 * @return  {UnityEngine.Vector2}
                 */
                GetLocalPosition: function (bone) {
                    return new pc.Vec2( bone.x, bone.y );
                },
                /*Spine.Unity.SkeletonExtensions.GetLocalPosition:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetSkeletonSpacePosition:static start.*/
                /**
                 * Gets the position of the bone in Skeleton-space.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {Spine.Bone}             bone
                 * @return  {UnityEngine.Vector2}
                 */
                GetSkeletonSpacePosition: function (bone) {
                    return new pc.Vec2( bone.worldX, bone.worldY );
                },
                /*Spine.Unity.SkeletonExtensions.GetSkeletonSpacePosition:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetSkeletonSpacePosition$1:static start.*/
                /**
                 * Gets a local offset from the bone and converts it into Skeleton-space.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {Spine.Bone}             bone         
                 * @param   {UnityEngine.Vector2}    boneLocal
                 * @return  {UnityEngine.Vector2}
                 */
                GetSkeletonSpacePosition$1: function (bone, boneLocal) {
                    var o = new UnityEngine.Vector2();
                    bone.LocalToWorld(boneLocal.x, boneLocal.y, Bridge.ref(o, "x"), Bridge.ref(o, "y"));
                    return o.$clone();
                },
                /*Spine.Unity.SkeletonExtensions.GetSkeletonSpacePosition$1:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetWorldPosition:static start.*/
                /**
                 * Gets the bone's Unity World position using its Spine GameObject Transform. UpdateWorldTransform needs to have been called for this to return the correct, updated value.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {Spine.Bone}               bone                        
                 * @param   {UnityEngine.Transform}    spineGameObjectTransform
                 * @return  {UnityEngine.Vector3}
                 */
                GetWorldPosition: function (bone, spineGameObjectTransform) {
                    return spineGameObjectTransform.TransformPoint$1(new pc.Vec3( bone.worldX, bone.worldY, 0 ));
                },
                /*Spine.Unity.SkeletonExtensions.GetWorldPosition:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetWorldPosition$1:static start.*/
                GetWorldPosition$1: function (bone, spineGameObjectTransform, positionScale) {
                    return spineGameObjectTransform.TransformPoint$1(new pc.Vec3( bone.worldX * positionScale, bone.worldY * positionScale, 0 ));
                },
                /*Spine.Unity.SkeletonExtensions.GetWorldPosition$1:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetWorldPosition$3:static start.*/
                /**
                 * Gets the PointAttachment's Unity World position using its Spine GameObject Transform.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {Spine.PointAttachment}    attachment                  
                 * @param   {Spine.Slot}               slot                        
                 * @param   {UnityEngine.Transform}    spineGameObjectTransform
                 * @return  {UnityEngine.Vector3}
                 */
                GetWorldPosition$3: function (attachment, slot, spineGameObjectTransform) {
                    var skeletonSpacePosition = new UnityEngine.Vector3();
                    skeletonSpacePosition.z = 0;
                    attachment.ComputeWorldPosition(slot.bone, Bridge.ref(skeletonSpacePosition, "x"), Bridge.ref(skeletonSpacePosition, "y"));
                    return spineGameObjectTransform.TransformPoint$1(skeletonSpacePosition);
                },
                /*Spine.Unity.SkeletonExtensions.GetWorldPosition$3:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetWorldPosition$2:static start.*/
                /**
                 * Gets the PointAttachment's Unity World position using its Spine GameObject Transform.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {Spine.PointAttachment}    attachment                  
                 * @param   {Spine.Bone}               bone                        
                 * @param   {UnityEngine.Transform}    spineGameObjectTransform
                 * @return  {UnityEngine.Vector3}
                 */
                GetWorldPosition$2: function (attachment, bone, spineGameObjectTransform) {
                    var skeletonSpacePosition = new UnityEngine.Vector3();
                    skeletonSpacePosition.z = 0;
                    attachment.ComputeWorldPosition(bone, Bridge.ref(skeletonSpacePosition, "x"), Bridge.ref(skeletonSpacePosition, "y"));
                    return spineGameObjectTransform.TransformPoint$1(skeletonSpacePosition);
                },
                /*Spine.Unity.SkeletonExtensions.GetWorldPosition$2:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetQuaternion:static start.*/
                /**
                 * Gets a skeleton space UnityEngine.Quaternion representation of bone.WorldRotationX.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {Spine.Bone}                bone
                 * @return  {UnityEngine.Quaternion}
                 */
                GetQuaternion: function (bone) {
                    var halfRotation = Math.atan2(bone.c, bone.a) * 0.5;
                    return new pc.Quat( 0, 0, Math.sin(halfRotation), Math.cos(halfRotation) );
                },
                /*Spine.Unity.SkeletonExtensions.GetQuaternion:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetLocalQuaternion:static start.*/
                /**
                 * Gets a bone-local space UnityEngine.Quaternion representation of bone.rotation.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {Spine.Bone}                bone
                 * @return  {UnityEngine.Quaternion}
                 */
                GetLocalQuaternion: function (bone) {
                    var halfRotation = bone.rotation * UnityEngine.Mathf.Deg2Rad * 0.5;
                    return new pc.Quat( 0, 0, Math.sin(halfRotation), Math.cos(halfRotation) );
                },
                /*Spine.Unity.SkeletonExtensions.GetLocalQuaternion:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetLocalScale:static start.*/
                /**
                 * Returns the Skeleton's local scale as a UnityEngine.Vector2. If only individual components are needed, use Skeleton.ScaleX or Skeleton.ScaleY.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {Spine.Skeleton}         skeleton
                 * @return  {UnityEngine.Vector2}
                 */
                GetLocalScale: function (skeleton) {
                    return new pc.Vec2( skeleton.scaleX, skeleton.scaleY );
                },
                /*Spine.Unity.SkeletonExtensions.GetLocalScale:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetWorldToLocalMatrix:static start.*/
                /**
                 * Calculates a 2x2 Transformation Matrix that can convert a skeleton-space position to a bone-local position.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {Spine.Bone}       bone    
                 * @param   {System.Single}    ia      
                 * @param   {System.Single}    ib      
                 * @param   {System.Single}    ic      
                 * @param   {System.Single}    id
                 * @return  {void}
                 */
                GetWorldToLocalMatrix: function (bone, ia, ib, ic, id) {
                    var a = bone.a, b = bone.b, c = bone.c, d = bone.d;
                    var invDet = 1 / (a * d - b * c);
                    ia.v = invDet * d;
                    ib.v = invDet * -b;
                    ic.v = invDet * -c;
                    id.v = invDet * a;
                },
                /*Spine.Unity.SkeletonExtensions.GetWorldToLocalMatrix:static end.*/

                /*Spine.Unity.SkeletonExtensions.WorldToLocal:static start.*/
                /**
                 * UnityEngine.Vector2 override of Bone.WorldToLocal. This converts a skeleton-space position into a bone local position.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {Spine.Bone}             bone             
                 * @param   {UnityEngine.Vector2}    worldPosition
                 * @return  {UnityEngine.Vector2}
                 */
                WorldToLocal: function (bone, worldPosition) {
                    var o = new UnityEngine.Vector2();
                    bone.WorldToLocal(worldPosition.x, worldPosition.y, Bridge.ref(o, "x"), Bridge.ref(o, "y"));
                    return o.$clone();
                },
                /*Spine.Unity.SkeletonExtensions.WorldToLocal:static end.*/

                /*Spine.Unity.SkeletonExtensions.SetPositionSkeletonSpace:static start.*/
                /**
                 * Sets the skeleton-space position of a bone.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {Spine.Bone}             bone                     
                 * @param   {UnityEngine.Vector2}    skeletonSpacePosition
                 * @return  {UnityEngine.Vector2}                             The local position in its parent bone space, or in skeleton space if it is the root bone.
                 */
                SetPositionSkeletonSpace: function (bone, skeletonSpacePosition) {
                    if (bone.parent == null) { // root bone
                        Spine.Unity.SkeletonExtensions.SetLocalPosition(bone, skeletonSpacePosition.$clone());
                        return skeletonSpacePosition.$clone();
                    } else {
                        var parent = bone.parent;
                        var parentLocal = Spine.Unity.SkeletonExtensions.WorldToLocal(parent, skeletonSpacePosition.$clone());
                        Spine.Unity.SkeletonExtensions.SetLocalPosition(bone, parentLocal.$clone());
                        return parentLocal.$clone();
                    }
                },
                /*Spine.Unity.SkeletonExtensions.SetPositionSkeletonSpace:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetMaterial:static start.*/
                GetMaterial: function (a) {
                    var rendererObject = null;
                    var renderableAttachment = Bridge.as(a, Spine.IHasTextureRegion);
                    if (renderableAttachment != null) {
                        rendererObject = renderableAttachment.Spine$IHasTextureRegion$Region;
                    }

                    if (rendererObject == null) {
                        return null;
                    }

                    return Bridge.cast(Bridge.cast(rendererObject, Spine.AtlasRegion).page.rendererObject, UnityEngine.Material);
                },
                /*Spine.Unity.SkeletonExtensions.GetMaterial:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetLocalVertices:static start.*/
                /**
                 * Fills a Vector2 buffer with local vertices.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {spine.VertexAttachment}         va        The VertexAttachment
                 * @param   {Spine.Slot}                     slot      Slot where the attachment belongs.
                 * @param   {Array.<UnityEngine.Vector2>}    buffer    Correctly-sized buffer. Use attachment's .WorldVerticesLength to get the correct size. If null, a new Vector2[] of the correct size will be allocated.
                 * @return  {Array.<UnityEngine.Vector2>}
                 */
                GetLocalVertices: function (va, slot, buffer) {
                    var floatsCount = va.worldVerticesLength;
                    var bufferTargetSize = floatsCount >> 1;
                    buffer = buffer || System.Array.init(bufferTargetSize, function (){
                        return new UnityEngine.Vector2();
                    }, UnityEngine.Vector2);
                    if (buffer.length < bufferTargetSize) {
                        throw new System.ArgumentException.$ctor3(System.String.format("Vector2 buffer too small. {0} requires an array of size {1}. Use the attachment's .WorldVerticesLength to get the correct size.", va.name, Bridge.box(floatsCount, System.Int32)), "buffer");
                    }

                    if (va.bones == null && slot.Deform.Count === 0) {
                        var localVerts = va.vertices;
                        for (var i = 0; i < bufferTargetSize; i = (i + 1) | 0) {
                            var j = Bridge.Int.mul(i, 2);
                            buffer[i] = new pc.Vec2( localVerts[j], localVerts[((j + 1) | 0)] );
                        }
                    } else {
                        var floats = System.Array.init(floatsCount, 0, System.Single);
                        va.computeWorldVertices( slot, 0, va.worldVerticesLength, floats, 0, 2 );

                        var sb = slot.bone;
                        var ia = { }, ib = { }, ic = { }, id = { }, bwx = sb.worldX, bwy = sb.worldY;
                        Spine.Unity.SkeletonExtensions.GetWorldToLocalMatrix(sb, ia, ib, ic, id);

                        for (var i1 = 0; i1 < bufferTargetSize; i1 = (i1 + 1) | 0) {
                            var j1 = Bridge.Int.mul(i1, 2);
                            var x = floats[j1] - bwx, y = floats[((j1 + 1) | 0)] - bwy;
                            buffer[i1] = new pc.Vec2( x * ia.v + y * ib.v, x * ic.v + y * id.v );
                        }
                    }

                    return buffer;
                },
                /*Spine.Unity.SkeletonExtensions.GetLocalVertices:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetWorldVertices:static start.*/
                /**
                 * Calculates world vertices and fills a Vector2 buffer.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {spine.VertexAttachment}         a         The VertexAttachment
                 * @param   {Spine.Slot}                     slot      Slot where the attachment belongs.
                 * @param   {Array.<UnityEngine.Vector2>}    buffer    Correctly-sized buffer. Use attachment's .WorldVerticesLength to get the correct size. If null, a new Vector2[] of the correct size will be allocated.
                 * @return  {Array.<UnityEngine.Vector2>}
                 */
                GetWorldVertices: function (a, slot, buffer) {
                    var worldVertsLength = a.worldVerticesLength;
                    var bufferTargetSize = worldVertsLength >> 1;
                    buffer = buffer || System.Array.init(bufferTargetSize, function (){
                        return new UnityEngine.Vector2();
                    }, UnityEngine.Vector2);
                    if (buffer.length < bufferTargetSize) {
                        throw new System.ArgumentException.$ctor3(System.String.format("Vector2 buffer too small. {0} requires an array of size {1}. Use the attachment's .WorldVerticesLength to get the correct size.", a.name, Bridge.box(worldVertsLength, System.Int32)), "buffer");
                    }

                    var floats = System.Array.init(worldVertsLength, 0, System.Single);
                    a.computeWorldVertices( slot, 0, a.worldVerticesLength, floats, 0, 2 );

                    for (var i = 0, n = worldVertsLength >> 1; i < n; i = (i + 1) | 0) {
                        var j = Bridge.Int.mul(i, 2);
                        buffer[i] = new pc.Vec2( floats[j], floats[((j + 1) | 0)] );
                    }

                    return buffer;
                },
                /*Spine.Unity.SkeletonExtensions.GetWorldVertices:static end.*/


            }
        }
    });
    /*Spine.Unity.SkeletonExtensions end.*/

    /*Spine.Unity.SkeletonGraphic+LayoutMode start.*/
    Bridge.define("Spine.Unity.SkeletonGraphic.LayoutMode", {
        $kind: 1006,
        statics: {
            fields: {
                None: 0,
                WidthControlsHeight: 1,
                HeightControlsWidth: 2,
                FitInParent: 3,
                EnvelopeParent: 4
            }
        }
    });
    /*Spine.Unity.SkeletonGraphic+LayoutMode end.*/

    /*Spine.Unity.SkeletonGraphicCustomMaterials start.*/
    Bridge.define("Spine.Unity.SkeletonGraphicCustomMaterials", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            skeletonGraphic: null,
            customMaterialOverrides: null,
            customTextureOverrides: null
        },
        ctors: {
            init: function () {
                this.customMaterialOverrides = new (System.Collections.Generic.List$1(Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride)).ctor();
                this.customTextureOverrides = new (System.Collections.Generic.List$1(Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride)).ctor();
            }
        },
        methods: {
            /*Spine.Unity.SkeletonGraphicCustomMaterials.SetCustomMaterialOverrides start.*/
            SetCustomMaterialOverrides: function () {
                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonGraphic, null)) {
                    UnityEngine.Debug.LogError$2("skeletonGraphic == null");
                    return;
                }

                for (var i = 0; i < this.customMaterialOverrides.Count; i = (i + 1) | 0) {
                    var atlasMaterialOverride = this.customMaterialOverrides.getItem(i).$clone();
                    if (atlasMaterialOverride.overrideEnabled) {
                        this.skeletonGraphic.CustomMaterialOverride.setItem(atlasMaterialOverride.originalTexture, atlasMaterialOverride.replacementMaterial);
                    }
                }
            },
            /*Spine.Unity.SkeletonGraphicCustomMaterials.SetCustomMaterialOverrides end.*/

            /*Spine.Unity.SkeletonGraphicCustomMaterials.RemoveCustomMaterialOverrides start.*/
            RemoveCustomMaterialOverrides: function () {
                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonGraphic, null)) {
                    UnityEngine.Debug.LogError$2("skeletonGraphic == null");
                    return;
                }

                for (var i = 0; i < this.customMaterialOverrides.Count; i = (i + 1) | 0) {
                    var atlasMaterialOverride = this.customMaterialOverrides.getItem(i).$clone();
                    var currentMaterial = { };

                    if (!this.skeletonGraphic.CustomMaterialOverride.tryGetValue(atlasMaterialOverride.originalTexture, currentMaterial)) {
                        continue;
                    }

                    // Do not revert the material if it was changed by something else
                    if (!Bridge.referenceEquals(currentMaterial.v, atlasMaterialOverride.replacementMaterial)) {
                        continue;
                    }

                    this.skeletonGraphic.CustomMaterialOverride.remove(atlasMaterialOverride.originalTexture);
                }
            },
            /*Spine.Unity.SkeletonGraphicCustomMaterials.RemoveCustomMaterialOverrides end.*/

            /*Spine.Unity.SkeletonGraphicCustomMaterials.SetCustomTextureOverrides start.*/
            SetCustomTextureOverrides: function () {
                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonGraphic, null)) {
                    UnityEngine.Debug.LogError$2("skeletonGraphic == null");
                    return;
                }

                for (var i = 0; i < this.customTextureOverrides.Count; i = (i + 1) | 0) {
                    var atlasTextureOverride = this.customTextureOverrides.getItem(i).$clone();
                    if (atlasTextureOverride.overrideEnabled) {
                        this.skeletonGraphic.CustomTextureOverride.setItem(atlasTextureOverride.originalTexture, atlasTextureOverride.replacementTexture);
                    }
                }
            },
            /*Spine.Unity.SkeletonGraphicCustomMaterials.SetCustomTextureOverrides end.*/

            /*Spine.Unity.SkeletonGraphicCustomMaterials.RemoveCustomTextureOverrides start.*/
            RemoveCustomTextureOverrides: function () {
                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonGraphic, null)) {
                    UnityEngine.Debug.LogError$2("skeletonGraphic == null");
                    return;
                }

                for (var i = 0; i < this.customTextureOverrides.Count; i = (i + 1) | 0) {
                    var atlasTextureOverride = this.customTextureOverrides.getItem(i).$clone();
                    var currentTexture = { };

                    if (!this.skeletonGraphic.CustomTextureOverride.tryGetValue(atlasTextureOverride.originalTexture, currentTexture)) {
                        continue;
                    }

                    // Do not revert the material if it was changed by something else
                    if (!Bridge.referenceEquals(currentTexture.v, atlasTextureOverride.replacementTexture)) {
                        continue;
                    }

                    this.skeletonGraphic.CustomTextureOverride.remove(atlasTextureOverride.originalTexture);
                }
            },
            /*Spine.Unity.SkeletonGraphicCustomMaterials.RemoveCustomTextureOverrides end.*/

            /*Spine.Unity.SkeletonGraphicCustomMaterials.OnEnable start.*/
            OnEnable: function () {
                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonGraphic, null)) {
                    this.skeletonGraphic = this.GetComponent(Spine.Unity.SkeletonGraphic);
                }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonGraphic, null)) {
                    UnityEngine.Debug.LogError$2("skeletonGraphic == null");
                    return;
                }

                this.skeletonGraphic.Initialize(false);
                this.SetCustomMaterialOverrides();
                this.SetCustomTextureOverrides();
            },
            /*Spine.Unity.SkeletonGraphicCustomMaterials.OnEnable end.*/

            /*Spine.Unity.SkeletonGraphicCustomMaterials.OnDisable start.*/
            OnDisable: function () {
                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonGraphic, null)) {
                    UnityEngine.Debug.LogError$2("skeletonGraphic == null");
                    return;
                }

                this.RemoveCustomMaterialOverrides();
                this.RemoveCustomTextureOverrides();
            },
            /*Spine.Unity.SkeletonGraphicCustomMaterials.OnDisable end.*/


        }
    });
    /*Spine.Unity.SkeletonGraphicCustomMaterials end.*/

    /*Spine.Unity.SkeletonGraphicCustomMaterials+AtlasMaterialOverride start.*/
    Bridge.define("Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride", {
        inherits: function () { return [System.IEquatable$1(Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride)]; },
        $kind: 1004,
        statics: {
            methods: {
                getDefaultValue: function () { return new Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride(); }
            }
        },
        fields: {
            overrideEnabled: false,
            originalTexture: null,
            replacementMaterial: null
        },
        alias: ["equalsT", "System$IEquatable$1$Spine$Unity$SkeletonGraphicCustomMaterials$AtlasMaterialOverride$equalsT"],
        ctors: {
            ctor: function () {
                this.$initialize();
            }
        },
        methods: {
            /*Spine.Unity.SkeletonGraphicCustomMaterials+AtlasMaterialOverride.equalsT start.*/
            equalsT: function (other) {
                return this.overrideEnabled === other.overrideEnabled && Bridge.referenceEquals(this.originalTexture, other.originalTexture) && Bridge.referenceEquals(this.replacementMaterial, other.replacementMaterial);
            },
            /*Spine.Unity.SkeletonGraphicCustomMaterials+AtlasMaterialOverride.equalsT end.*/

            getHashCode: function () {
                var h = Bridge.addHash([8608216668, this.overrideEnabled, this.originalTexture, this.replacementMaterial]);
                return h;
            },
            $clone: function (to) {
                var s = to || new Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride();
                s.overrideEnabled = this.overrideEnabled;
                s.originalTexture = this.originalTexture;
                s.replacementMaterial = this.replacementMaterial;
                return s;
            }
        },
        overloads: {
            "Equals(AtlasMaterialOverride)": "equalsT"
        }
    });
    /*Spine.Unity.SkeletonGraphicCustomMaterials+AtlasMaterialOverride end.*/

    /*Spine.Unity.SkeletonGraphicCustomMaterials+AtlasTextureOverride start.*/
    Bridge.define("Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride", {
        inherits: function () { return [System.IEquatable$1(Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride)]; },
        $kind: 1004,
        statics: {
            methods: {
                getDefaultValue: function () { return new Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride(); }
            }
        },
        fields: {
            overrideEnabled: false,
            originalTexture: null,
            replacementTexture: null
        },
        alias: ["equalsT", "System$IEquatable$1$Spine$Unity$SkeletonGraphicCustomMaterials$AtlasTextureOverride$equalsT"],
        ctors: {
            ctor: function () {
                this.$initialize();
            }
        },
        methods: {
            /*Spine.Unity.SkeletonGraphicCustomMaterials+AtlasTextureOverride.equalsT start.*/
            equalsT: function (other) {
                return this.overrideEnabled === other.overrideEnabled && Bridge.referenceEquals(this.originalTexture, other.originalTexture) && Bridge.referenceEquals(this.replacementTexture, other.replacementTexture);
            },
            /*Spine.Unity.SkeletonGraphicCustomMaterials+AtlasTextureOverride.equalsT end.*/

            getHashCode: function () {
                var h = Bridge.addHash([8976735721, this.overrideEnabled, this.originalTexture, this.replacementTexture]);
                return h;
            },
            $clone: function (to) {
                var s = to || new Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride();
                s.overrideEnabled = this.overrideEnabled;
                s.originalTexture = this.originalTexture;
                s.replacementTexture = this.replacementTexture;
                return s;
            }
        },
        overloads: {
            "Equals(AtlasTextureOverride)": "equalsT"
        }
    });
    /*Spine.Unity.SkeletonGraphicCustomMaterials+AtlasTextureOverride end.*/

    /*Spine.Unity.SkeletonMecanim+MecanimTranslator start.*/
    Bridge.define("Spine.Unity.SkeletonMecanim.MecanimTranslator", {
        $kind: 1002,
        statics: {
            fields: {
                WeightEpsilon: 0
            },
            ctors: {
                init: function () {
                    this.WeightEpsilon = 0.0001;
                }
            },
            methods: {
                /*Spine.Unity.SkeletonMecanim+MecanimTranslator.AnimationTime:static start.*/
                AnimationTime: function (normalizedTime, clipLength, loop, reversed) {
                    var time = Spine.Unity.SkeletonMecanim.MecanimTranslator.ToSpineAnimationTime(normalizedTime, clipLength, loop, reversed);
                    if (loop) {
                        return time;
                    }
                    var EndSnapEpsilon = 0.0333333351; // Workaround for end-duration keys not being applied.
                    return (clipLength - time < EndSnapEpsilon) ? clipLength : time; // return a time snapped to clipLength;
                },
                /*Spine.Unity.SkeletonMecanim+MecanimTranslator.AnimationTime:static end.*/

                /*Spine.Unity.SkeletonMecanim+MecanimTranslator.ToSpineAnimationTime:static start.*/
                ToSpineAnimationTime: function (normalizedTime, clipLength, loop, reversed) {
                    if (reversed) {
                        normalizedTime = (1 - normalizedTime);
                    }
                    if (normalizedTime < 0.0) {
                        normalizedTime = loop ? (normalizedTime % 1.0) + 1.0 : 0.0;
                    }
                    return normalizedTime * clipLength;
                },
                /*Spine.Unity.SkeletonMecanim+MecanimTranslator.ToSpineAnimationTime:static end.*/


            }
        },
        fields: {
            autoReset: false,
            useCustomMixMode: false,
            layerMixModes: null,
            layerBlendModes: null,
            animationTable: null,
            clipNameHashCodeTable: null,
            previousAnimations: null,
            layerClipInfos: null,
            animator: null
        },
        events: {
            _OnClipApplied: null
        },
        props: {
            Animator: {
                get: function () {
                    return this.animator;
                }
            },
            MecanimLayerCount: {
                get: function () {
                    if (!UnityEngine.Object.op_Implicit(this.animator)) {
                        return 0;
                    }
                    return this.animator.layerCount;
                }
            },
            MecanimLayerNames: {
                get: function () {
                    if (!UnityEngine.Object.op_Implicit(this.animator)) {
                        return System.Array.init(0, null, System.String);
                    }
                    var layerNames = System.Array.init(this.animator.layerCount, null, System.String);
                    for (var i = 0; i < this.animator.layerCount; i = (i + 1) | 0) {
                        layerNames[i] = this.animator.GetLayerName(i);
                    }
                    return layerNames;
                }
            }
        },
        ctors: {
            init: function () {
                this.autoReset = true;
                this.useCustomMixMode = true;
                this.layerMixModes = System.Array.init(0, 0, Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode);
                this.layerBlendModes = System.Array.init(0, 0, spine.MixBlend);
                this.animationTable = new (System.Collections.Generic.Dictionary$2(System.Int32,Spine.Animation)).$ctor3(Spine.Unity.SkeletonMecanim.MecanimTranslator.IntEqualityComparer.Instance);
                this.clipNameHashCodeTable = new (System.Collections.Generic.Dictionary$2(UnityEngine.AnimationClip,System.Int32)).$ctor3(Spine.Unity.SkeletonMecanim.MecanimTranslator.AnimationClipEqualityComparer.Instance);
                this.previousAnimations = new (System.Collections.Generic.List$1(Spine.Animation)).ctor();
                this.layerClipInfos = System.Array.init(0, null, Spine.Unity.SkeletonMecanim.MecanimTranslator.ClipInfos);
            }
        },
        methods: {
            addOnClipApplied: function (value) {
                this.add_OnClipApplied(value);
            },
            removeOnClipApplied: function (value) {
                this.remove_OnClipApplied(value);
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.Initialize start.*/
            Initialize: function (animator, skeletonDataAsset) {
                var $t;
                this.animator = animator;

                this.previousAnimations.clear();

                this.animationTable.clear();
                var data = skeletonDataAsset.GetSkeletonData(true);
                $t = Bridge.getEnumerator(data.Animations);
                try {
                    while ($t.moveNext()) {
                        var a = $t.Current;
                        this.animationTable.add(Bridge.getHashCode(a.name), a);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }

                this.clipNameHashCodeTable.clear();
                this.ClearClipInfosForLayers();
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.Initialize end.*/

            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.ApplyAnimation start.*/
            ApplyAnimation: function (skeleton, info, stateInfo, layerIndex, layerWeight, layerBlendMode, useClipWeight1) {
                if (useClipWeight1 === void 0) { useClipWeight1 = false; }
                var weight = info.weight * layerWeight;
                if (weight < Spine.Unity.SkeletonMecanim.MecanimTranslator.WeightEpsilon) {
                    return false;
                }

                var clip = this.GetAnimation(info.clip);
                if (clip == null) {
                    return false;
                }
                var time = Spine.Unity.SkeletonMecanim.MecanimTranslator.AnimationTime(stateInfo.normalizedTime, info.clip.length, info.clip.isLooping, stateInfo.speed < 0);
                weight = useClipWeight1 ? layerWeight : weight;
                clip.apply(skeleton, 0, time, info.clip.isLooping, null, weight, layerBlendMode, spine.MixDirection.mixIn);
                if (!Bridge.staticEquals(this._OnClipApplied, null)) {
                    this.OnClipAppliedCallback(clip, stateInfo, layerIndex, time, info.clip.isLooping, weight);
                }
                return true;
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.ApplyAnimation end.*/

            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.ApplyInterruptionAnimation start.*/
            ApplyInterruptionAnimation: function (skeleton, interpolateWeightTo1, info, stateInfo, layerIndex, layerWeight, layerBlendMode, interruptingClipTimeAddition, useClipWeight1) {
                if (useClipWeight1 === void 0) { useClipWeight1 = false; }

                var clipWeight = interpolateWeightTo1 ? (info.weight + 1.0) * 0.5 : info.weight;
                var weight = clipWeight * layerWeight;
                if (weight < Spine.Unity.SkeletonMecanim.MecanimTranslator.WeightEpsilon) {
                    return false;
                }

                var clip = this.GetAnimation(info.clip);
                if (clip == null) {
                    return false;
                }

                var time = Spine.Unity.SkeletonMecanim.MecanimTranslator.AnimationTime(stateInfo.normalizedTime + interruptingClipTimeAddition, info.clip.length, info.clip.isLooping, stateInfo.speed < 0);
                weight = useClipWeight1 ? layerWeight : weight;
                clip.apply(skeleton, 0, time, info.clip.isLooping, null, weight, layerBlendMode, spine.MixDirection.mixIn);
                if (!Bridge.staticEquals(this._OnClipApplied, null)) {
                    this.OnClipAppliedCallback(clip, stateInfo, layerIndex, time, info.clip.isLooping, weight);
                }
                return true;
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.ApplyInterruptionAnimation end.*/

            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.OnClipAppliedCallback start.*/
            OnClipAppliedCallback: function (clip, stateInfo, layerIndex, time, isLooping, weight) {

                var speedFactor = stateInfo.speedMultiplier * stateInfo.speed;
                var lastTime = time - (UnityEngine.Time.deltaTime * speedFactor);
                var clipDuration = clip.duration;
                if (isLooping && clipDuration !== 0) {
                    time %= clipDuration;
                    lastTime %= clipDuration;
                }
                this._OnClipApplied(clip, layerIndex, weight, time, lastTime, speedFactor < 0);
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.OnClipAppliedCallback end.*/

            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.Apply start.*/
            Apply: function (skeleton) {

                if (this.layerMixModes.length < this.animator.layerCount) {
                    var oldSize = this.layerMixModes.length;
                    System.Array.resize(Bridge.ref(this, "layerMixModes"), this.animator.layerCount, 0, Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode);
                    for (var layer = oldSize; layer < this.animator.layerCount; layer = (layer + 1) | 0) {
                        var isAdditiveLayer = false;
                        if (layer < this.layerBlendModes.length) {
                            isAdditiveLayer = this.layerBlendModes[layer] === spine.MixBlend.add;
                        }
                        this.layerMixModes[layer] = isAdditiveLayer ? Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode.AlwaysMix : Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode.MixNext;
                    }
                }

                this.InitClipInfosForLayers();
                for (var layer1 = 0, n = this.animator.layerCount; layer1 < n; layer1 = (layer1 + 1) | 0) {
                    this.GetStateUpdatesFromAnimator(layer1);
                }

                // Clear Previous
                if (this.autoReset) {
                    var previousAnimations = this.previousAnimations;
                    for (var i = 0, n1 = previousAnimations.Count; i < n1; i = (i + 1) | 0) {
                        previousAnimations.getItem(i).apply(skeleton, 0, 0, false, null, 0, spine.MixBlend.setup, spine.MixDirection.mixOut);
                    } // SetKeyedItemsToSetupPose

                    previousAnimations.clear();
                    for (var layer2 = 0, n2 = this.animator.layerCount; layer2 < n2; layer2 = (layer2 + 1) | 0) {
                        var layerWeight = (layer2 === 0) ? 1 : this.animator.GetLayerWeight(layer2); // Animator.GetLayerWeight always returns 0 on the first layer. Should be interpreted as 1.
                        if (layerWeight <= 0) {
                            continue;
                        }

                        var nextStateInfo = this.animator.GetNextAnimatorStateInfo(layer2);

                        var hasNext = nextStateInfo.fullPathHash !== 0;

                        var clipInfoCount = { }, nextClipInfoCount = { }, interruptingClipInfoCount = { };
                        var clipInfo = { }, nextClipInfo = { }, interruptingClipInfo = { };
                        var isInterruptionActive = { }, shallInterpolateWeightTo1 = { };
                        this.GetAnimatorClipInfos(layer2, isInterruptionActive, clipInfoCount, nextClipInfoCount, interruptingClipInfoCount, clipInfo, nextClipInfo, interruptingClipInfo, shallInterpolateWeightTo1);

                        for (var c = 0; c < clipInfoCount.v; c = (c + 1) | 0) {
                            var info = System.Array.getItem(clipInfo.v, c, UnityEngine.AnimatorClipInfo).$clone();
                            var weight = info.weight * layerWeight;
                            if (weight < Spine.Unity.SkeletonMecanim.MecanimTranslator.WeightEpsilon) {
                                continue;
                            }
                            var clip = this.GetAnimation(info.clip);
                            if (clip != null) {
                                previousAnimations.add(clip);
                            }
                        }

                        if (hasNext) {
                            for (var c1 = 0; c1 < nextClipInfoCount.v; c1 = (c1 + 1) | 0) {
                                var info1 = System.Array.getItem(nextClipInfo.v, c1, UnityEngine.AnimatorClipInfo).$clone();
                                var weight1 = info1.weight * layerWeight;
                                if (weight1 < Spine.Unity.SkeletonMecanim.MecanimTranslator.WeightEpsilon) {
                                    continue;
                                }
                                var clip1 = this.GetAnimation(info1.clip);
                                if (clip1 != null) {
                                    previousAnimations.add(clip1);
                                }
                            }
                        }

                        if (isInterruptionActive.v) {
                            for (var c2 = 0; c2 < interruptingClipInfoCount.v; c2 = (c2 + 1) | 0) {
                                var info2 = System.Array.getItem(interruptingClipInfo.v, c2, UnityEngine.AnimatorClipInfo).$clone();
                                var clipWeight = shallInterpolateWeightTo1.v ? (info2.weight + 1.0) * 0.5 : info2.weight;
                                var weight2 = clipWeight * layerWeight;
                                if (weight2 < Spine.Unity.SkeletonMecanim.MecanimTranslator.WeightEpsilon) {
                                    continue;
                                }
                                var clip2 = this.GetAnimation(info2.clip);
                                if (clip2 != null) {
                                    previousAnimations.add(clip2);
                                }
                            }
                        }
                    }
                }

                // Apply
                for (var layer3 = 0, n3 = this.animator.layerCount; layer3 < n3; layer3 = (layer3 + 1) | 0) {
                    var layerWeight1 = (layer3 === 0) ? 1 : this.animator.GetLayerWeight(layer3); // Animator.GetLayerWeight always returns 0 on the first layer. Should be interpreted as 1.

                    var isInterruptionActive1 = { };
                    var stateInfo = { };
                    var nextStateInfo1 = { };
                    var interruptingStateInfo = { };
                    var interruptingClipTimeAddition = { };
                    this.GetAnimatorStateInfos(layer3, isInterruptionActive1, stateInfo, nextStateInfo1, interruptingStateInfo, interruptingClipTimeAddition);

                    var hasNext1 = nextStateInfo1.v.fullPathHash !== 0;

                    var clipInfoCount1 = { }, nextClipInfoCount1 = { }, interruptingClipInfoCount1 = { };
                    var clipInfo1 = { }, nextClipInfo1 = { }, interruptingClipInfo1 = { };
                    var interpolateWeightTo1 = { };
                    this.GetAnimatorClipInfos(layer3, isInterruptionActive1, clipInfoCount1, nextClipInfoCount1, interruptingClipInfoCount1, clipInfo1, nextClipInfo1, interruptingClipInfo1, interpolateWeightTo1);

                    var layerBlendMode = (layer3 < this.layerBlendModes.length) ? this.layerBlendModes[layer3] : spine.MixBlend.replace;
                    var mode = this.GetMixMode(layer3, layerBlendMode);
                    if (mode === Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode.AlwaysMix) {
                        // Always use Mix instead of Applying the first non-zero weighted clip.
                        for (var c3 = 0; c3 < clipInfoCount1.v; c3 = (c3 + 1) | 0) {
                            this.ApplyAnimation(skeleton, System.Array.getItem(clipInfo1.v, c3, UnityEngine.AnimatorClipInfo).$clone(), stateInfo.v, layer3, layerWeight1, layerBlendMode);
                        }
                        if (hasNext1) {
                            for (var c4 = 0; c4 < nextClipInfoCount1.v; c4 = (c4 + 1) | 0) {
                                this.ApplyAnimation(skeleton, System.Array.getItem(nextClipInfo1.v, c4, UnityEngine.AnimatorClipInfo).$clone(), nextStateInfo1.v, layer3, layerWeight1, layerBlendMode);
                            }
                        }
                        if (isInterruptionActive1.v) {
                            for (var c5 = 0; c5 < interruptingClipInfoCount1.v; c5 = (c5 + 1) | 0) {
                                this.ApplyInterruptionAnimation(skeleton, interpolateWeightTo1.v, System.Array.getItem(interruptingClipInfo1.v, c5, UnityEngine.AnimatorClipInfo).$clone(), interruptingStateInfo.v, layer3, layerWeight1, layerBlendMode, interruptingClipTimeAddition.v);
                            }
                        }
                    } else { // case MixNext || Hard
                        // Apply first non-zero weighted clip
                        var c6 = 0;
                        for (; c6 < clipInfoCount1.v; c6 = (c6 + 1) | 0) {
                            if (!this.ApplyAnimation(skeleton, System.Array.getItem(clipInfo1.v, c6, UnityEngine.AnimatorClipInfo).$clone(), stateInfo.v, layer3, layerWeight1, layerBlendMode, true)) {
                                continue;
                            }
                            c6 = (c6 + 1) | 0;
                            break;
                        }
                        // Mix the rest
                        for (; c6 < clipInfoCount1.v; c6 = (c6 + 1) | 0) {
                            this.ApplyAnimation(skeleton, System.Array.getItem(clipInfo1.v, c6, UnityEngine.AnimatorClipInfo).$clone(), stateInfo.v, layer3, layerWeight1, layerBlendMode);
                        }

                        c6 = 0;
                        if (hasNext1) {
                            // Apply next clip directly instead of mixing (ie: no crossfade, ignores mecanim transition weights)
                            if (mode === Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode.Hard) {
                                for (; c6 < nextClipInfoCount1.v; c6 = (c6 + 1) | 0) {
                                    if (!this.ApplyAnimation(skeleton, System.Array.getItem(nextClipInfo1.v, c6, UnityEngine.AnimatorClipInfo).$clone(), nextStateInfo1.v, layer3, layerWeight1, layerBlendMode, true)) {
                                        continue;
                                    }
                                    c6 = (c6 + 1) | 0;
                                    break;
                                }
                            }
                            // Mix the rest
                            for (; c6 < nextClipInfoCount1.v; c6 = (c6 + 1) | 0) {
                                if (!this.ApplyAnimation(skeleton, System.Array.getItem(nextClipInfo1.v, c6, UnityEngine.AnimatorClipInfo).$clone(), nextStateInfo1.v, layer3, layerWeight1, layerBlendMode)) {
                                    continue;
                                }
                            }
                        }

                        c6 = 0;
                        if (isInterruptionActive1.v) {
                            // Apply next clip directly instead of mixing (ie: no crossfade, ignores mecanim transition weights)
                            if (mode === Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode.Hard) {
                                for (; c6 < interruptingClipInfoCount1.v; c6 = (c6 + 1) | 0) {
                                    if (this.ApplyInterruptionAnimation(skeleton, interpolateWeightTo1.v, System.Array.getItem(interruptingClipInfo1.v, c6, UnityEngine.AnimatorClipInfo).$clone(), interruptingStateInfo.v, layer3, layerWeight1, layerBlendMode, interruptingClipTimeAddition.v, true)) {

                                        c6 = (c6 + 1) | 0;
                                        break;
                                    }
                                }
                            }
                            // Mix the rest
                            for (; c6 < interruptingClipInfoCount1.v; c6 = (c6 + 1) | 0) {
                                this.ApplyInterruptionAnimation(skeleton, interpolateWeightTo1.v, System.Array.getItem(interruptingClipInfo1.v, c6, UnityEngine.AnimatorClipInfo).$clone(), interruptingStateInfo.v, layer3, layerWeight1, layerBlendMode, interruptingClipTimeAddition.v);
                            }
                        }
                    }
                }
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.Apply end.*/

            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.GetActiveAnimationAndTime start.*/
            GetActiveAnimationAndTime: function (layer) {
                if (layer >= this.layerClipInfos.length) {
                    return new (System.Collections.Generic.KeyValuePair$2(Spine.Animation,System.Single)).$ctor1(null, 0);
                }

                var layerInfos = this.layerClipInfos[layer];
                var isInterruptionActive = layerInfos.isInterruptionActive;
                var clip = null;
                var animation = null;
                var stateInfo;
                if (isInterruptionActive && layerInfos.interruptingClipInfoCount > 0) {
                    clip = layerInfos.interruptingClipInfos.getItem(0).$clone().clip;
                    stateInfo = layerInfos.interruptingStateInfo;
                } else {
                    clip = layerInfos.clipInfos.getItem(0).$clone().clip;
                    stateInfo = layerInfos.stateInfo;
                }
                animation = this.GetAnimation(clip);
                var time = Spine.Unity.SkeletonMecanim.MecanimTranslator.AnimationTime(stateInfo.normalizedTime, clip.length, clip.isLooping, stateInfo.speed < 0);
                return new (System.Collections.Generic.KeyValuePair$2(Spine.Animation,System.Single)).$ctor1(animation, time);
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.GetActiveAnimationAndTime end.*/

            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.InitClipInfosForLayers start.*/
            InitClipInfosForLayers: function () {
                if (this.layerClipInfos.length < this.animator.layerCount) {
                    System.Array.resize(Bridge.ref(this, "layerClipInfos"), this.animator.layerCount, null, Spine.Unity.SkeletonMecanim.MecanimTranslator.ClipInfos);
                    for (var layer = 0, n = this.animator.layerCount; layer < n; layer = (layer + 1) | 0) {
                        if (this.layerClipInfos[layer] == null) {
                            this.layerClipInfos[layer] = new Spine.Unity.SkeletonMecanim.MecanimTranslator.ClipInfos();
                        }
                    }
                }
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.InitClipInfosForLayers end.*/

            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.ClearClipInfosForLayers start.*/
            ClearClipInfosForLayers: function () {
                for (var layer = 0, n = this.layerClipInfos.length; layer < n; layer = (layer + 1) | 0) {
                    if (this.layerClipInfos[layer] == null) {
                        this.layerClipInfos[layer] = new Spine.Unity.SkeletonMecanim.MecanimTranslator.ClipInfos();
                    } else {
                        this.layerClipInfos[layer].isInterruptionActive = false;
                        this.layerClipInfos[layer].isLastFrameOfInterruption = false;
                        this.layerClipInfos[layer].clipInfos.clear();
                        this.layerClipInfos[layer].nextClipInfos.clear();
                        this.layerClipInfos[layer].interruptingClipInfos.clear();
                    }
                }
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.ClearClipInfosForLayers end.*/

            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.GetMixMode start.*/
            GetMixMode: function (layer, layerBlendMode) {
                if (this.useCustomMixMode) {
                    var mode = this.layerMixModes[layer];
                    // Note: at additive blending it makes no sense to use constant weight 1 at a fadeout anim add1 as
                    // with override layers, so we use AlwaysMix instead to use the proper weights.
                    // AlwaysMix leads to the expected result = lower_layer + lerp(add1, add2, transition_weight).
                    if (layerBlendMode === spine.MixBlend.add && mode === Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode.MixNext) {
                        mode = Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode.AlwaysMix;
                        this.layerMixModes[layer] = mode;
                    }
                    return mode;
                } else {
                    return layerBlendMode === spine.MixBlend.add ? Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode.AlwaysMix : Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode.MixNext;
                }
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.GetMixMode end.*/

            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.GetStateUpdatesFromAnimator start.*/
            GetStateUpdatesFromAnimator: function (layer) {

                var layerInfos = this.layerClipInfos[layer];
                var clipInfoCount = this.animator.GetCurrentAnimatorClipInfoCount(layer);
                var nextClipInfoCount = this.animator.GetNextAnimatorClipInfoCount(layer);

                var clipInfos = layerInfos.clipInfos;
                var nextClipInfos = layerInfos.nextClipInfos;
                var interruptingClipInfos = layerInfos.interruptingClipInfos;

                layerInfos.isInterruptionActive = (clipInfoCount === 0 && clipInfos.Count !== 0 && nextClipInfoCount === 0 && nextClipInfos.Count !== 0);

                // Note: during interruption, GetCurrentAnimatorClipInfoCount and GetNextAnimatorClipInfoCount
                // are returning 0 in calls above. Therefore we keep previous clipInfos and nextClipInfos
                // until the interruption is over.
                if (layerInfos.isInterruptionActive) {

                    // Note: The last frame of a transition interruption
                    // will have fullPathHash set to 0, therefore we have to use previous
                    // frame's infos about interruption clips and correct some values
                    // accordingly (normalizedTime and weight).
                    var interruptingStateInfo = this.animator.GetNextAnimatorStateInfo(layer);
                    layerInfos.isLastFrameOfInterruption = interruptingStateInfo.fullPathHash === 0;
                    if (!layerInfos.isLastFrameOfInterruption) {
                        this.animator.GetNextAnimatorClipInfo(layer, interruptingClipInfos);
                        layerInfos.interruptingClipInfoCount = interruptingClipInfos.Count;
                        var oldTime = layerInfos.interruptingStateInfo.normalizedTime;
                        var newTime = interruptingStateInfo.normalizedTime;
                        layerInfos.interruptingClipTimeAddition = newTime - oldTime;
                        layerInfos.interruptingStateInfo = interruptingStateInfo;
                    }
                } else {
                    layerInfos.clipInfoCount = clipInfoCount;
                    layerInfos.nextClipInfoCount = nextClipInfoCount;
                    layerInfos.interruptingClipInfoCount = 0;
                    layerInfos.isLastFrameOfInterruption = false;

                    if (clipInfos.Capacity < clipInfoCount) {
                        clipInfos.Capacity = clipInfoCount;
                    }
                    if (nextClipInfos.Capacity < nextClipInfoCount) {
                        nextClipInfos.Capacity = nextClipInfoCount;
                    }

                    this.animator.GetCurrentAnimatorClipInfo(layer, clipInfos);
                    this.animator.GetNextAnimatorClipInfo(layer, nextClipInfos);

                    layerInfos.stateInfo = this.animator.GetCurrentAnimatorStateInfo(layer);
                    layerInfos.nextStateInfo = this.animator.GetNextAnimatorStateInfo(layer);
                }
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.GetStateUpdatesFromAnimator end.*/

            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.GetAnimatorClipInfos start.*/
            GetAnimatorClipInfos: function (layer, isInterruptionActive, clipInfoCount, nextClipInfoCount, interruptingClipInfoCount, clipInfo, nextClipInfo, interruptingClipInfo, shallInterpolateWeightTo1) {

                var layerInfos = this.layerClipInfos[layer];
                isInterruptionActive.v = layerInfos.isInterruptionActive;

                clipInfoCount.v = layerInfos.clipInfoCount;
                nextClipInfoCount.v = layerInfos.nextClipInfoCount;
                interruptingClipInfoCount.v = layerInfos.interruptingClipInfoCount;

                clipInfo.v = layerInfos.clipInfos;
                nextClipInfo.v = layerInfos.nextClipInfos;
                interruptingClipInfo.v = isInterruptionActive.v ? layerInfos.interruptingClipInfos : null;
                shallInterpolateWeightTo1.v = layerInfos.isLastFrameOfInterruption;
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.GetAnimatorClipInfos end.*/

            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.GetAnimatorStateInfos start.*/
            GetAnimatorStateInfos: function (layer, isInterruptionActive, stateInfo, nextStateInfo, interruptingStateInfo, interruptingClipTimeAddition) {

                var layerInfos = this.layerClipInfos[layer];
                isInterruptionActive.v = layerInfos.isInterruptionActive;

                stateInfo.v = layerInfos.stateInfo;
                nextStateInfo.v = layerInfos.nextStateInfo;
                interruptingStateInfo.v = layerInfos.interruptingStateInfo;
                interruptingClipTimeAddition.v = layerInfos.isLastFrameOfInterruption ? layerInfos.interruptingClipTimeAddition : 0;
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.GetAnimatorStateInfos end.*/

            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.GetAnimation start.*/
            GetAnimation: function (clip) {
                var clipNameHashCode = { };
                if (!this.clipNameHashCodeTable.tryGetValue(clip, clipNameHashCode)) {
                    clipNameHashCode.v = Bridge.getHashCode(clip.name);
                    this.clipNameHashCodeTable.add(clip, clipNameHashCode.v);
                }
                var animation = { };
                this.animationTable.tryGetValue(clipNameHashCode.v, animation);
                return animation.v;
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.GetAnimation end.*/


        }
    });
    /*Spine.Unity.SkeletonMecanim+MecanimTranslator end.*/

    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+AnimationClipEqualityComparer start.*/
    Bridge.define("Spine.Unity.SkeletonMecanim.MecanimTranslator.AnimationClipEqualityComparer", {
        inherits: [System.Collections.Generic.IEqualityComparer$1(UnityEngine.AnimationClip)],
        $kind: 1002,
        statics: {
            fields: {
                Instance: null
            },
            ctors: {
                init: function () {
                    this.Instance = new Spine.Unity.SkeletonMecanim.MecanimTranslator.AnimationClipEqualityComparer();
                }
            }
        },
        alias: [
            "equals2", ["System$Collections$Generic$IEqualityComparer$1$UnityEngine$AnimationClip$equals2", "System$Collections$Generic$IEqualityComparer$1$equals2"],
            "getHashCode2", ["System$Collections$Generic$IEqualityComparer$1$UnityEngine$AnimationClip$getHashCode2", "System$Collections$Generic$IEqualityComparer$1$getHashCode2"]
        ],
        methods: {
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator+AnimationClipEqualityComparer.equals2 start.*/
            equals2: function (x, y) {
                return x.GetInstanceID() === y.GetInstanceID();
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator+AnimationClipEqualityComparer.equals2 end.*/

            /*Spine.Unity.SkeletonMecanim+MecanimTranslator+AnimationClipEqualityComparer.getHashCode2 start.*/
            getHashCode2: function (o) {
                return o.GetInstanceID();
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator+AnimationClipEqualityComparer.getHashCode2 end.*/


        },
        overloads: {
            "Equals(AnimationClip, AnimationClip)": "equals2",
            "GetHashCode(AnimationClip)": "getHashCode2"
        }
    });
    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+AnimationClipEqualityComparer end.*/

    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+ClipInfos start.*/
    Bridge.define("Spine.Unity.SkeletonMecanim.MecanimTranslator.ClipInfos", {
        $kind: 1002,
        fields: {
            isInterruptionActive: false,
            isLastFrameOfInterruption: false,
            clipInfoCount: 0,
            nextClipInfoCount: 0,
            interruptingClipInfoCount: 0,
            clipInfos: null,
            nextClipInfos: null,
            interruptingClipInfos: null,
            stateInfo: null,
            nextStateInfo: null,
            interruptingStateInfo: null,
            interruptingClipTimeAddition: 0
        },
        ctors: {
            init: function () {
                this.isInterruptionActive = false;
                this.isLastFrameOfInterruption = false;
                this.clipInfoCount = 0;
                this.nextClipInfoCount = 0;
                this.interruptingClipInfoCount = 0;
                this.clipInfos = new (System.Collections.Generic.List$1(UnityEngine.AnimatorClipInfo)).ctor();
                this.nextClipInfos = new (System.Collections.Generic.List$1(UnityEngine.AnimatorClipInfo)).ctor();
                this.interruptingClipInfos = new (System.Collections.Generic.List$1(UnityEngine.AnimatorClipInfo)).ctor();
                this.interruptingClipTimeAddition = 0;
            }
        }
    });
    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+ClipInfos end.*/

    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+IntEqualityComparer start.*/
    Bridge.define("Spine.Unity.SkeletonMecanim.MecanimTranslator.IntEqualityComparer", {
        inherits: [System.Collections.Generic.IEqualityComparer$1(System.Int32)],
        $kind: 1002,
        statics: {
            fields: {
                Instance: null
            },
            ctors: {
                init: function () {
                    this.Instance = new Spine.Unity.SkeletonMecanim.MecanimTranslator.IntEqualityComparer();
                }
            }
        },
        alias: [
            "equals2", ["System$Collections$Generic$IEqualityComparer$1$System$Int32$equals2", "System$Collections$Generic$IEqualityComparer$1$equals2"],
            "getHashCode2", ["System$Collections$Generic$IEqualityComparer$1$System$Int32$getHashCode2", "System$Collections$Generic$IEqualityComparer$1$getHashCode2"]
        ],
        methods: {
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator+IntEqualityComparer.equals2 start.*/
            equals2: function (x, y) {
                return x === y;
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator+IntEqualityComparer.equals2 end.*/

            /*Spine.Unity.SkeletonMecanim+MecanimTranslator+IntEqualityComparer.getHashCode2 start.*/
            getHashCode2: function (o) {
                return o;
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator+IntEqualityComparer.getHashCode2 end.*/


        },
        overloads: {
            "Equals(int, int)": "equals2",
            "GetHashCode(int)": "getHashCode2"
        }
    });
    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+IntEqualityComparer end.*/

    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+MixMode start.*/
    Bridge.define("Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode", {
        $kind: 1006,
        statics: {
            fields: {
                AlwaysMix: 0,
                MixNext: 1,
                Hard: 2
            }
        }
    });
    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+MixMode end.*/
    /**
     * @memberof Spine.Unity
     * @callback Spine.Unity.SkeletonRootMotionBase.RootMotionDelegate
     * @param   {Spine.Unity.SkeletonRootMotionBase}    component      
     * @param   {UnityEngine.Vector2}                   translation    
     * @param   {number}                                rotation
     * @return  {void}
     */


    /*Spine.Unity.SkeletonRootMotionBase start.*/
    /**
     * Base class for skeleton root motion components.
     *
     * @abstract
     * @public
     * @class Spine.Unity.SkeletonRootMotionBase
     * @augments UnityEngine.MonoBehaviour
     */
    Bridge.define("Spine.Unity.SkeletonRootMotionBase", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            rootMotionBoneName: null,
            transformPositionX: false,
            transformPositionY: false,
            transformRotation: false,
            rootMotionScaleX: 0,
            rootMotionScaleY: 0,
            rootMotionScaleRotation: 0,
            /**
             * Skeleton space X translation per skeleton space Y translation root motion.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRootMotionBase
             * @default 0
             * @type number
             */
            rootMotionTranslateXPerY: 0,
            /**
             * Skeleton space Y translation per skeleton space X translation root motion.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRootMotionBase
             * @default 0
             * @type number
             */
            rootMotionTranslateYPerX: 0,
            rigidBody2D: null,
            applyRigidbody2DGravity: false,
            rigidBody: null,
            /**
             * When true, root-motion is not applied to the Transform or Rigidbody.
             Otherwise the delegate callbacks are issued additionally.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRootMotionBase
             * @default true
             * @type boolean
             */
            disableOnOverride: false,
            skeletonComponent: null,
            rootMotionBone: null,
            rootMotionBoneIndex: 0,
            transformConstraintIndices: null,
            transformConstraintLastPos: null,
            transformConstraintLastRotation: null,
            topLevelBones: null,
            initialOffset: null,
            accumulatedUntilFixedUpdate: false,
            tempSkeletonDisplacement: null,
            rigidbodyDisplacement: null,
            previousRigidbodyRootMotion: null,
            additionalRigidbody2DMovement: null,
            rigidbodyLocalRotation: null,
            rigidbody2DRotation: 0,
            initialOffsetRotation: 0,
            tempSkeletonRotation: 0
        },
        events: {
            /**
             * This callback can be used to apply root-motion in a custom way. It is raised after evaluating
             this animation frame's root-motion, before it is potentially applied (see {@link })
             to either Transform or Rigidbody.
             When {@link } is set to {@link }, multiple
             animation frames might take place before <pre><code>FixedUpdate</code></pre> is called once.
             The callback parameters <pre><code>translation</code></pre> and <pre><code>rotation</code></pre> are filled out with
             this animation frame's skeleton-space root-motion (not cumulated). You can use
             e.g. <pre><code>transform.TransformVector()</code></pre> to transform skeleton-space root-motion to world space.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonRootMotionBase
             * @memberof Spine.Unity.SkeletonRootMotionBase
             * @function addProcessRootMotionOverride
             * @param   {Spine.Unity.SkeletonRootMotionBase.RootMotionDelegate}    value
             * @return  {void}
             * @see {@link PhysicsUpdateRootMotionOverride}
             */
            /**
             * This callback can be used to apply root-motion in a custom way. It is raised after evaluating
             this animation frame's root-motion, before it is potentially applied (see {@link })
             to either Transform or Rigidbody.
             When {@link } is set to {@link }, multiple
             animation frames might take place before <pre><code>FixedUpdate</code></pre> is called once.
             The callback parameters <pre><code>translation</code></pre> and <pre><code>rotation</code></pre> are filled out with
             this animation frame's skeleton-space root-motion (not cumulated). You can use
             e.g. <pre><code>transform.TransformVector()</code></pre> to transform skeleton-space root-motion to world space.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonRootMotionBase
             * @memberof Spine.Unity.SkeletonRootMotionBase
             * @function removeProcessRootMotionOverride
             * @param   {Spine.Unity.SkeletonRootMotionBase.RootMotionDelegate}    value
             * @return  {void}
             * @see {@link PhysicsUpdateRootMotionOverride}
             */
            ProcessRootMotionOverride: null,
            /**
             * This callback can be used to apply root-motion in a custom way. It is raised in FixedUpdate
             after (when {@link } is set to false) or instead of when root-motion
             would be applied at the Rigidbody.
             When {@link } is set to {@link }, multiple
             animation frames might take place before before <pre><code>FixedUpdate</code></pre> is called once.
             The callback parameters <pre><code>translation</code></pre> and <pre><code>rotation</code></pre> are filled out with the
             (cumulated) skeleton-space root-motion since the the last <pre><code>FixedUpdate</code></pre> call. You can use
             e.g. <pre><code>transform.TransformVector()</code></pre> to transform skeleton-space root-motion to world space.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonRootMotionBase
             * @memberof Spine.Unity.SkeletonRootMotionBase
             * @function addPhysicsUpdateRootMotionOverride
             * @param   {Spine.Unity.SkeletonRootMotionBase.RootMotionDelegate}    value
             * @return  {void}
             * @see {@link ProcessRootMotionOverride}
             */
            /**
             * This callback can be used to apply root-motion in a custom way. It is raised in FixedUpdate
             after (when {@link } is set to false) or instead of when root-motion
             would be applied at the Rigidbody.
             When {@link } is set to {@link }, multiple
             animation frames might take place before before <pre><code>FixedUpdate</code></pre> is called once.
             The callback parameters <pre><code>translation</code></pre> and <pre><code>rotation</code></pre> are filled out with the
             (cumulated) skeleton-space root-motion since the the last <pre><code>FixedUpdate</code></pre> call. You can use
             e.g. <pre><code>transform.TransformVector()</code></pre> to transform skeleton-space root-motion to world space.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonRootMotionBase
             * @memberof Spine.Unity.SkeletonRootMotionBase
             * @function removePhysicsUpdateRootMotionOverride
             * @param   {Spine.Unity.SkeletonRootMotionBase.RootMotionDelegate}    value
             * @return  {void}
             * @see {@link ProcessRootMotionOverride}
             */
            PhysicsUpdateRootMotionOverride: null
        },
        props: {
            RootMotionBone: {
                get: function () {
                    return this.rootMotionBone;
                }
            },
            UsesRigidbody: {
                get: function () {
                    return UnityEngine.Component.op_Inequality(this.rigidBody, null) || UnityEngine.Component.op_Inequality(this.rigidBody2D, null);
                }
            },
            /**
             * Root motion translation that has been applied in the preceding <pre><code>FixedUpdate</code></pre> call
             if a rigidbody is assigned at either <pre><code>rigidbody</code></pre> or <pre><code>rigidbody2D</code></pre>.
             Returns <pre><code>Vector2.zero</code></pre> when <pre><code>rigidbody</code></pre> and <pre><code>rigidbody2D</code></pre> are null.
             This can be necessary when multiple scripts call <pre><code>Rigidbody2D.MovePosition</code></pre>,
             where the last call overwrites the effect of preceding ones.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Unity.SkeletonRootMotionBase
             * @function PreviousRigidbodyRootMotion2D
             * @type UnityEngine.Vector2
             */
            PreviousRigidbodyRootMotion2D: {
                get: function () {
                    return new pc.Vec2( this.previousRigidbodyRootMotion.x, this.previousRigidbodyRootMotion.y );
                }
            },
            /**
             * Root motion translation that has been applied in the preceding <pre><code>FixedUpdate</code></pre> call
             if a rigidbody is assigned at either <pre><code>rigidbody</code></pre> or <pre><code>rigidbody2D</code></pre>.
             Returns <pre><code>Vector3.zero</code></pre> when <pre><code>rigidbody</code></pre> and <pre><code>rigidbody2D</code></pre> are null.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Unity.SkeletonRootMotionBase
             * @function PreviousRigidbodyRootMotion3D
             * @type UnityEngine.Vector3
             */
            PreviousRigidbodyRootMotion3D: {
                get: function () {
                    return this.previousRigidbodyRootMotion.$clone();
                }
            },
            /**
             * Additional translation to add to <pre><code>Rigidbody2D.MovePosition</code></pre>
             called in FixedUpdate. This can be necessary when multiple scripts call
             <pre><code>MovePosition</code></pre>, where the last call overwrites the effect of preceding ones.
             Has no effect if <pre><code>rigidBody2D</code></pre> is null.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRootMotionBase
             * @function AdditionalRigidbody2DMovement
             * @type UnityEngine.Vector2
             */
            AdditionalRigidbody2DMovement: {
                get: function () {
                    return this.additionalRigidbody2DMovement.$clone();
                },
                set: function (value) {
                    this.additionalRigidbody2DMovement = value.$clone();
                }
            },
            SkeletonAnimationUsesFixedUpdate: {
                get: function () {
                    var skeletonAnimation = Bridge.as(this.skeletonComponent, Spine.Unity.ISkeletonAnimation);
                    if (skeletonAnimation != null) {
                        return skeletonAnimation.Spine$Unity$ISkeletonAnimation$UpdateTiming === Spine.Unity.UpdateTiming.InFixedUpdate;
                    }
                    return false;
                }
            },
            AdditionalScale: {
                get: function () {
                    return 1.0;
                }
            },
            TargetSkeletonComponent: {
                get: function () {
                    if (this.skeletonComponent == null) {
                        this.skeletonComponent = this.GetComponent(Spine.Unity.ISkeletonComponent);
                    }
                    return this.skeletonComponent;
                }
            },
            TargetSkeletonAnimationComponent: {
                get: function () {
                    return Bridge.as(this.TargetSkeletonComponent, Spine.Unity.ISkeletonAnimation);
                }
            }
        },
        ctors: {
            init: function () {
                this.initialOffset = new UnityEngine.Vector2();
                this.tempSkeletonDisplacement = new UnityEngine.Vector2();
                this.rigidbodyDisplacement = new UnityEngine.Vector3();
                this.previousRigidbodyRootMotion = new UnityEngine.Vector3();
                this.additionalRigidbody2DMovement = new UnityEngine.Vector2();
                this.rigidbodyLocalRotation = new UnityEngine.Quaternion();
                this.rootMotionBoneName = "root";
                this.transformPositionX = true;
                this.transformPositionY = true;
                this.transformRotation = false;
                this.rootMotionScaleX = 1;
                this.rootMotionScaleY = 1;
                this.rootMotionScaleRotation = 1;
                this.rootMotionTranslateXPerY = 0;
                this.rootMotionTranslateYPerX = 0;
                this.applyRigidbody2DGravity = false;
                this.disableOnOverride = true;
                this.transformConstraintIndices = new (System.Collections.Generic.List$1(System.Int32)).ctor();
                this.transformConstraintLastPos = new (System.Collections.Generic.List$1(UnityEngine.Vector2)).ctor();
                this.transformConstraintLastRotation = new (System.Collections.Generic.List$1(System.Single)).ctor();
                this.topLevelBones = new (System.Collections.Generic.List$1(Spine.Bone)).ctor();
                this.initialOffset = pc.Vec2.ZERO.clone();
                this.accumulatedUntilFixedUpdate = false;
                this.previousRigidbodyRootMotion = UnityEngine.Vector3.FromVector2(pc.Vec2.ZERO.clone());
                this.additionalRigidbody2DMovement = pc.Vec2.ZERO.clone();
                this.rigidbodyLocalRotation = pc.Quat.IDENTITY.clone();
            }
        },
        methods: {
            /*Spine.Unity.SkeletonRootMotionBase.Reset start.*/
            Reset: function () {
                this.FindRigidbodyComponent();
            },
            /*Spine.Unity.SkeletonRootMotionBase.Reset end.*/

            /*Spine.Unity.SkeletonRootMotionBase.Start start.*/
            Start: function () {
                this.skeletonComponent = this.GetComponent(Spine.Unity.ISkeletonComponent);
                this.GatherTopLevelBones();
                this.SetRootMotionBone(this.rootMotionBoneName);
                if (this.rootMotionBone != null) {
                    this.initialOffset = new pc.Vec2( this.rootMotionBone.x, this.rootMotionBone.y );
                    this.initialOffsetRotation = this.rootMotionBone.rotation;
                }

                var skeletonAnimation = Bridge.as(this.skeletonComponent, Spine.Unity.ISkeletonAnimation);
                if (skeletonAnimation != null) {
                    skeletonAnimation.Spine$Unity$ISkeletonAnimation$removeUpdateLocal(Bridge.fn.cacheBind(this, this.HandleUpdateLocal));
                    skeletonAnimation.Spine$Unity$ISkeletonAnimation$addUpdateLocal(Bridge.fn.cacheBind(this, this.HandleUpdateLocal));
                }
            },
            /*Spine.Unity.SkeletonRootMotionBase.Start end.*/

            /*Spine.Unity.SkeletonRootMotionBase.FixedUpdate start.*/
            FixedUpdate: function () {
                // Root motion is only applied when component is enabled.
                if (!this.isActiveAndEnabled) {
                    return;
                }
                // When SkeletonAnimation component uses UpdateTiming.InFixedUpdate,
                // we directly call PhysicsUpdate in HandleUpdateLocal instead of here.
                if (!this.SkeletonAnimationUsesFixedUpdate) {
                    this.PhysicsUpdate(false);
                }
            },
            /*Spine.Unity.SkeletonRootMotionBase.FixedUpdate end.*/

            /*Spine.Unity.SkeletonRootMotionBase.PhysicsUpdate start.*/
            PhysicsUpdate: function (skeletonAnimationUsesFixedUpdate) {
                var callbackDisplacement = this.tempSkeletonDisplacement.$clone();
                var callbackRotation = this.tempSkeletonRotation;

                var isApplyAtRigidbodyAllowed = Bridge.staticEquals(this.PhysicsUpdateRootMotionOverride, null) || !this.disableOnOverride;
                if (isApplyAtRigidbodyAllowed) {
                    if (UnityEngine.Component.op_Inequality(this.rigidBody2D, null)) {
                        var gravityAndVelocityMovement = pc.Vec2.ZERO.clone();
                        if (this.applyRigidbody2DGravity) {
                            var deltaTime = UnityEngine.Time.fixedDeltaTime;
                            var deltaTimeSquared = (deltaTime * deltaTime);

                            this.rigidBody2D.velocity = this.rigidBody2D.velocity.$clone().add( UnityEngine.Physics2D.gravity.$clone().scale( this.rigidBody2D.gravityScale ).scale( deltaTime ) );
                            gravityAndVelocityMovement = UnityEngine.Physics2D.gravity.$clone().scale( 0.5 * this.rigidBody2D.gravityScale ).scale( deltaTimeSquared ).add( this.rigidBody2D.velocity.$clone().scale( deltaTime ) );
                        }

                        var rigidbodyDisplacement2D = new pc.Vec2( this.rigidbodyDisplacement.x, this.rigidbodyDisplacement.y );
                        this.rigidBody2D.MovePosition(gravityAndVelocityMovement.$clone().add( new pc.Vec2( this.rigidBody2D.position.x, this.rigidBody2D.position.y ) ).add( rigidbodyDisplacement2D ).add( this.additionalRigidbody2DMovement ));
                        this.rigidBody2D.MoveRotation(this.rigidbody2DRotation + this.rigidBody2D.rotation);
                    } else if (UnityEngine.Component.op_Inequality(this.rigidBody, null)) {
                        this.rigidBody.MovePosition(this.rigidBody.position.$clone().add( new pc.Vec3( this.rigidbodyDisplacement.x, this.rigidbodyDisplacement.y, this.rigidbodyDisplacement.z ) ));
                        this.rigidBody.MoveRotation(this.rigidBody.rotation.clone().mul( this.rigidbodyLocalRotation ));
                    }
                }

                this.previousRigidbodyRootMotion = this.rigidbodyDisplacement.$clone();
                if (this.accumulatedUntilFixedUpdate) {
                    var parentBoneScale = { v : new UnityEngine.Vector2() };
                    this.GetScaleAffectingRootMotion$1(parentBoneScale);
                    this.ClearEffectiveBoneOffsets(parentBoneScale.v.$clone());
                    this.skeletonComponent.Spine$Unity$ISkeletonComponent$Skeleton.updateWorldTransform();
                }
                this.ClearRigidbodyTempMovement();

                if (!Bridge.staticEquals(this.PhysicsUpdateRootMotionOverride, null)) {
                    this.PhysicsUpdateRootMotionOverride(this, callbackDisplacement.$clone(), callbackRotation);
                }
            },
            /*Spine.Unity.SkeletonRootMotionBase.PhysicsUpdate end.*/

            /*Spine.Unity.SkeletonRootMotionBase.OnDisable start.*/
            OnDisable: function () {
                this.ClearRigidbodyTempMovement();
            },
            /*Spine.Unity.SkeletonRootMotionBase.OnDisable end.*/

            /*Spine.Unity.SkeletonRootMotionBase.FindRigidbodyComponent start.*/
            FindRigidbodyComponent: function () {
                this.rigidBody2D = this.GetComponent(UnityEngine.Rigidbody2D);
                if (!UnityEngine.Object.op_Implicit(this.rigidBody2D)) {
                    this.rigidBody = this.GetComponent(UnityEngine.Rigidbody);
                }

                if (!UnityEngine.Object.op_Implicit(this.rigidBody2D) && !UnityEngine.Object.op_Implicit(this.rigidBody)) {
                    this.rigidBody2D = this.GetComponentInParent(UnityEngine.Rigidbody2D);
                    if (!UnityEngine.Object.op_Implicit(this.rigidBody2D)) {
                        this.rigidBody = this.GetComponentInParent(UnityEngine.Rigidbody);
                    }
                }
            },
            /*Spine.Unity.SkeletonRootMotionBase.FindRigidbodyComponent end.*/

            /*Spine.Unity.SkeletonRootMotionBase.CalculateAnimationsRotationDelta start.*/
            CalculateAnimationsRotationDelta: function () {
                return 0;
            },
            /*Spine.Unity.SkeletonRootMotionBase.CalculateAnimationsRotationDelta end.*/

            /*Spine.Unity.SkeletonRootMotionBase.SetRootMotionBone start.*/
            SetRootMotionBone: function (name) {
                var skeleton = this.skeletonComponent.Spine$Unity$ISkeletonComponent$Skeleton;
                var bone = skeleton.findBone(name);
                if (bone != null) {
                    this.rootMotionBoneIndex = bone.data.index;
                    this.rootMotionBone = bone;
                    this.FindTransformConstraintsAffectingBone();
                } else {
                    UnityEngine.Debug.Log$1("Bone named \"" + (name || "") + "\" could not be found.");
                    this.rootMotionBoneIndex = 0;
                    this.rootMotionBone = skeleton.getRootBone();
                }
            },
            /*Spine.Unity.SkeletonRootMotionBase.SetRootMotionBone end.*/

            /*Spine.Unity.SkeletonRootMotionBase.AdjustRootMotionToDistance start.*/
            AdjustRootMotionToDistance: function (distanceToTarget, trackIndex, adjustX, adjustY, minX, maxX, minY, maxY, allowXTranslation, allowYTranslation) {
                if (trackIndex === void 0) { trackIndex = 0; }
                if (adjustX === void 0) { adjustX = true; }
                if (adjustY === void 0) { adjustY = true; }
                if (minX === void 0) { minX = 0.0; }
                if (maxX === void 0) { maxX = 3.40282347E+38; }
                if (minY === void 0) { minY = 0.0; }
                if (maxY === void 0) { maxY = 3.40282347E+38; }
                if (allowXTranslation === void 0) { allowXTranslation = false; }
                if (allowYTranslation === void 0) { allowYTranslation = false; }

                var distanceToTargetSkeletonSpace = UnityEngine.Vector2.FromVector3(this.transform.InverseTransformVector(UnityEngine.Vector3.FromVector2(distanceToTarget)));
                var scaleAffectingRootMotion = this.GetScaleAffectingRootMotion();
                if (this.UsesRigidbody) {
                    distanceToTargetSkeletonSpace = distanceToTargetSkeletonSpace.$clone().sub( this.tempSkeletonDisplacement.$clone() );
                }

                var remainingRootMotionSkeletonSpace = this.GetRemainingRootMotion(trackIndex);
                remainingRootMotionSkeletonSpace.mul( scaleAffectingRootMotion );
                if (remainingRootMotionSkeletonSpace.x === 0) {
                    remainingRootMotionSkeletonSpace.x = 0.0001;
                }
                if (remainingRootMotionSkeletonSpace.y === 0) {
                    remainingRootMotionSkeletonSpace.y = 0.0001;
                }

                if (adjustX) {
                    this.rootMotionScaleX = Math.min(maxX, Math.max(minX, distanceToTargetSkeletonSpace.x / remainingRootMotionSkeletonSpace.x));
                }
                if (adjustY) {
                    this.rootMotionScaleY = Math.min(maxY, Math.max(minY, distanceToTargetSkeletonSpace.y / remainingRootMotionSkeletonSpace.y));
                }

                if (allowXTranslation) {
                    this.rootMotionTranslateXPerY = (distanceToTargetSkeletonSpace.x - remainingRootMotionSkeletonSpace.x * this.rootMotionScaleX) / remainingRootMotionSkeletonSpace.y;
                }
                if (allowYTranslation) {
                    this.rootMotionTranslateYPerX = (distanceToTargetSkeletonSpace.y - remainingRootMotionSkeletonSpace.y * this.rootMotionScaleY) / remainingRootMotionSkeletonSpace.x;
                }
            },
            /*Spine.Unity.SkeletonRootMotionBase.AdjustRootMotionToDistance end.*/

            /*Spine.Unity.SkeletonRootMotionBase.GetAnimationRootMotion start.*/
            GetAnimationRootMotion: function (animation) {
                return this.GetAnimationRootMotion$1(0, animation.duration, animation);
            },
            /*Spine.Unity.SkeletonRootMotionBase.GetAnimationRootMotion end.*/

            /*Spine.Unity.SkeletonRootMotionBase.GetAnimationRootMotion$1 start.*/
            GetAnimationRootMotion$1: function (startTime, endTime, animation) {
                var $t, $t1;

                if (startTime === endTime) {
                    return pc.Vec2.ZERO.clone();
                }

                var translateTimeline = Spine.Unity.AnimationTools.TimelineExtensions.FindTranslateTimelineForBone(animation, this.rootMotionBoneIndex);
                var xTimeline = Spine.Unity.AnimationTools.TimelineExtensions.FindTimelineForBone(spine.TranslateXTimeline, animation, this.rootMotionBoneIndex);
                var yTimeline = Spine.Unity.AnimationTools.TimelineExtensions.FindTimelineForBone(spine.TranslateYTimeline, animation, this.rootMotionBoneIndex);

                // Non-looped base
                var endPos = { v : pc.Vec2.ZERO.clone() };
                var startPos = { v : pc.Vec2.ZERO.clone() };
                if (translateTimeline != null) {
                    endPos.v = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$1(translateTimeline, endTime);
                    startPos.v = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$1(translateTimeline, startTime);
                } else if (xTimeline != null || yTimeline != null) {
                    endPos.v = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$2(xTimeline, yTimeline, endTime);
                    startPos.v = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$2(xTimeline, yTimeline, startTime);
                }
                var transformConstraintsItems = this.skeletonComponent.Spine$Unity$ISkeletonComponent$Skeleton.TransformConstraints.Items;
                $t = Bridge.getEnumerator(this.transformConstraintIndices);
                try {
                    while ($t.moveNext()) {
                        var constraintIndex = $t.Current;
                        var constraint = transformConstraintsItems[constraintIndex];
                        this.ApplyConstraintToPos(animation, constraint, constraintIndex, endTime, false, endPos);
                        this.ApplyConstraintToPos(animation, constraint, constraintIndex, startTime, true, startPos);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                var currentDelta = endPos.v.$clone().sub( startPos.v );

                // Looped additions
                if (startTime > endTime) {
                    var loopPos = { v : pc.Vec2.ZERO.clone() };
                    var zeroPos = { v : pc.Vec2.ZERO.clone() };
                    if (translateTimeline != null) {
                        loopPos.v = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$1(translateTimeline, animation.duration);
                        zeroPos.v = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$1(translateTimeline, 0);
                    } else if (xTimeline != null || yTimeline != null) {
                        loopPos.v = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$2(xTimeline, yTimeline, animation.duration);
                        zeroPos.v = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$2(xTimeline, yTimeline, 0);
                    }
                    $t1 = Bridge.getEnumerator(this.transformConstraintIndices);
                    try {
                        while ($t1.moveNext()) {
                            var constraintIndex1 = $t1.Current;
                            var constraint1 = transformConstraintsItems[constraintIndex1];
                            this.ApplyConstraintToPos(animation, constraint1, constraintIndex1, animation.duration, false, loopPos);
                            this.ApplyConstraintToPos(animation, constraint1, constraintIndex1, 0, false, zeroPos);
                        }
                    } finally {
                        if (Bridge.is($t1, System.IDisposable)) {
                            $t1.System$IDisposable$Dispose();
                        }
                    }
                    currentDelta = currentDelta.$clone().add( loopPos.v.$clone().sub( zeroPos.v ) );
                }
                this.UpdateLastConstraintPos(transformConstraintsItems);
                return currentDelta.$clone();
            },
            /*Spine.Unity.SkeletonRootMotionBase.GetAnimationRootMotion$1 end.*/

            /*Spine.Unity.SkeletonRootMotionBase.GetAnimationRootMotionRotation start.*/
            GetAnimationRootMotionRotation: function (animation) {
                return this.GetAnimationRootMotionRotation$1(0, animation.duration, animation);
            },
            /*Spine.Unity.SkeletonRootMotionBase.GetAnimationRootMotionRotation end.*/

            /*Spine.Unity.SkeletonRootMotionBase.GetAnimationRootMotionRotation$1 start.*/
            GetAnimationRootMotionRotation$1: function (startTime, endTime, animation) {
                var $t, $t1;

                if (startTime === endTime) {
                    return 0;
                }

                var rotateTimeline = Spine.Unity.AnimationTools.TimelineExtensions.FindTimelineForBone(spine.RotateTimeline, animation, this.rootMotionBoneIndex);

                // Non-looped base
                var endRotation = { v : 0 };
                var startRotation = { v : 0 };
                if (rotateTimeline != null) {
                    endRotation.v = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate(rotateTimeline, endTime);
                    startRotation.v = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate(rotateTimeline, startTime);
                }
                var transformConstraintsItems = this.skeletonComponent.Spine$Unity$ISkeletonComponent$Skeleton.TransformConstraints.Items;
                $t = Bridge.getEnumerator(this.transformConstraintIndices);
                try {
                    while ($t.moveNext()) {
                        var constraintIndex = $t.Current;
                        var constraint = transformConstraintsItems[constraintIndex];
                        this.ApplyConstraintToRotation(animation, constraint, constraintIndex, endTime, false, endRotation);
                        this.ApplyConstraintToRotation(animation, constraint, constraintIndex, startTime, true, startRotation);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                var currentDelta = endRotation.v - startRotation.v;

                // Looped additions
                if (startTime > endTime) {
                    var loopRotation = { v : 0 };
                    var zeroPos = { v : 0 };
                    if (rotateTimeline != null) {
                        loopRotation.v = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate(rotateTimeline, animation.duration);
                        zeroPos.v = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate(rotateTimeline, 0);
                    }
                    $t1 = Bridge.getEnumerator(this.transformConstraintIndices);
                    try {
                        while ($t1.moveNext()) {
                            var constraintIndex1 = $t1.Current;
                            var constraint1 = transformConstraintsItems[constraintIndex1];
                            this.ApplyConstraintToRotation(animation, constraint1, constraintIndex1, animation.duration, false, loopRotation);
                            this.ApplyConstraintToRotation(animation, constraint1, constraintIndex1, 0, false, zeroPos);
                        }
                    } finally {
                        if (Bridge.is($t1, System.IDisposable)) {
                            $t1.System$IDisposable$Dispose();
                        }
                    }
                    currentDelta += loopRotation.v - zeroPos.v;
                }
                this.UpdateLastConstraintRotation(transformConstraintsItems);
                return currentDelta;
            },
            /*Spine.Unity.SkeletonRootMotionBase.GetAnimationRootMotionRotation$1 end.*/

            /*Spine.Unity.SkeletonRootMotionBase.ApplyConstraintToPos start.*/
            ApplyConstraintToPos: function (animation, constraint, constraintIndex, time, useLastConstraintPos, pos) {
                var timeline = Spine.Unity.AnimationTools.TimelineExtensions.FindTransformConstraintTimeline(animation, constraintIndex);
                if (timeline == null) {
                    return;
                }
                var mixXY = Spine.Unity.AnimationTools.TimelineExtensions.EvaluateTranslateXYMix(timeline, time);
                var invMixXY = Spine.Unity.AnimationTools.TimelineExtensions.EvaluateTranslateXYMix(timeline, time);
                var constraintPos = new UnityEngine.Vector2();
                if (useLastConstraintPos) {
                    constraintPos = this.transformConstraintLastPos.getItem(this.GetConstraintLastPosIndex(constraintIndex)).$clone();
                } else {
                    var targetBone = constraint.target;
                    constraintPos = new pc.Vec2( targetBone.x, targetBone.y );
                }
                pos.v = new pc.Vec2( pos.v.x * invMixXY.x + constraintPos.x * mixXY.x, pos.v.y * invMixXY.y + constraintPos.y * mixXY.y );
            },
            /*Spine.Unity.SkeletonRootMotionBase.ApplyConstraintToPos end.*/

            /*Spine.Unity.SkeletonRootMotionBase.ApplyConstraintToRotation start.*/
            ApplyConstraintToRotation: function (animation, constraint, constraintIndex, time, useLastConstraintRotation, rotation) {
                var timeline = Spine.Unity.AnimationTools.TimelineExtensions.FindTransformConstraintTimeline(animation, constraintIndex);
                if (timeline == null) {
                    return;
                }
                var mixRotate = Spine.Unity.AnimationTools.TimelineExtensions.EvaluateRotateMix(timeline, time);
                var invMixRotate = Spine.Unity.AnimationTools.TimelineExtensions.EvaluateRotateMix(timeline, time);
                var constraintRotation;
                if (useLastConstraintRotation) {
                    constraintRotation = this.transformConstraintLastRotation.getItem(this.GetConstraintLastPosIndex(constraintIndex));
                } else {
                    var targetBone = constraint.target;
                    constraintRotation = targetBone.rotation;
                }
                rotation.v = rotation.v * invMixRotate + constraintRotation * mixRotate;
            },
            /*Spine.Unity.SkeletonRootMotionBase.ApplyConstraintToRotation end.*/

            /*Spine.Unity.SkeletonRootMotionBase.UpdateLastConstraintPos start.*/
            UpdateLastConstraintPos: function (transformConstraintsItems) {
                var $t;
                $t = Bridge.getEnumerator(this.transformConstraintIndices);
                try {
                    while ($t.moveNext()) {
                        var constraintIndex = $t.Current;
                        var constraint = transformConstraintsItems[constraintIndex];
                        var targetBone = constraint.target;
                        this.transformConstraintLastPos.setItem(this.GetConstraintLastPosIndex(constraintIndex), new pc.Vec2( targetBone.x, targetBone.y ));
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.Unity.SkeletonRootMotionBase.UpdateLastConstraintPos end.*/

            /*Spine.Unity.SkeletonRootMotionBase.UpdateLastConstraintRotation start.*/
            UpdateLastConstraintRotation: function (transformConstraintsItems) {
                var $t;
                $t = Bridge.getEnumerator(this.transformConstraintIndices);
                try {
                    while ($t.moveNext()) {
                        var constraintIndex = $t.Current;
                        var constraint = transformConstraintsItems[constraintIndex];
                        var targetBone = constraint.target;
                        this.transformConstraintLastRotation.setItem(this.GetConstraintLastPosIndex(constraintIndex), targetBone.rotation);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.Unity.SkeletonRootMotionBase.UpdateLastConstraintRotation end.*/

            /*Spine.Unity.SkeletonRootMotionBase.GetAnimationRootMotionInfo start.*/
            GetAnimationRootMotionInfo: function (animation, currentTime) {
                var rootMotion = new Spine.Unity.SkeletonRootMotionBase.RootMotionInfo();
                var duration = animation.duration;
                var mid = duration * 0.5;
                rootMotion.timeIsPastMid = currentTime > mid;
                var timeline = Spine.Unity.AnimationTools.TimelineExtensions.FindTranslateTimelineForBone(animation, this.rootMotionBoneIndex);
                if (timeline != null) {
                    rootMotion.start = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$1(timeline, 0);
                    rootMotion.current = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$1(timeline, currentTime);
                    rootMotion.mid = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$1(timeline, mid);
                    rootMotion.end = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$1(timeline, duration);
                    return rootMotion.$clone();
                }
                var xTimeline = Spine.Unity.AnimationTools.TimelineExtensions.FindTimelineForBone(spine.TranslateXTimeline, animation, this.rootMotionBoneIndex);
                var yTimeline = Spine.Unity.AnimationTools.TimelineExtensions.FindTimelineForBone(spine.TranslateYTimeline, animation, this.rootMotionBoneIndex);
                if (xTimeline != null || yTimeline != null) {
                    rootMotion.start = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$2(xTimeline, yTimeline, 0);
                    rootMotion.current = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$2(xTimeline, yTimeline, currentTime);
                    rootMotion.mid = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$2(xTimeline, yTimeline, mid);
                    rootMotion.end = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$2(xTimeline, yTimeline, duration);
                    return rootMotion.$clone();
                }
                return rootMotion.$clone();
            },
            /*Spine.Unity.SkeletonRootMotionBase.GetAnimationRootMotionInfo end.*/

            /*Spine.Unity.SkeletonRootMotionBase.GetConstraintLastPosIndex start.*/
            GetConstraintLastPosIndex: function (constraintIndex) {
                var constraints = this.skeletonComponent.Spine$Unity$ISkeletonComponent$Skeleton.TransformConstraints;
                return this.transformConstraintIndices.FindIndex$2(function (addedIndex) {
                    return addedIndex === constraintIndex;
                });
            },
            /*Spine.Unity.SkeletonRootMotionBase.GetConstraintLastPosIndex end.*/

            /*Spine.Unity.SkeletonRootMotionBase.FindTransformConstraintsAffectingBone start.*/
            FindTransformConstraintsAffectingBone: function () {
                var constraints = this.skeletonComponent.Spine$Unity$ISkeletonComponent$Skeleton.TransformConstraints;
                var constraintsItems = constraints.Items;
                for (var i = 0, n = constraints.Count; i < n; i = (i + 1) | 0) {
                    var constraint = constraintsItems[i];
                    if (constraint.Bones.Contains(this.rootMotionBone)) {
                        this.transformConstraintIndices.add(i);
                        var targetBone = constraint.target;
                        var constraintPos = new pc.Vec2( targetBone.x, targetBone.y );
                        this.transformConstraintLastPos.add(constraintPos.$clone());
                        this.transformConstraintLastRotation.add(targetBone.rotation);
                    }
                }
            },
            /*Spine.Unity.SkeletonRootMotionBase.FindTransformConstraintsAffectingBone end.*/

            /*Spine.Unity.SkeletonRootMotionBase.GetTimelineMovementDelta start.*/
            GetTimelineMovementDelta: function (startTime, endTime, xTimeline, yTimeline, animation) {

                var currentDelta = new UnityEngine.Vector2();
                if (startTime > endTime) {
                    currentDelta = (Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$2(xTimeline, yTimeline, animation.duration).sub( Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$2(xTimeline, yTimeline, startTime) )).add( (Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$2(xTimeline, yTimeline, endTime).sub( Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$2(xTimeline, yTimeline, 0) )) );
                } else {
                    if (startTime !== endTime) {
                        currentDelta = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$2(xTimeline, yTimeline, endTime).sub( Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$2(xTimeline, yTimeline, startTime) );
                    } else {
                        currentDelta = pc.Vec2.ZERO.clone();
                    }
                }
                return currentDelta.$clone();
            },
            /*Spine.Unity.SkeletonRootMotionBase.GetTimelineMovementDelta end.*/

            /*Spine.Unity.SkeletonRootMotionBase.GatherTopLevelBones start.*/
            GatherTopLevelBones: function () {
                var $t;
                this.topLevelBones.clear();
                var skeleton = this.skeletonComponent.Spine$Unity$ISkeletonComponent$Skeleton;
                $t = Bridge.getEnumerator(skeleton.bones);
                try {
                    while ($t.moveNext()) {
                        var bone = $t.Current;
                        if (bone.parent == null) {
                            this.topLevelBones.add(bone);
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.Unity.SkeletonRootMotionBase.GatherTopLevelBones end.*/

            /*Spine.Unity.SkeletonRootMotionBase.HandleUpdateLocal start.*/
            HandleUpdateLocal: function (animatedSkeletonComponent) {
                if (!this.isActiveAndEnabled) {
                    return;
                } // Root motion is only applied when component is enabled.

                var boneLocalDelta = this.CalculateAnimationsMovementDelta();
                var parentBoneScale = { v : new UnityEngine.Vector2() };
                var totalScale = { v : new UnityEngine.Vector2() };
                var skeletonTranslationDelta = this.GetSkeletonSpaceMovementDelta(boneLocalDelta.$clone(), parentBoneScale, totalScale);
                var skeletonRotationDelta = 0;
                if (this.transformRotation) {
                    var boneLocalDeltaRotation = this.CalculateAnimationsRotationDelta();
                    boneLocalDeltaRotation *= this.rootMotionScaleRotation;
                    skeletonRotationDelta = this.GetSkeletonSpaceRotationDelta(boneLocalDeltaRotation, totalScale.v.$clone());
                }

                var usesFixedUpdate = this.SkeletonAnimationUsesFixedUpdate;
                this.ApplyRootMotion(skeletonTranslationDelta.$clone(), skeletonRotationDelta, parentBoneScale.v.$clone(), usesFixedUpdate);

                if (usesFixedUpdate) {
                    this.PhysicsUpdate(usesFixedUpdate);
                }
            },
            /*Spine.Unity.SkeletonRootMotionBase.HandleUpdateLocal end.*/

            /*Spine.Unity.SkeletonRootMotionBase.ApplyRootMotion start.*/
            ApplyRootMotion: function (skeletonTranslationDelta, skeletonRotationDelta, parentBoneScale, skeletonAnimationUsesFixedUpdate) {

                // Accumulated displacement is applied on the next Physics update in FixedUpdate.
                // Until the next Physics update, tempSkeletonDisplacement and tempSkeletonRotation
                // are offsetting bone locations to prevent stutter which would otherwise occur if
                // we don't move every Update.
                var usesRigidbody = this.UsesRigidbody;
                var applyToTransform = !usesRigidbody && (Bridge.staticEquals(this.ProcessRootMotionOverride, null) || !this.disableOnOverride);
                this.accumulatedUntilFixedUpdate = !applyToTransform && !skeletonAnimationUsesFixedUpdate;

                if (!Bridge.staticEquals(this.ProcessRootMotionOverride, null)) {
                    this.ProcessRootMotionOverride(this, skeletonTranslationDelta.$clone(), skeletonRotationDelta);
                }

                // Apply root motion to Transform or update values applied to RigidBody later (must happen in FixedUpdate).
                if (usesRigidbody) {
                    this.rigidbodyDisplacement = this.rigidbodyDisplacement.$clone().add( this.transform.TransformVector(UnityEngine.Vector3.FromVector2(skeletonTranslationDelta)) );
                    if (skeletonRotationDelta !== 0.0) {
                        if (UnityEngine.Component.op_Inequality(this.rigidBody, null)) {
                            var addedWorldRotation = new pc.Quat().setFromEulerAngles_Unity( 0, 0, skeletonRotationDelta );
                            this.rigidbodyLocalRotation = this.rigidbodyLocalRotation.clone().mul( addedWorldRotation );
                        } else if (UnityEngine.Component.op_Inequality(this.rigidBody2D, null)) {
                            var lossyScale = this.transform.lossyScale.$clone();
                            var rotationSign = lossyScale.x * lossyScale.y > 0 ? 1 : -1;
                            this.rigidbody2DRotation += rotationSign * skeletonRotationDelta;
                        }
                    }
                } else if (applyToTransform) {
                    this.transform.position = this.transform.position.$clone().add( this.transform.TransformVector(UnityEngine.Vector3.FromVector2(skeletonTranslationDelta)) );
                    if (skeletonRotationDelta !== 0.0) {
                        var lossyScale1 = this.transform.lossyScale.$clone();
                        var rotationSign1 = lossyScale1.x * lossyScale1.y > 0 ? 1 : -1;
                        this.transform.Rotate(0, 0, rotationSign1 * skeletonRotationDelta);
                    }
                }

                this.tempSkeletonDisplacement = this.tempSkeletonDisplacement.$clone().add( skeletonTranslationDelta.$clone() );
                this.tempSkeletonRotation += skeletonRotationDelta;
                if (this.accumulatedUntilFixedUpdate) {
                    this.SetEffectiveBoneOffsetsTo(this.tempSkeletonDisplacement.$clone(), this.tempSkeletonRotation, parentBoneScale.$clone());
                } else {
                    this.ClearEffectiveBoneOffsets(parentBoneScale.$clone());
                }
            },
            /*Spine.Unity.SkeletonRootMotionBase.ApplyRootMotion end.*/

            /*Spine.Unity.SkeletonRootMotionBase.ApplyTransformConstraints start.*/
            ApplyTransformConstraints: function () {
                var $t;
                this.rootMotionBone.ax = this.rootMotionBone.x;
                this.rootMotionBone.ay = this.rootMotionBone.y;
                this.rootMotionBone.arotation = this.rootMotionBone.rotation;
                var transformConstraintsItems = this.skeletonComponent.Spine$Unity$ISkeletonComponent$Skeleton.TransformConstraints.Items;
                $t = Bridge.getEnumerator(this.transformConstraintIndices);
                try {
                    while ($t.moveNext()) {
                        var constraintIndex = $t.Current;
                        var constraint = transformConstraintsItems[constraintIndex];
                        // apply the constraint and sets Bone.ax, Bone.ay and Bone.arotation values.
                        constraint.update();
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.Unity.SkeletonRootMotionBase.ApplyTransformConstraints end.*/

            /*Spine.Unity.SkeletonRootMotionBase.GetScaleAffectingRootMotion start.*/
            GetScaleAffectingRootMotion: function () {
                var parentBoneScale = { v : new UnityEngine.Vector2() };
                return this.GetScaleAffectingRootMotion$1(parentBoneScale);
            },
            /*Spine.Unity.SkeletonRootMotionBase.GetScaleAffectingRootMotion end.*/

            /*Spine.Unity.SkeletonRootMotionBase.GetScaleAffectingRootMotion$1 start.*/
            GetScaleAffectingRootMotion$1: function (parentBoneScale) {
                var skeleton = this.skeletonComponent.Spine$Unity$ISkeletonComponent$Skeleton;
                var totalScale = pc.Vec2.ONE.clone();
                totalScale.x *= skeleton.scaleX;
                totalScale.y *= skeleton.scaleY;

                parentBoneScale.v = pc.Vec2.ONE.clone();
                var scaleBone = this.rootMotionBone;
                while (((scaleBone = scaleBone.parent)) != null) {
                    parentBoneScale.v.x *= scaleBone.scaleX;
                    parentBoneScale.v.y *= scaleBone.scaleY;
                }
                totalScale = new pc.Vec2( totalScale.x * parentBoneScale.v.x, totalScale.y * parentBoneScale.v.y );
                totalScale = totalScale.$clone().scale( this.AdditionalScale );
                return totalScale.$clone();
            },
            /*Spine.Unity.SkeletonRootMotionBase.GetScaleAffectingRootMotion$1 end.*/

            /*Spine.Unity.SkeletonRootMotionBase.GetSkeletonSpaceMovementDelta start.*/
            GetSkeletonSpaceMovementDelta: function (boneLocalDelta, parentBoneScale, totalScale) {
                var skeletonDelta = boneLocalDelta.$clone();
                totalScale.v = this.GetScaleAffectingRootMotion$1(parentBoneScale);
                skeletonDelta.mul( totalScale.v );

                var rootMotionTranslation = new pc.Vec2( this.rootMotionTranslateXPerY * skeletonDelta.y, this.rootMotionTranslateYPerX * skeletonDelta.x );

                skeletonDelta.x *= this.rootMotionScaleX;
                skeletonDelta.y *= this.rootMotionScaleY;
                skeletonDelta.x += rootMotionTranslation.x;
                skeletonDelta.y += rootMotionTranslation.y;

                if (!this.transformPositionX) {
                    skeletonDelta.x = 0.0;
                }
                if (!this.transformPositionY) {
                    skeletonDelta.y = 0.0;
                }
                return skeletonDelta.$clone();
            },
            /*Spine.Unity.SkeletonRootMotionBase.GetSkeletonSpaceMovementDelta end.*/

            /*Spine.Unity.SkeletonRootMotionBase.GetSkeletonSpaceRotationDelta start.*/
            GetSkeletonSpaceRotationDelta: function (boneLocalDelta, totalScaleAffectingRootMotion) {
                var rotationSign = totalScaleAffectingRootMotion.x * totalScaleAffectingRootMotion.y > 0 ? 1 : -1;
                return rotationSign * boneLocalDelta;
            },
            /*Spine.Unity.SkeletonRootMotionBase.GetSkeletonSpaceRotationDelta end.*/

            /*Spine.Unity.SkeletonRootMotionBase.SetEffectiveBoneOffsetsTo start.*/
            SetEffectiveBoneOffsetsTo: function (displacementSkeletonSpace, rotationSkeletonSpace, parentBoneScale) {
                var $t;

                this.ApplyTransformConstraints();

                // Move top level bones in opposite direction of the root motion bone
                var skeleton = this.skeletonComponent.Spine$Unity$ISkeletonComponent$Skeleton;
                $t = Bridge.getEnumerator(this.topLevelBones);
                try {
                    while ($t.moveNext()) {
                        var topLevelBone = $t.Current;
                        if (Bridge.referenceEquals(topLevelBone, this.rootMotionBone)) {
                            if (this.transformPositionX) {
                                topLevelBone.x = displacementSkeletonSpace.x / skeleton.scaleX;
                            }
                            if (this.transformPositionY) {
                                topLevelBone.y = displacementSkeletonSpace.y / skeleton.scaleY;
                            }
                            if (this.transformRotation) {
                                var rotationSign = skeleton.scaleX * skeleton.scaleY > 0 ? 1 : -1;
                                topLevelBone.rotation = rotationSign * rotationSkeletonSpace;
                            }
                        } else {
                            var useAppliedTransform = this.transformConstraintIndices.Count > 0;
                            var rootMotionBoneX = useAppliedTransform ? this.rootMotionBone.ax : this.rootMotionBone.x;
                            var rootMotionBoneY = useAppliedTransform ? this.rootMotionBone.ay : this.rootMotionBone.y;

                            var offsetX = (this.initialOffset.x - rootMotionBoneX) * parentBoneScale.x;
                            var offsetY = (this.initialOffset.y - rootMotionBoneY) * parentBoneScale.y;

                            if (this.transformPositionX) {
                                topLevelBone.x = (displacementSkeletonSpace.x / skeleton.scaleX) + offsetX;
                            }
                            if (this.transformPositionY) {
                                topLevelBone.y = (displacementSkeletonSpace.y / skeleton.scaleY) + offsetY;
                            }

                            if (this.transformRotation) {
                                var rootMotionBoneRotation = useAppliedTransform ? this.rootMotionBone.arotation : this.rootMotionBone.rotation;

                                var parentBoneRotationSign = (parentBoneScale.x * parentBoneScale.y > 0 ? 1 : -1);
                                var offsetRotation = (this.initialOffsetRotation - rootMotionBoneRotation) * parentBoneRotationSign;

                                var skeletonRotationSign = skeleton.scaleX * skeleton.scaleY > 0 ? 1 : -1;
                                topLevelBone.rotation = (rotationSkeletonSpace * skeletonRotationSign) + offsetRotation;
                            }
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.Unity.SkeletonRootMotionBase.SetEffectiveBoneOffsetsTo end.*/

            /*Spine.Unity.SkeletonRootMotionBase.ClearEffectiveBoneOffsets start.*/
            ClearEffectiveBoneOffsets: function (parentBoneScale) {
                this.SetEffectiveBoneOffsetsTo(pc.Vec2.ZERO.clone(), 0, parentBoneScale.$clone());
            },
            /*Spine.Unity.SkeletonRootMotionBase.ClearEffectiveBoneOffsets end.*/

            /*Spine.Unity.SkeletonRootMotionBase.ClearRigidbodyTempMovement start.*/
            ClearRigidbodyTempMovement: function () {
                this.rigidbodyDisplacement = UnityEngine.Vector3.FromVector2(pc.Vec2.ZERO.clone());
                this.tempSkeletonDisplacement = pc.Vec2.ZERO.clone();
                this.rigidbodyLocalRotation = pc.Quat.IDENTITY.clone();
                this.rigidbody2DRotation = 0;
                this.tempSkeletonRotation = 0;
            },
            /*Spine.Unity.SkeletonRootMotionBase.ClearRigidbodyTempMovement end.*/


        },
        overloads: {
            "GetAnimationRootMotion(float, float, Animation)": "GetAnimationRootMotion$1",
            "GetAnimationRootMotionRotation(float, float, Animation)": "GetAnimationRootMotionRotation$1",
            "GetScaleAffectingRootMotion(Vector2)": "GetScaleAffectingRootMotion$1"
        }
    });
    /*Spine.Unity.SkeletonRootMotionBase end.*/
    /**
     * @memberof Spine.Unity
     * @callback Spine.Unity.SkeletonPartsRenderer.SkeletonPartsRendererDelegate
     * @param   {Spine.Unity.SkeletonPartsRenderer}    skeletonPartsRenderer
     * @return  {void}
     */


    /*Spine.Unity.SkeletonPartsRenderer start.*/
    Bridge.define("Spine.Unity.SkeletonPartsRenderer", {
        inherits: [UnityEngine.MonoBehaviour],
        statics: {
            methods: {
                /*Spine.Unity.SkeletonPartsRenderer.NewPartsRendererGameObject:static start.*/
                NewPartsRendererGameObject: function (parent, name, sortingOrder) {
                    if (sortingOrder === void 0) { sortingOrder = 0; }
                    var go = new UnityEngine.GameObject.$ctor4(name, [UnityEngine.MeshFilter, UnityEngine.MeshRenderer]);
                    go.transform.SetParent(parent, false);
                    var returnComponent = go.AddComponent(Spine.Unity.SkeletonPartsRenderer);
                    returnComponent.MeshRenderer.sortingOrder = sortingOrder;

                    return returnComponent;
                },
                /*Spine.Unity.SkeletonPartsRenderer.NewPartsRendererGameObject:static end.*/


            }
        },
        fields: {
            meshGenerator: null,
            meshRenderer: null,
            meshFilter: null,
            buffers: null,
            currentInstructions: null
        },
        events: {
            /**
             * OnMeshAndMaterialsUpdated is called at the end of LateUpdate after the Mesh and
             all materials have been updated.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonPartsRenderer
             * @memberof Spine.Unity.SkeletonPartsRenderer
             * @function addOnMeshAndMaterialsUpdated
             * @param   {Spine.Unity.SkeletonPartsRenderer.SkeletonPartsRendererDelegate}    value
             * @return  {void}
             */
            /**
             * OnMeshAndMaterialsUpdated is called at the end of LateUpdate after the Mesh and
             all materials have been updated.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonPartsRenderer
             * @memberof Spine.Unity.SkeletonPartsRenderer
             * @function removeOnMeshAndMaterialsUpdated
             * @param   {Spine.Unity.SkeletonPartsRenderer.SkeletonPartsRendererDelegate}    value
             * @return  {void}
             */
            OnMeshAndMaterialsUpdated: null
        },
        props: {
            MeshGenerator: {
                get: function () {
                    this.LazyIntialize();
                    return this.meshGenerator;
                }
            },
            MeshRenderer: {
                get: function () {
                    this.LazyIntialize();
                    return this.meshRenderer;
                }
            },
            MeshFilter: {
                get: function () {
                    this.LazyIntialize();
                    return this.meshFilter;
                }
            }
        },
        ctors: {
            init: function () {
                this.currentInstructions = new Spine.Unity.SkeletonRendererInstruction();
            }
        },
        methods: {
            /*Spine.Unity.SkeletonPartsRenderer.LazyIntialize start.*/
            LazyIntialize: function () {
                if (this.buffers == null) {
                    this.buffers = new Spine.Unity.MeshRendererBuffers();
                    this.buffers.Initialize();

                    if (this.meshGenerator != null) {
                        return;
                    }
                    this.meshGenerator = new Spine.Unity.MeshGenerator();
                    this.meshFilter = this.GetComponent(UnityEngine.MeshFilter);
                    this.meshRenderer = this.GetComponent(UnityEngine.MeshRenderer);
                    this.currentInstructions.Clear();
                }
            },
            /*Spine.Unity.SkeletonPartsRenderer.LazyIntialize end.*/

            /*Spine.Unity.SkeletonPartsRenderer.OnDestroy start.*/
            OnDestroy: function () {
                if (this.buffers != null) {
                    this.buffers.Dispose();
                }
            },
            /*Spine.Unity.SkeletonPartsRenderer.OnDestroy end.*/

            /*Spine.Unity.SkeletonPartsRenderer.ClearMesh start.*/
            ClearMesh: function () {
                this.LazyIntialize();
                this.meshFilter.sharedMesh = null;
            },
            /*Spine.Unity.SkeletonPartsRenderer.ClearMesh end.*/

            /*Spine.Unity.SkeletonPartsRenderer.RenderParts start.*/
            RenderParts: function (instructions, startSubmesh, endSubmesh) {
                this.LazyIntialize();

                // STEP 1: Create instruction
                var smartMesh = this.buffers.GetNextMesh();
                this.currentInstructions.SetWithSubset(instructions, startSubmesh, endSubmesh);
                var updateTriangles = Spine.Unity.SkeletonRendererInstruction.GeometryNotEqual(this.currentInstructions, smartMesh.instructionUsed);

                // STEP 2: Generate mesh buffers.
                var currentInstructionsSubmeshesItems = this.currentInstructions.submeshInstructions.Items;
                this.meshGenerator.Begin();
                if (this.currentInstructions.hasActiveClipping) {
                    for (var i = 0; i < this.currentInstructions.submeshInstructions.Count; i = (i + 1) | 0) {
                        this.meshGenerator.AddSubmesh(currentInstructionsSubmeshesItems[i].$clone(), updateTriangles);
                    }
                } else {
                    this.meshGenerator.BuildMeshWithArrays(this.currentInstructions, updateTriangles);
                }

                this.buffers.UpdateSharedMaterials(this.currentInstructions.submeshInstructions);

                // STEP 3: modify mesh.
                var mesh = smartMesh.mesh;

                if (this.meshGenerator.VertexCount <= 0) { // Clear an empty mesh
                    updateTriangles = false;
                    mesh.Clear();
                } else {
                    this.meshGenerator.FillVertexData(mesh);
                    if (updateTriangles) {
                        this.meshGenerator.FillTriangles(mesh);
                        this.meshRenderer.sharedMaterials = this.buffers.GetUpdatedSharedMaterialsArray();
                    } else if (this.buffers.MaterialsChangedInLastUpdate()) {
                        this.meshRenderer.sharedMaterials = this.buffers.GetUpdatedSharedMaterialsArray();
                    }
                    this.meshGenerator.FillLateVertexData(mesh);
                }

                this.meshFilter.sharedMesh = mesh;
                smartMesh.instructionUsed.Set(this.currentInstructions);

                if (!Bridge.staticEquals(this.OnMeshAndMaterialsUpdated, null)) {
                    this.OnMeshAndMaterialsUpdated(this);
                }
            },
            /*Spine.Unity.SkeletonPartsRenderer.RenderParts end.*/

            /*Spine.Unity.SkeletonPartsRenderer.SetPropertyBlock start.*/
            SetPropertyBlock: function (block) {
                this.LazyIntialize();
                this.meshRenderer.SetPropertyBlock(block);
            },
            /*Spine.Unity.SkeletonPartsRenderer.SetPropertyBlock end.*/


        }
    });
    /*Spine.Unity.SkeletonPartsRenderer end.*/

    /*Spine.Unity.SkeletonRenderer+SpriteMaskInteractionMaterials start.*/
    Bridge.define("Spine.Unity.SkeletonRenderer.SpriteMaskInteractionMaterials", {
        $kind: 1002,
        fields: {
            /**
             * Material references for switching material sets at runtime when {@link } changes to {@link }.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer.SpriteMaskInteractionMaterials
             * @type Array.<UnityEngine.Material>
             */
            materialsMaskDisabled: null,
            /**
             * Material references for switching material sets at runtime when {@link } changes to {@link }.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer.SpriteMaskInteractionMaterials
             * @type Array.<UnityEngine.Material>
             */
            materialsInsideMask: null,
            /**
             * Material references for switching material sets at runtime when {@link } changes to {@link }.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer.SpriteMaskInteractionMaterials
             * @type Array.<UnityEngine.Material>
             */
            materialsOutsideMask: null
        },
        props: {
            AnyMaterialCreated: {
                get: function () {
                    return this.materialsMaskDisabled.length > 0 || this.materialsInsideMask.length > 0 || this.materialsOutsideMask.length > 0;
                }
            }
        },
        ctors: {
            init: function () {
                this.materialsMaskDisabled = System.Array.init(0, null, UnityEngine.Material);
                this.materialsInsideMask = System.Array.init(0, null, UnityEngine.Material);
                this.materialsOutsideMask = System.Array.init(0, null, UnityEngine.Material);
            }
        }
    });
    /*Spine.Unity.SkeletonRenderer+SpriteMaskInteractionMaterials end.*/

    /*Spine.Unity.SkeletonRendererCustomMaterials start.*/
    Bridge.define("Spine.Unity.SkeletonRendererCustomMaterials", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            skeletonRenderer: null,
            customSlotMaterials: null,
            customMaterialOverrides: null
        },
        ctors: {
            init: function () {
                this.customSlotMaterials = new (System.Collections.Generic.List$1(Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride)).ctor();
                this.customMaterialOverrides = new (System.Collections.Generic.List$1(Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride)).ctor();
            }
        },
        methods: {
            /*Spine.Unity.SkeletonRendererCustomMaterials.SetCustomSlotMaterials start.*/
            SetCustomSlotMaterials: function () {
                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonRenderer, null)) {
                    UnityEngine.Debug.LogError$2("skeletonRenderer == null");
                    return;
                }

                for (var i = 0; i < this.customSlotMaterials.Count; i = (i + 1) | 0) {
                    var slotMaterialOverride = this.customSlotMaterials.getItem(i).$clone();
                    if (slotMaterialOverride.overrideDisabled || System.String.isNullOrEmpty(slotMaterialOverride.slotName)) {
                        continue;
                    }

                    var slotObject = this.skeletonRenderer.skeleton.findSlot(slotMaterialOverride.slotName);
                    if (slotObject != null) {
                        this.skeletonRenderer.CustomSlotMaterials.setItem(slotObject, slotMaterialOverride.material);
                    }
                }
            },
            /*Spine.Unity.SkeletonRendererCustomMaterials.SetCustomSlotMaterials end.*/

            /*Spine.Unity.SkeletonRendererCustomMaterials.RemoveCustomSlotMaterials start.*/
            RemoveCustomSlotMaterials: function () {
                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonRenderer, null)) {
                    UnityEngine.Debug.LogError$2("skeletonRenderer == null");
                    return;
                }

                for (var i = 0; i < this.customSlotMaterials.Count; i = (i + 1) | 0) {
                    var slotMaterialOverride = this.customSlotMaterials.getItem(i).$clone();
                    if (System.String.isNullOrEmpty(slotMaterialOverride.slotName)) {
                        continue;
                    }

                    var slotObject = this.skeletonRenderer.skeleton.findSlot(slotMaterialOverride.slotName);
                    if (slotObject == null) {
                        continue;
                    }
                    var currentMaterial = { };
                    if (!this.skeletonRenderer.CustomSlotMaterials.tryGetValue(slotObject, currentMaterial)) {
                        continue;
                    }

                    // Do not revert the material if it was changed by something else
                    if (!Bridge.referenceEquals(currentMaterial.v, slotMaterialOverride.material)) {
                        continue;
                    }

                    this.skeletonRenderer.CustomSlotMaterials.remove(slotObject);
                }
            },
            /*Spine.Unity.SkeletonRendererCustomMaterials.RemoveCustomSlotMaterials end.*/

            /*Spine.Unity.SkeletonRendererCustomMaterials.SetCustomMaterialOverrides start.*/
            SetCustomMaterialOverrides: function () {
                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonRenderer, null)) {
                    UnityEngine.Debug.LogError$2("skeletonRenderer == null");
                    return;
                }

                for (var i = 0; i < this.customMaterialOverrides.Count; i = (i + 1) | 0) {
                    var atlasMaterialOverride = this.customMaterialOverrides.getItem(i).$clone();
                    if (atlasMaterialOverride.overrideDisabled) {
                        continue;
                    }

                    this.skeletonRenderer.CustomMaterialOverride.setItem(atlasMaterialOverride.originalMaterial, atlasMaterialOverride.replacementMaterial);
                }
            },
            /*Spine.Unity.SkeletonRendererCustomMaterials.SetCustomMaterialOverrides end.*/

            /*Spine.Unity.SkeletonRendererCustomMaterials.RemoveCustomMaterialOverrides start.*/
            RemoveCustomMaterialOverrides: function () {
                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonRenderer, null)) {
                    UnityEngine.Debug.LogError$2("skeletonRenderer == null");
                    return;
                }

                for (var i = 0; i < this.customMaterialOverrides.Count; i = (i + 1) | 0) {
                    var atlasMaterialOverride = this.customMaterialOverrides.getItem(i).$clone();
                    var currentMaterial = { };

                    if (!this.skeletonRenderer.CustomMaterialOverride.tryGetValue(atlasMaterialOverride.originalMaterial, currentMaterial)) {
                        continue;
                    }

                    // Do not revert the material if it was changed by something else
                    if (!Bridge.referenceEquals(currentMaterial.v, atlasMaterialOverride.replacementMaterial)) {
                        continue;
                    }

                    this.skeletonRenderer.CustomMaterialOverride.remove(atlasMaterialOverride.originalMaterial);
                }
            },
            /*Spine.Unity.SkeletonRendererCustomMaterials.RemoveCustomMaterialOverrides end.*/

            /*Spine.Unity.SkeletonRendererCustomMaterials.OnEnable start.*/
            OnEnable: function () {
                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonRenderer, null)) {
                    this.skeletonRenderer = this.GetComponent(Spine.Unity.SkeletonRenderer);
                }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonRenderer, null)) {
                    UnityEngine.Debug.LogError$2("skeletonRenderer == null");
                    return;
                }

                this.skeletonRenderer.Initialize(false);
                this.SetCustomMaterialOverrides();
                this.SetCustomSlotMaterials();
            },
            /*Spine.Unity.SkeletonRendererCustomMaterials.OnEnable end.*/

            /*Spine.Unity.SkeletonRendererCustomMaterials.OnDisable start.*/
            OnDisable: function () {
                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonRenderer, null)) {
                    UnityEngine.Debug.LogError$2("skeletonRenderer == null");
                    return;
                }

                this.RemoveCustomMaterialOverrides();
                this.RemoveCustomSlotMaterials();
            },
            /*Spine.Unity.SkeletonRendererCustomMaterials.OnDisable end.*/


        }
    });
    /*Spine.Unity.SkeletonRendererCustomMaterials end.*/

    /*Spine.Unity.SkeletonRendererCustomMaterials+AtlasMaterialOverride start.*/
    Bridge.define("Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride", {
        inherits: function () { return [System.IEquatable$1(Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride)]; },
        $kind: 1004,
        statics: {
            methods: {
                getDefaultValue: function () { return new Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride(); }
            }
        },
        fields: {
            overrideDisabled: false,
            originalMaterial: null,
            replacementMaterial: null
        },
        alias: ["equalsT", "System$IEquatable$1$Spine$Unity$SkeletonRendererCustomMaterials$AtlasMaterialOverride$equalsT"],
        ctors: {
            ctor: function () {
                this.$initialize();
            }
        },
        methods: {
            /*Spine.Unity.SkeletonRendererCustomMaterials+AtlasMaterialOverride.equalsT start.*/
            equalsT: function (other) {
                return this.overrideDisabled === other.overrideDisabled && Bridge.referenceEquals(this.originalMaterial, other.originalMaterial) && Bridge.referenceEquals(this.replacementMaterial, other.replacementMaterial);
            },
            /*Spine.Unity.SkeletonRendererCustomMaterials+AtlasMaterialOverride.equalsT end.*/

            getHashCode: function () {
                var h = Bridge.addHash([8608216668, this.overrideDisabled, this.originalMaterial, this.replacementMaterial]);
                return h;
            },
            $clone: function (to) {
                var s = to || new Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride();
                s.overrideDisabled = this.overrideDisabled;
                s.originalMaterial = this.originalMaterial;
                s.replacementMaterial = this.replacementMaterial;
                return s;
            }
        },
        overloads: {
            "Equals(AtlasMaterialOverride)": "equalsT"
        }
    });
    /*Spine.Unity.SkeletonRendererCustomMaterials+AtlasMaterialOverride end.*/

    /*Spine.Unity.SkeletonRendererCustomMaterials+SlotMaterialOverride start.*/
    Bridge.define("Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride", {
        inherits: function () { return [System.IEquatable$1(Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride)]; },
        $kind: 1004,
        statics: {
            methods: {
                getDefaultValue: function () { return new Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride(); }
            }
        },
        fields: {
            overrideDisabled: false,
            slotName: null,
            material: null
        },
        alias: ["equalsT", "System$IEquatable$1$Spine$Unity$SkeletonRendererCustomMaterials$SlotMaterialOverride$equalsT"],
        ctors: {
            ctor: function () {
                this.$initialize();
            }
        },
        methods: {
            /*Spine.Unity.SkeletonRendererCustomMaterials+SlotMaterialOverride.equalsT start.*/
            equalsT: function (other) {
                return this.overrideDisabled === other.overrideDisabled && Bridge.referenceEquals(this.slotName, other.slotName) && Bridge.referenceEquals(this.material, other.material);
            },
            /*Spine.Unity.SkeletonRendererCustomMaterials+SlotMaterialOverride.equalsT end.*/

            getHashCode: function () {
                var h = Bridge.addHash([9094239955, this.overrideDisabled, this.slotName, this.material]);
                return h;
            },
            $clone: function (to) {
                var s = to || new Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride();
                s.overrideDisabled = this.overrideDisabled;
                s.slotName = this.slotName;
                s.material = this.material;
                return s;
            }
        },
        overloads: {
            "Equals(SlotMaterialOverride)": "equalsT"
        }
    });
    /*Spine.Unity.SkeletonRendererCustomMaterials+SlotMaterialOverride end.*/

    /*Spine.Unity.SkeletonRendererInstruction start.*/
    /**
     * Instructions used by a SkeletonRenderer to render a mesh.
     *
     * @public
     * @class Spine.Unity.SkeletonRendererInstruction
     */
    Bridge.define("Spine.Unity.SkeletonRendererInstruction", {
        statics: {
            methods: {
                /*Spine.Unity.SkeletonRendererInstruction.GeometryNotEqual:static start.*/
                GeometryNotEqual: function (a, b) {

                    if (a.hasActiveClipping || b.hasActiveClipping) {
                        return true;
                    } // Triangles are unpredictable when clipping is active.

                    // Everything below assumes the raw vertex and triangle counts were used. (ie, no clipping was done)
                    if (a.rawVertexCount !== b.rawVertexCount) {
                        return true;
                    }

                    if (a.immutableTriangles !== b.immutableTriangles) {
                        return true;
                    }

                    var attachmentCountB = b.attachments.Count;
                    if (a.attachments.Count !== attachmentCountB) {
                        return true;
                    } // Bounds check for the looped storedAttachments count below.

                    // Submesh count changed
                    var submeshCountA = a.submeshInstructions.Count;
                    var submeshCountB = b.submeshInstructions.Count;
                    if (submeshCountA !== submeshCountB) {
                        return true;
                    }

                    // Submesh Instruction mismatch
                    var submeshInstructionsItemsA = a.submeshInstructions.Items;
                    var submeshInstructionsItemsB = b.submeshInstructions.Items;

                    var attachmentsA = a.attachments.Items;
                    var attachmentsB = b.attachments.Items;
                    for (var i = 0; i < attachmentCountB; i = (i + 1) | 0) {
                        if (!Bridge.referenceEquals(attachmentsA[i], attachmentsB[i])) {
                            return true;
                        }
                    }

                    for (var i1 = 0; i1 < submeshCountB; i1 = (i1 + 1) | 0) {
                        var submeshA = submeshInstructionsItemsA[i1].$clone();
                        var submeshB = submeshInstructionsItemsB[i1].$clone();

                        if (!(submeshA.rawVertexCount === submeshB.rawVertexCount && submeshA.startSlot === submeshB.startSlot && submeshA.endSlot === submeshB.endSlot && submeshA.rawTriangleCount === submeshB.rawTriangleCount && submeshA.rawFirstVertexIndex === submeshB.rawFirstVertexIndex)) {
                            return true;
                        }
                    }

                    return false;
                },
                /*Spine.Unity.SkeletonRendererInstruction.GeometryNotEqual:static end.*/


            }
        },
        fields: {
            submeshInstructions: null,
            immutableTriangles: false,
            hasActiveClipping: false,
            rawVertexCount: 0,
            attachments: null
        },
        ctors: {
            init: function () {
                this.submeshInstructions = new (Spine.ExposedList$1(Spine.Unity.SubmeshInstruction)).ctor();
                this.rawVertexCount = -1;
                this.attachments = new (Spine.ExposedList$1(spine.Attachment)).ctor();
            }
        },
        methods: {
            /*Spine.Unity.SkeletonRendererInstruction.Clear start.*/
            Clear: function () {
                this.attachments.Clear(false);
                this.rawVertexCount = -1;
                this.hasActiveClipping = false;
                this.submeshInstructions.Clear(false);
            },
            /*Spine.Unity.SkeletonRendererInstruction.Clear end.*/

            /*Spine.Unity.SkeletonRendererInstruction.Dispose start.*/
            Dispose: function () {
                this.attachments.Clear(true);
            },
            /*Spine.Unity.SkeletonRendererInstruction.Dispose end.*/

            /*Spine.Unity.SkeletonRendererInstruction.SetWithSubset start.*/
            SetWithSubset: function (instructions, startSubmesh, endSubmesh) {
                var runningVertexCount = 0;

                var submeshes = this.submeshInstructions;
                submeshes.Clear(false);
                var submeshCount = (endSubmesh - startSubmesh) | 0;
                submeshes.Resize(submeshCount);
                var submeshesItems = submeshes.Items;
                var instructionsItems = instructions.Items;
                for (var i = 0; i < submeshCount; i = (i + 1) | 0) {
                    var instruction = instructionsItems[((startSubmesh + i) | 0)].$clone();
                    submeshesItems[i] = instruction.$clone();
                    this.hasActiveClipping = !!(this.hasActiveClipping | instruction.hasClipping);
                    submeshesItems[i].rawFirstVertexIndex = runningVertexCount; // Ensure current instructions have correct cached values.
                    runningVertexCount = (runningVertexCount + instruction.rawVertexCount) | 0; // vertexCount will also be used for the rest of this method.
                }
                this.rawVertexCount = runningVertexCount;

                // assumption: instructions are contiguous. start and end are valid within instructions.

                var startSlot = instructionsItems[startSubmesh].startSlot;
                var endSlot = instructionsItems[((endSubmesh - 1) | 0)].endSlot;
                this.attachments.Clear(false);
                var attachmentCount = (endSlot - startSlot) | 0;
                this.attachments.Resize(attachmentCount);
                var attachmentsItems = this.attachments.Items;

                var drawOrderItems = instructionsItems[0].skeleton.DrawOrder.Items;
                for (var i1 = 0; i1 < attachmentCount; i1 = (i1 + 1) | 0) {
                    var slot = drawOrderItems[((startSlot + i1) | 0)];
                    if (!slot.bone.isActive()) {
                        continue;
                    }
                    attachmentsItems[i1] = slot.getAttachment();
                }

            },
            /*Spine.Unity.SkeletonRendererInstruction.SetWithSubset end.*/

            /*Spine.Unity.SkeletonRendererInstruction.Set start.*/
            Set: function (other) {
                this.immutableTriangles = other.immutableTriangles;

                this.hasActiveClipping = other.hasActiveClipping;
                this.rawVertexCount = other.rawVertexCount;
                this.attachments.Clear(false);
                this.attachments.EnsureCapacity(other.attachments.Capacity);
                this.attachments.Count = other.attachments.Count;
                other.attachments.CopyTo(this.attachments.Items);

                this.submeshInstructions.Clear(false);
                this.submeshInstructions.EnsureCapacity(other.submeshInstructions.Capacity);
                this.submeshInstructions.Count = other.submeshInstructions.Count;
                other.submeshInstructions.CopyTo(this.submeshInstructions.Items);
            },
            /*Spine.Unity.SkeletonRendererInstruction.Set end.*/


        }
    });
    /*Spine.Unity.SkeletonRendererInstruction end.*/
    /**
     * @memberof Spine.Unity
     * @callback Spine.Unity.SkeletonRenderer.SkeletonRendererDelegate
     * @param   {Spine.Unity.SkeletonRenderer}    skeletonRenderer
     * @return  {void}
     */


    /*Spine.Unity.SkeletonRenderSeparator start.*/
    Bridge.define("Spine.Unity.SkeletonRenderSeparator", {
        inherits: [UnityEngine.MonoBehaviour],
        statics: {
            fields: {
                DefaultSortingOrderIncrement: 0
            },
            ctors: {
                init: function () {
                    this.DefaultSortingOrderIncrement = 5;
                }
            },
            methods: {
                /*Spine.Unity.SkeletonRenderSeparator.AddToSkeletonRenderer:static start.*/
                /**
                 * Adds a SkeletonRenderSeparator and child SkeletonPartsRenderer GameObjects to a given SkeletonRenderer.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonRenderSeparator
                 * @memberof Spine.Unity.SkeletonRenderSeparator
                 * @param   {Spine.Unity.SkeletonRenderer}           skeletonRenderer            The target SkeletonRenderer or SkeletonAnimation.
                 * @param   {number}                                 sortingLayerID              Sorting layer to be used for the parts renderers.
                 * @param   {number}                                 extraPartsRenderers         Number of additional SkeletonPartsRenderers on top of the ones determined by counting the number of separator slots.
                 * @param   {number}                                 sortingOrderIncrement       The integer to increment the sorting order per SkeletonPartsRenderer to separate them.
                 * @param   {number}                                 baseSortingOrder            The sorting order value of the first SkeletonPartsRenderer.
                 * @param   {boolean}                                addMinimumPartsRenderers    If set to <pre><code>true</code></pre>, a minimum number of SkeletonPartsRenderer GameObjects (determined by separatorSlots.Count + 1) will be added.
                 * @return  {Spine.Unity.SkeletonRenderSeparator}                                The to skeleton renderer.
                 */
                AddToSkeletonRenderer: function (skeletonRenderer, sortingLayerID, extraPartsRenderers, sortingOrderIncrement, baseSortingOrder, addMinimumPartsRenderers) {
                    if (sortingLayerID === void 0) { sortingLayerID = 0; }
                    if (extraPartsRenderers === void 0) { extraPartsRenderers = 0; }
                    if (sortingOrderIncrement === void 0) { sortingOrderIncrement = 5; }
                    if (baseSortingOrder === void 0) { baseSortingOrder = 0; }
                    if (addMinimumPartsRenderers === void 0) { addMinimumPartsRenderers = true; }
                    if (UnityEngine.MonoBehaviour.op_Equality(skeletonRenderer, null)) {
                        UnityEngine.Debug.Log$1("Tried to add SkeletonRenderSeparator to a null SkeletonRenderer reference.");
                        return null;
                    }

                    var srs = skeletonRenderer.gameObject.AddComponent(Spine.Unity.SkeletonRenderSeparator);
                    srs.skeletonRenderer = skeletonRenderer;

                    skeletonRenderer.Initialize(false);
                    var count = extraPartsRenderers;
                    if (addMinimumPartsRenderers) {
                        count = (((extraPartsRenderers + skeletonRenderer.separatorSlots.Count) | 0) + 1) | 0;
                    }

                    var skeletonRendererTransform = skeletonRenderer.transform;
                    var componentRenderers = srs.partsRenderers;

                    for (var i = 0; i < count; i = (i + 1) | 0) {
                        var spr = Spine.Unity.SkeletonPartsRenderer.NewPartsRendererGameObject(skeletonRendererTransform, Bridge.toString(i));
                        var mr = spr.MeshRenderer;
                        mr.sortingLayerID = sortingLayerID;
                        mr.sortingOrder = (baseSortingOrder + (Bridge.Int.mul(i, sortingOrderIncrement))) | 0;
                        componentRenderers.add(spr);
                    }

                    srs.OnEnable();


                    return srs;
                },
                /*Spine.Unity.SkeletonRenderSeparator.AddToSkeletonRenderer:static end.*/


            }
        },
        fields: {
            skeletonRenderer: null,
            mainMeshRenderer: null,
            copyPropertyBlock: false,
            copyMeshRendererFlags: false,
            partsRenderers: null,
            copiedBlock: null
        },
        events: {
            /**
             * OnMeshAndMaterialsUpdated is called at the end of LateUpdate after the Mesh and
             all materials have been updated.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonRenderSeparator
             * @memberof Spine.Unity.SkeletonRenderSeparator
             * @function addOnMeshAndMaterialsUpdated
             * @param   {Spine.Unity.SkeletonRenderer.SkeletonRendererDelegate}    value
             * @return  {void}
             */
            /**
             * OnMeshAndMaterialsUpdated is called at the end of LateUpdate after the Mesh and
             all materials have been updated.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonRenderSeparator
             * @memberof Spine.Unity.SkeletonRenderSeparator
             * @function removeOnMeshAndMaterialsUpdated
             * @param   {Spine.Unity.SkeletonRenderer.SkeletonRendererDelegate}    value
             * @return  {void}
             */
            OnMeshAndMaterialsUpdated: null
        },
        props: {
            SkeletonRenderer: {
                get: function () {
                    return this.skeletonRenderer;
                },
                set: function (value) {
                    if (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonRenderer, null)) {
                        this.skeletonRenderer.removeGenerateMeshOverride(Bridge.fn.cacheBind(this, this.HandleRender));
                    }

                    this.skeletonRenderer = value;
                    if (UnityEngine.MonoBehaviour.op_Equality(value, null)) {
                        this.enabled = false;
                    }
                }
            }
        },
        ctors: {
            init: function () {
                this.copyPropertyBlock = true;
                this.copyMeshRendererFlags = true;
                this.partsRenderers = new (System.Collections.Generic.List$1(Spine.Unity.SkeletonPartsRenderer)).ctor();
            }
        },
        methods: {
            /*Spine.Unity.SkeletonRenderSeparator.AddPartsRenderer start.*/
            /**
             * Add a child SkeletonPartsRenderer GameObject to this SkeletonRenderSeparator.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonRenderSeparator
             * @memberof Spine.Unity.SkeletonRenderSeparator
             * @param   {number}                               sortingOrderIncrement    
             * @param   {string}                               name
             * @return  {Spine.Unity.SkeletonPartsRenderer}
             */
            AddPartsRenderer: function (sortingOrderIncrement, name) {
                if (sortingOrderIncrement === void 0) { sortingOrderIncrement = 5; }
                if (name === void 0) { name = null; }
                var sortingLayerID = 0;
                var sortingOrder = 0;
                if (this.partsRenderers.Count > 0) {
                    var previous = this.partsRenderers.getItem(((this.partsRenderers.Count - 1) | 0));
                    var previousMeshRenderer = previous.MeshRenderer;
                    sortingLayerID = previousMeshRenderer.sortingLayerID;
                    sortingOrder = (previousMeshRenderer.sortingOrder + sortingOrderIncrement) | 0;
                }

                if (System.String.isNullOrEmpty(name)) {
                    name = Bridge.toString(this.partsRenderers.Count);
                }

                var spr = Spine.Unity.SkeletonPartsRenderer.NewPartsRendererGameObject(this.skeletonRenderer.transform, name);
                this.partsRenderers.add(spr);

                var mr = spr.MeshRenderer;
                mr.sortingLayerID = sortingLayerID;
                mr.sortingOrder = sortingOrder;

                return spr;
            },
            /*Spine.Unity.SkeletonRenderSeparator.AddPartsRenderer end.*/

            /*Spine.Unity.SkeletonRenderSeparator.OnEnable start.*/
            OnEnable: function () {
                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonRenderer, null)) {
                    return;
                }
                if (this.copiedBlock == null) {
                    this.copiedBlock = new UnityEngine.MaterialPropertyBlock();
                }
                this.mainMeshRenderer = this.skeletonRenderer.GetComponent(UnityEngine.MeshRenderer);

                this.skeletonRenderer.removeGenerateMeshOverride(Bridge.fn.cacheBind(this, this.HandleRender));
                this.skeletonRenderer.addGenerateMeshOverride(Bridge.fn.cacheBind(this, this.HandleRender));

                if (this.copyMeshRendererFlags) {
                    var lightProbeUsage = this.mainMeshRenderer.lightProbeUsage;
                    var receiveShadows = this.mainMeshRenderer.receiveShadows;
                    var reflectionProbeUsage = this.mainMeshRenderer.reflectionProbeUsage;
                    var shadowCastingMode = this.mainMeshRenderer.shadowCastingMode;
                    var motionVectorGenerationMode = this.mainMeshRenderer.motionVectorGenerationMode;
                    var probeAnchor = this.mainMeshRenderer.probeAnchor;

                    for (var i = 0; i < this.partsRenderers.Count; i = (i + 1) | 0) {
                        var currentRenderer = this.partsRenderers.getItem(i);
                        if (UnityEngine.MonoBehaviour.op_Equality(currentRenderer, null)) {
                            continue;
                        } // skip null items.

                        var mr = currentRenderer.MeshRenderer;
                        mr.lightProbeUsage = lightProbeUsage;
                        mr.receiveShadows = receiveShadows;
                        mr.reflectionProbeUsage = reflectionProbeUsage;
                        mr.shadowCastingMode = shadowCastingMode;
                        mr.motionVectorGenerationMode = motionVectorGenerationMode;
                        mr.probeAnchor = probeAnchor;
                    }
                }

                if (this.skeletonRenderer.updateWhenInvisible !== Spine.Unity.UpdateMode.FullUpdate) {
                    this.skeletonRenderer.LateUpdateMesh();
                }
            },
            /*Spine.Unity.SkeletonRenderSeparator.OnEnable end.*/

            /*Spine.Unity.SkeletonRenderSeparator.OnDisable start.*/
            OnDisable: function () {
                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonRenderer, null)) {
                    return;
                }
                this.skeletonRenderer.removeGenerateMeshOverride(Bridge.fn.cacheBind(this, this.HandleRender));
                this.skeletonRenderer.LateUpdateMesh();
                this.ClearPartsRendererMeshes();
            },
            /*Spine.Unity.SkeletonRenderSeparator.OnDisable end.*/

            /*Spine.Unity.SkeletonRenderSeparator.HandleRender start.*/
            HandleRender: function (instruction) {
                var $t;
                var rendererCount = this.partsRenderers.Count;
                if (rendererCount <= 0) {
                    return;
                }

                var assignPropertyBlock = this.copyPropertyBlock && this.mainMeshRenderer.HasPropertyBlock();
                if (assignPropertyBlock) {
                    this.mainMeshRenderer.GetPropertyBlock(this.copiedBlock);
                }

                var settings = ($t = new Spine.Unity.MeshGenerator.Settings(), $t.addNormals = this.skeletonRenderer.addNormals, $t.calculateTangents = this.skeletonRenderer.calculateTangents, $t.immutableTriangles = false, $t.pmaVertexColors = this.skeletonRenderer.pmaVertexColors, $t.tintBlack = this.skeletonRenderer.tintBlack, $t.useClipping = true, $t.zSpacing = this.skeletonRenderer.zSpacing, $t);

                var submeshInstructions = instruction.submeshInstructions;
                var submeshInstructionsItems = submeshInstructions.Items;
                var lastSubmeshInstruction = (submeshInstructions.Count - 1) | 0;

                var rendererIndex = 0;
                var currentRenderer = this.partsRenderers.getItem(rendererIndex);
                for (var si = 0, start = 0; si <= lastSubmeshInstruction; si = (si + 1) | 0) {
                    if (UnityEngine.MonoBehaviour.op_Equality(currentRenderer, null)) {
                        continue;
                    }
                    if (submeshInstructionsItems[si].forceSeparate || si === lastSubmeshInstruction) {
                        // Apply properties
                        var meshGenerator = currentRenderer.MeshGenerator;
                        meshGenerator.settings = settings.$clone();

                        if (assignPropertyBlock) {
                            currentRenderer.SetPropertyBlock(this.copiedBlock);
                        }
                        // Render
                        currentRenderer.RenderParts(instruction.submeshInstructions, start, ((si + 1) | 0));

                        start = (si + 1) | 0;
                        rendererIndex = (rendererIndex + 1) | 0;
                        if (rendererIndex < rendererCount) {
                            currentRenderer = this.partsRenderers.getItem(rendererIndex);
                        } else {
                            // Not enough renderers. Skip the rest of the instructions.
                            break;
                        }
                    }
                }

                if (!Bridge.staticEquals(this.OnMeshAndMaterialsUpdated, null)) {
                    this.OnMeshAndMaterialsUpdated(this.skeletonRenderer);
                }

                // Clear extra renderers if they exist.
                for (; rendererIndex < rendererCount; rendererIndex = (rendererIndex + 1) | 0) {
                    currentRenderer = this.partsRenderers.getItem(rendererIndex);
                    if (UnityEngine.MonoBehaviour.op_Inequality(currentRenderer, null)) {
                        this.partsRenderers.getItem(rendererIndex).ClearMesh();
                    }
                }
            },
            /*Spine.Unity.SkeletonRenderSeparator.HandleRender end.*/

            /*Spine.Unity.SkeletonRenderSeparator.ClearPartsRendererMeshes start.*/
            ClearPartsRendererMeshes: function () {
                var $t;
                $t = Bridge.getEnumerator(this.partsRenderers);
                try {
                    while ($t.moveNext()) {
                        var partsRenderer = $t.Current;
                        if (UnityEngine.MonoBehaviour.op_Inequality(partsRenderer, null)) {
                            partsRenderer.ClearMesh();
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.Unity.SkeletonRenderSeparator.ClearPartsRendererMeshes end.*/


        }
    });
    /*Spine.Unity.SkeletonRenderSeparator end.*/

    /*Spine.Unity.SkeletonRootMotionBase+RootMotionInfo start.*/
    Bridge.define("Spine.Unity.SkeletonRootMotionBase.RootMotionInfo", {
        $kind: 1004,
        statics: {
            methods: {
                getDefaultValue: function () { return new Spine.Unity.SkeletonRootMotionBase.RootMotionInfo(); }
            }
        },
        fields: {
            start: null,
            current: null,
            mid: null,
            end: null,
            timeIsPastMid: false
        },
        ctors: {
            init: function () {
                this.start = new UnityEngine.Vector2();
                this.current = new UnityEngine.Vector2();
                this.mid = new UnityEngine.Vector2();
                this.end = new UnityEngine.Vector2();
            },
            ctor: function () {
                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
                var h = Bridge.addHash([5573033076, this.start, this.current, this.mid, this.end, this.timeIsPastMid]);
                return h;
            },
            equals: function (o) {
                if (!Bridge.is(o, Spine.Unity.SkeletonRootMotionBase.RootMotionInfo)) {
                    return false;
                }
                return Bridge.equals(this.start, o.start) && Bridge.equals(this.current, o.current) && Bridge.equals(this.mid, o.mid) && Bridge.equals(this.end, o.end) && Bridge.equals(this.timeIsPastMid, o.timeIsPastMid);
            },
            $clone: function (to) {
                var s = to || new Spine.Unity.SkeletonRootMotionBase.RootMotionInfo();
                s.start = this.start.$clone();
                s.current = this.current.$clone();
                s.mid = this.mid.$clone();
                s.end = this.end.$clone();
                s.timeIsPastMid = this.timeIsPastMid;
                return s;
            }
        }
    });
    /*Spine.Unity.SkeletonRootMotionBase+RootMotionInfo end.*/

    /*Spine.Unity.SkeletonSubmeshGraphic start.*/
    /**
     * A minimal MaskableGraphic subclass for rendering multiple submeshes
     at a {@link }.
     *
     * @public
     * @class Spine.Unity.SkeletonSubmeshGraphic
     * @augments UnityEngine.UI.MaskableGraphic
     */
    Bridge.define("Spine.Unity.SkeletonSubmeshGraphic", {
        inherits: [UnityEngine.UI.MaskableGraphic],
        methods: {
            /*Spine.Unity.SkeletonSubmeshGraphic.SetMaterialDirty start.*/
            SetMaterialDirty: function () { },
            /*Spine.Unity.SkeletonSubmeshGraphic.SetMaterialDirty end.*/

            /*Spine.Unity.SkeletonSubmeshGraphic.SetVerticesDirty start.*/
            SetVerticesDirty: function () { },
            /*Spine.Unity.SkeletonSubmeshGraphic.SetVerticesDirty end.*/

            /*Spine.Unity.SkeletonSubmeshGraphic.OnPopulateMesh start.*/
            OnPopulateMesh: function (vh) {
                vh.Clear();
            },
            /*Spine.Unity.SkeletonSubmeshGraphic.OnPopulateMesh end.*/

            /*Spine.Unity.SkeletonSubmeshGraphic.OnDisable start.*/
            OnDisable: function () {
                UnityEngine.UI.MaskableGraphic.prototype.OnDisable.call(this);
                this.canvasRenderer.cull = true;
            },
            /*Spine.Unity.SkeletonSubmeshGraphic.OnDisable end.*/

            /*Spine.Unity.SkeletonSubmeshGraphic.OnEnable start.*/
            OnEnable: function () {
                UnityEngine.UI.MaskableGraphic.prototype.OnEnable.call(this);
                this.canvasRenderer.cull = false;
            },
            /*Spine.Unity.SkeletonSubmeshGraphic.OnEnable end.*/


        }
    });
    /*Spine.Unity.SkeletonSubmeshGraphic end.*/

    /*Spine.Unity.SkeletonUtility start.*/
    Bridge.define("Spine.Unity.SkeletonUtility", {
        inherits: [UnityEngine.MonoBehaviour],
        statics: {
            methods: {
                /*Spine.Unity.SkeletonUtility.AddBoundingBoxGameObject:static start.*/
                AddBoundingBoxGameObject: function (skeleton, skinName, slotName, attachmentName, parent, isTrigger) {
                    if (isTrigger === void 0) { isTrigger = true; }
                    var skin = System.String.isNullOrEmpty(skinName) ? skeleton.data.defaultSkin : skeleton.data.findSkin(skinName);
                    if (skin == null) {
                        UnityEngine.Debug.LogError$2("Skin " + (skinName || "") + " not found!");
                        return null;
                    }

                    var slot = skeleton.findSlot(slotName);
                    var attachment = slot != null ? skin.getAttachment(slot.data.index, attachmentName) : null;
                    if (attachment == null) {
                        UnityEngine.Debug.LogFormat("Attachment in slot '{0}' named '{1}' not found in skin '{2}'.", [slotName, attachmentName, skin.name]);
                        return null;
                    }

                    var box = Bridge.as(attachment, spine.BoundingBoxAttachment);
                    if (box != null) {
                        return Spine.Unity.SkeletonUtility.AddBoundingBoxGameObject$1(box.name, box, slot, parent, isTrigger);
                    } else {
                        UnityEngine.Debug.LogFormat("Attachment '{0}' was not a Bounding Box.", [attachmentName]);
                        return null;
                    }
                },
                /*Spine.Unity.SkeletonUtility.AddBoundingBoxGameObject:static end.*/

                /*Spine.Unity.SkeletonUtility.AddBoundingBoxGameObject$1:static start.*/
                AddBoundingBoxGameObject$1: function (name, box, slot, parent, isTrigger) {
                    if (isTrigger === void 0) { isTrigger = true; }
                    var go = new UnityEngine.GameObject.$ctor2("[BoundingBox]" + ((System.String.isNullOrEmpty(name) ? box.name : name) || ""));
                    var got = go.transform;
                    got.parent = parent;
                    got.localPosition = pc.Vec3.ZERO.clone();
                    got.localRotation = pc.Quat.IDENTITY.clone();
                    got.localScale = new pc.Vec3( 1, 1, 1 );
                    return Spine.Unity.SkeletonUtility.AddBoundingBoxAsComponent(box, slot, go, isTrigger);
                },
                /*Spine.Unity.SkeletonUtility.AddBoundingBoxGameObject$1:static end.*/

                /*Spine.Unity.SkeletonUtility.AddBoundingBoxAsComponent:static start.*/
                AddBoundingBoxAsComponent: function (box, slot, gameObject, isTrigger) {
                    if (isTrigger === void 0) { isTrigger = true; }
                    if (box == null) {
                        return null;
                    }
                    var collider = gameObject.AddComponent(UnityEngine.PolygonCollider2D);
                    collider.isTrigger = isTrigger;
                    Spine.Unity.SkeletonUtility.SetColliderPointsLocal(collider, slot, box);
                    return collider;
                },
                /*Spine.Unity.SkeletonUtility.AddBoundingBoxAsComponent:static end.*/

                /*Spine.Unity.SkeletonUtility.SetColliderPointsLocal:static start.*/
                SetColliderPointsLocal: function (collider, slot, box, scale) {
                    if (scale === void 0) { scale = 1.0; }
                    if (box == null) {
                        return;
                    }
                    if (Spine.SpineSkeletonExtensions.IsWeighted(box)) {
                        UnityEngine.Debug.LogWarning$1("UnityEngine.PolygonCollider2D does not support weighted or animated points. Collider points will not be animated and may have incorrect orientation. If you want to use it as a collider, please remove weights and animations from the bounding box in Spine editor.");
                    }
                    var verts = Spine.Unity.SkeletonExtensions.GetLocalVertices(box, slot, null);
                    if (scale !== 1.0) {
                        for (var i = 0, n = verts.length; i < n; i = (i + 1) | 0) {
                            verts[i] = verts[i].$clone().scale( scale );
                        }
                    }
                    collider.SetPath$1(0, verts);
                },
                /*Spine.Unity.SkeletonUtility.SetColliderPointsLocal:static end.*/

                /*Spine.Unity.SkeletonUtility.GetBoundingBoxBounds:static start.*/
                GetBoundingBoxBounds: function (boundingBox, depth) {
                    if (depth === void 0) { depth = 0.0; }
                    var floats = boundingBox.vertices;
                    var floatCount = floats.length;

                    var bounds = new pc.BoundingBox.ctor();

                    bounds.center = new pc.Vec3( floats[0], floats[1], 0 );
                    for (var i = 2; i < floatCount; i = (i + 2) | 0) {
                        bounds.expandToPoint( new pc.Vec3( floats[i], floats[((i + 1) | 0)], 0 ) );
                    }

                    var size = bounds.halfExtents.$clone().scale( 2 ).$clone();
                    size.z = depth;
                    bounds.halfExtents = size.$clone().$clone().scale( 0.5 );

                    return bounds;
                },
                /*Spine.Unity.SkeletonUtility.GetBoundingBoxBounds:static end.*/

                /*Spine.Unity.SkeletonUtility.AddBoneRigidbody2D:static start.*/
                AddBoneRigidbody2D: function (gameObject, isKinematic, gravityScale) {
                    if (isKinematic === void 0) { isKinematic = true; }
                    if (gravityScale === void 0) { gravityScale = 0.0; }
                    var rb = gameObject.GetComponent(UnityEngine.Rigidbody2D);
                    if (UnityEngine.Component.op_Equality(rb, null)) {
                        rb = gameObject.AddComponent(UnityEngine.Rigidbody2D);
                        rb.isKinematic = isKinematic;
                        rb.gravityScale = gravityScale;
                    }
                    return rb;
                },
                /*Spine.Unity.SkeletonUtility.AddBoneRigidbody2D:static end.*/


            }
        },
        fields: {
            boneRoot: null,
            /**
             * If true, {@link } and {@link } are followed
             by 180 degree rotation. If false, negative Transform scale is used.
             Note that using negative scale is consistent with previous behaviour (hence the default),
             however causes serious problems with rigidbodies and physics. Therefore, it is recommended to
             enable this parameter where possible. When creating hinge chains for a chain of skeleton bones
             via {@link }, it is mandatory to have <pre><code>flipBy180DegreeRotation</code></pre> enabled.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonUtility
             * @default false
             * @type boolean
             */
            flipBy180DegreeRotation: false,
            skeletonRenderer: null,
            skeletonGraphic: null,
            skeletonAnimation: null,
            skeletonComponent: null,
            boneComponents: null,
            constraintComponents: null,
            positionScale: 0,
            hasOverrideBones: false,
            hasConstraints: false,
            needToReprocessBones: false
        },
        events: {
            OnReset: null
        },
        props: {
            SkeletonComponent: {
                get: function () {
                    if (this.skeletonComponent == null) {
                        this.skeletonComponent = UnityEngine.MonoBehaviour.op_Inequality(this.skeletonRenderer, null) ? this.skeletonRenderer.GetComponent(Spine.Unity.ISkeletonComponent) : UnityEngine.MonoBehaviour.op_Inequality(this.skeletonGraphic, null) ? this.skeletonGraphic.GetComponent(Spine.Unity.ISkeletonComponent) : this.GetComponent(Spine.Unity.ISkeletonComponent);
                    }
                    return this.skeletonComponent;
                }
            },
            Skeleton: {
                get: function () {
                    if (this.SkeletonComponent == null) {
                        return null;
                    }
                    return this.skeletonComponent.Spine$Unity$ISkeletonComponent$Skeleton;
                }
            },
            IsValid: {
                get: function () {
                    return (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonRenderer, null) && this.skeletonRenderer.valid) || (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonGraphic, null) && this.skeletonGraphic.IsValid);
                }
            },
            PositionScale: {
                get: function () {
                    return this.positionScale;
                }
            }
        },
        ctors: {
            init: function () {
                this.flipBy180DegreeRotation = false;
                this.boneComponents = new (System.Collections.Generic.List$1(Spine.Unity.SkeletonUtilityBone)).ctor();
                this.constraintComponents = new (System.Collections.Generic.List$1(Spine.Unity.SkeletonUtilityConstraint)).ctor();
                this.positionScale = 1.0;
            }
        },
        methods: {
            /*Spine.Unity.SkeletonUtility.Update start.*/
            Update: function () {
                var skeleton = this.skeletonComponent.Spine$Unity$ISkeletonComponent$Skeleton;
                if (skeleton != null && UnityEngine.Component.op_Inequality(this.boneRoot, null)) {

                    if (this.flipBy180DegreeRotation) {
                        this.boneRoot.localScale = new pc.Vec3( Math.abs(skeleton.scaleX), Math.abs(skeleton.scaleY), 1.0 );
                        this.boneRoot.eulerAngles = new pc.Vec3( skeleton.scaleY > 0 ? 0 : 180, skeleton.scaleX > 0 ? 0 : 180, 0 );
                    } else {
                        this.boneRoot.localScale = new pc.Vec3( skeleton.scaleX, skeleton.scaleY, 1.0 );
                    }
                }

                if (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonGraphic, null)) {
                    this.positionScale = this.skeletonGraphic.MeshScale;
                }
            },
            /*Spine.Unity.SkeletonUtility.Update end.*/

            /*Spine.Unity.SkeletonUtility.ResubscribeEvents start.*/
            ResubscribeEvents: function () {
                this.OnDisable();
                this.OnEnable();
            },
            /*Spine.Unity.SkeletonUtility.ResubscribeEvents end.*/

            /*Spine.Unity.SkeletonUtility.OnEnable start.*/
            OnEnable: function () {
                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonRenderer, null)) {
                    this.skeletonRenderer = this.GetComponent(Spine.Unity.SkeletonRenderer);
                }
                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonGraphic, null)) {
                    this.skeletonGraphic = this.GetComponent(Spine.Unity.SkeletonGraphic);
                }
                if (this.skeletonAnimation == null) {
                    this.skeletonAnimation = UnityEngine.MonoBehaviour.op_Inequality(this.skeletonRenderer, null) ? this.skeletonRenderer.GetComponent(Spine.Unity.ISkeletonAnimation) : UnityEngine.MonoBehaviour.op_Inequality(this.skeletonGraphic, null) ? this.skeletonGraphic.GetComponent(Spine.Unity.ISkeletonAnimation) : this.GetComponent(Spine.Unity.ISkeletonAnimation);
                }
                if (this.skeletonComponent == null) {
                    this.skeletonComponent = UnityEngine.MonoBehaviour.op_Inequality(this.skeletonRenderer, null) ? this.skeletonRenderer.GetComponent(Spine.Unity.ISkeletonComponent) : UnityEngine.MonoBehaviour.op_Inequality(this.skeletonGraphic, null) ? this.skeletonGraphic.GetComponent(Spine.Unity.ISkeletonComponent) : this.GetComponent(Spine.Unity.ISkeletonComponent);
                }

                if (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonRenderer, null)) {
                    this.skeletonRenderer.removeOnRebuild(Bridge.fn.cacheBind(this, this.HandleRendererReset$1));
                    this.skeletonRenderer.addOnRebuild(Bridge.fn.cacheBind(this, this.HandleRendererReset$1));
                } else if (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonGraphic, null)) {
                    this.skeletonGraphic.removeOnRebuild(Bridge.fn.cacheBind(this, this.HandleRendererReset));
                    this.skeletonGraphic.addOnRebuild(Bridge.fn.cacheBind(this, this.HandleRendererReset));
                }

                if (this.skeletonAnimation != null) {
                    this.skeletonAnimation.Spine$Unity$ISkeletonAnimation$removeUpdateLocal(Bridge.fn.cacheBind(this, this.UpdateLocal));
                    this.skeletonAnimation.Spine$Unity$ISkeletonAnimation$addUpdateLocal(Bridge.fn.cacheBind(this, this.UpdateLocal));
                }

                this.CollectBones();
            },
            /*Spine.Unity.SkeletonUtility.OnEnable end.*/

            /*Spine.Unity.SkeletonUtility.Start start.*/
            Start: function () {
                //recollect because order of operations failure when switching between game mode and edit mode...
                this.CollectBones();
            },
            /*Spine.Unity.SkeletonUtility.Start end.*/

            /*Spine.Unity.SkeletonUtility.OnDisable start.*/
            OnDisable: function () {
                if (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonRenderer, null)) {
                    this.skeletonRenderer.removeOnRebuild(Bridge.fn.cacheBind(this, this.HandleRendererReset$1));
                }
                if (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonGraphic, null)) {
                    this.skeletonGraphic.removeOnRebuild(Bridge.fn.cacheBind(this, this.HandleRendererReset));
                }

                if (this.skeletonAnimation != null) {
                    this.skeletonAnimation.Spine$Unity$ISkeletonAnimation$removeUpdateLocal(Bridge.fn.cacheBind(this, this.UpdateLocal));
                    this.skeletonAnimation.Spine$Unity$ISkeletonAnimation$removeUpdateWorld(Bridge.fn.cacheBind(this, this.UpdateWorld));
                    this.skeletonAnimation.Spine$Unity$ISkeletonAnimation$removeUpdateComplete(Bridge.fn.cacheBind(this, this.UpdateComplete));
                }
            },
            /*Spine.Unity.SkeletonUtility.OnDisable end.*/

            /*Spine.Unity.SkeletonUtility.HandleRendererReset$1 start.*/
            HandleRendererReset$1: function (r) {
                if (!Bridge.staticEquals(this.OnReset, null)) {
                    this.OnReset();
                }
                this.CollectBones();
            },
            /*Spine.Unity.SkeletonUtility.HandleRendererReset$1 end.*/

            /*Spine.Unity.SkeletonUtility.HandleRendererReset start.*/
            HandleRendererReset: function (g) {
                if (!Bridge.staticEquals(this.OnReset, null)) {
                    this.OnReset();
                }
                this.CollectBones();
            },
            /*Spine.Unity.SkeletonUtility.HandleRendererReset end.*/

            /*Spine.Unity.SkeletonUtility.RegisterBone start.*/
            RegisterBone: function (bone) {
                if (this.boneComponents.contains(bone)) {
                    return;
                } else {
                    this.boneComponents.add(bone);
                    this.needToReprocessBones = true;
                }
            },
            /*Spine.Unity.SkeletonUtility.RegisterBone end.*/

            /*Spine.Unity.SkeletonUtility.UnregisterBone start.*/
            UnregisterBone: function (bone) {
                this.boneComponents.remove(bone);
            },
            /*Spine.Unity.SkeletonUtility.UnregisterBone end.*/

            /*Spine.Unity.SkeletonUtility.RegisterConstraint start.*/
            RegisterConstraint: function (constraint) {
                if (this.constraintComponents.contains(constraint)) {
                    return;
                } else {
                    this.constraintComponents.add(constraint);
                    this.needToReprocessBones = true;
                }
            },
            /*Spine.Unity.SkeletonUtility.RegisterConstraint end.*/

            /*Spine.Unity.SkeletonUtility.UnregisterConstraint start.*/
            UnregisterConstraint: function (constraint) {
                this.constraintComponents.remove(constraint);
            },
            /*Spine.Unity.SkeletonUtility.UnregisterConstraint end.*/

            /*Spine.Unity.SkeletonUtility.CollectBones start.*/
            CollectBones: function () {
                var skeleton = this.skeletonComponent.Spine$Unity$ISkeletonComponent$Skeleton;
                if (skeleton == null) {
                    return;
                }

                if (UnityEngine.Component.op_Inequality(this.boneRoot, null)) {
                    var constraintTargets = new (System.Collections.Generic.List$1(System.Object)).ctor();
                    var ikConstraints = skeleton.IkConstraints;
                    for (var i = 0, n = ikConstraints.Count; i < n; i = (i + 1) | 0) {
                        constraintTargets.add(ikConstraints.Items[i].target);
                    }

                    var transformConstraints = skeleton.TransformConstraints;
                    for (var i1 = 0, n1 = transformConstraints.Count; i1 < n1; i1 = (i1 + 1) | 0) {
                        constraintTargets.add(transformConstraints.Items[i1].target);
                    }

                    var boneComponents = this.boneComponents;
                    for (var i2 = 0, n2 = boneComponents.Count; i2 < n2; i2 = (i2 + 1) | 0) {
                        var b = boneComponents.getItem(i2);
                        if (b.bone == null) {
                            b.DoUpdate(Spine.Unity.SkeletonUtilityBone.UpdatePhase.Local);
                            if (b.bone == null) {
                                continue;
                            }
                        }
                        this.hasOverrideBones = !!(this.hasOverrideBones | (b.mode === Spine.Unity.SkeletonUtilityBone.Mode.Override));
                        this.hasConstraints = !!(this.hasConstraints | constraintTargets.contains(b.bone));
                    }

                    this.hasConstraints = !!(this.hasConstraints | this.constraintComponents.Count > 0);

                    if (this.skeletonAnimation != null) {
                        this.skeletonAnimation.Spine$Unity$ISkeletonAnimation$removeUpdateWorld(Bridge.fn.cacheBind(this, this.UpdateWorld));
                        this.skeletonAnimation.Spine$Unity$ISkeletonAnimation$removeUpdateComplete(Bridge.fn.cacheBind(this, this.UpdateComplete));

                        if (this.hasOverrideBones || this.hasConstraints) {
                            this.skeletonAnimation.Spine$Unity$ISkeletonAnimation$addUpdateWorld(Bridge.fn.cacheBind(this, this.UpdateWorld));
                        }

                        if (this.hasConstraints) {
                            this.skeletonAnimation.Spine$Unity$ISkeletonAnimation$addUpdateComplete(Bridge.fn.cacheBind(this, this.UpdateComplete));
                        }
                    }

                    this.needToReprocessBones = false;
                } else {
                    this.boneComponents.clear();
                    this.constraintComponents.clear();
                }
            },
            /*Spine.Unity.SkeletonUtility.CollectBones end.*/

            /*Spine.Unity.SkeletonUtility.UpdateLocal start.*/
            UpdateLocal: function (anim) {
                if (this.needToReprocessBones) {
                    this.CollectBones();
                }

                var boneComponents = this.boneComponents;
                if (boneComponents == null) {
                    return;
                }
                for (var i = 0, n = boneComponents.Count; i < n; i = (i + 1) | 0) {
                    boneComponents.getItem(i).transformLerpComplete = false;
                }

                this.UpdateAllBones(Spine.Unity.SkeletonUtilityBone.UpdatePhase.Local);
            },
            /*Spine.Unity.SkeletonUtility.UpdateLocal end.*/

            /*Spine.Unity.SkeletonUtility.UpdateWorld start.*/
            UpdateWorld: function (anim) {
                this.UpdateAllBones(Spine.Unity.SkeletonUtilityBone.UpdatePhase.World);
                for (var i = 0, n = this.constraintComponents.Count; i < n; i = (i + 1) | 0) {
                    this.constraintComponents.getItem(i).DoUpdate();
                }
            },
            /*Spine.Unity.SkeletonUtility.UpdateWorld end.*/

            /*Spine.Unity.SkeletonUtility.UpdateComplete start.*/
            UpdateComplete: function (anim) {
                this.UpdateAllBones(Spine.Unity.SkeletonUtilityBone.UpdatePhase.Complete);
            },
            /*Spine.Unity.SkeletonUtility.UpdateComplete end.*/

            /*Spine.Unity.SkeletonUtility.UpdateAllBones start.*/
            UpdateAllBones: function (phase) {
                if (UnityEngine.Component.op_Equality(this.boneRoot, null)) {
                    this.CollectBones();
                }

                var boneComponents = this.boneComponents;
                if (boneComponents == null) {
                    return;
                }
                for (var i = 0, n = boneComponents.Count; i < n; i = (i + 1) | 0) {
                    boneComponents.getItem(i).DoUpdate(phase);
                }
            },
            /*Spine.Unity.SkeletonUtility.UpdateAllBones end.*/

            /*Spine.Unity.SkeletonUtility.GetBoneRoot start.*/
            GetBoneRoot: function () {
                if (UnityEngine.Component.op_Inequality(this.boneRoot, null)) {
                    return this.boneRoot;
                }

                var boneRootObject = new UnityEngine.GameObject.$ctor2("SkeletonUtility-SkeletonRoot");
                if (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonGraphic, null)) {
                    boneRootObject.AddComponent(UnityEngine.RectTransform);
                }

                this.boneRoot = boneRootObject.transform;
                this.boneRoot.SetParent(this.transform);
                this.boneRoot.localPosition = pc.Vec3.ZERO.clone();
                this.boneRoot.localRotation = pc.Quat.IDENTITY.clone();
                this.boneRoot.localScale = new pc.Vec3( 1, 1, 1 );

                return this.boneRoot;
            },
            /*Spine.Unity.SkeletonUtility.GetBoneRoot end.*/

            /*Spine.Unity.SkeletonUtility.SpawnRoot start.*/
            SpawnRoot: function (mode, pos, rot, sca) {
                this.GetBoneRoot();
                var skeleton = this.skeletonComponent.Spine$Unity$ISkeletonComponent$Skeleton;

                var go = this.SpawnBone(skeleton.getRootBone(), this.boneRoot, mode, pos, rot, sca);
                this.CollectBones();
                return go;
            },
            /*Spine.Unity.SkeletonUtility.SpawnRoot end.*/

            /*Spine.Unity.SkeletonUtility.SpawnHierarchy start.*/
            SpawnHierarchy: function (mode, pos, rot, sca) {
                this.GetBoneRoot();
                var skeleton = this.skeletonComponent.Spine$Unity$ISkeletonComponent$Skeleton;
                var go = this.SpawnBoneRecursively(skeleton.getRootBone(), this.boneRoot, mode, pos, rot, sca);
                this.CollectBones();
                return go;
            },
            /*Spine.Unity.SkeletonUtility.SpawnHierarchy end.*/

            /*Spine.Unity.SkeletonUtility.SpawnBoneRecursively start.*/
            SpawnBoneRecursively: function (bone, parent, mode, pos, rot, sca) {
                var go = this.SpawnBone(bone, parent, mode, pos, rot, sca);

                var childrenBones = bone.Children;
                for (var i = 0, n = childrenBones.Count; i < n; i = (i + 1) | 0) {
                    var child = childrenBones.Items[i];
                    this.SpawnBoneRecursively(child, go.transform, mode, pos, rot, sca);
                }

                return go;
            },
            /*Spine.Unity.SkeletonUtility.SpawnBoneRecursively end.*/

            /*Spine.Unity.SkeletonUtility.SpawnBone start.*/
            SpawnBone: function (bone, parent, mode, pos, rot, sca) {
                var go = new UnityEngine.GameObject.$ctor2(bone.data.name);
                if (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonGraphic, null)) {
                    go.AddComponent(UnityEngine.RectTransform);
                }

                var goTransform = go.transform;
                goTransform.SetParent(parent);

                var b = go.AddComponent(Spine.Unity.SkeletonUtilityBone);
                b.hierarchy = this;
                b.position = pos;
                b.rotation = rot;
                b.scale = sca;
                b.mode = mode;
                b.zPosition = true;
                b.Reset();
                b.bone = bone;
                b.boneName = bone.data.name;
                b.valid = true;

                if (mode === Spine.Unity.SkeletonUtilityBone.Mode.Override) {
                    if (rot) {
                        goTransform.localRotation = new pc.Quat().setFromEulerAngles_Unity( 0, 0, b.bone.arotation );
                    }
                    if (pos) {
                        goTransform.localPosition = new pc.Vec3( b.bone.x * this.positionScale, b.bone.y * this.positionScale, 0 );
                    }
                    goTransform.localScale = new pc.Vec3( b.bone.scaleX, b.bone.scaleY, 0 );
                }

                return go;
            },
            /*Spine.Unity.SkeletonUtility.SpawnBone end.*/


        },
        overloads: {
            "HandleRendererReset(SkeletonRenderer)": "HandleRendererReset$1"
        }
    });
    /*Spine.Unity.SkeletonUtility end.*/

    /*Spine.Unity.SkeletonUtilityBone start.*/
    /**
     * Sets a GameObject's transform to match a bone on a Spine skeleton.
     *
     * @public
     * @class Spine.Unity.SkeletonUtilityBone
     * @augments UnityEngine.MonoBehaviour
     */
    Bridge.define("Spine.Unity.SkeletonUtilityBone", {
        inherits: [UnityEngine.MonoBehaviour],
        statics: {
            methods: {
                /*Spine.Unity.SkeletonUtilityBone.BoneTransformModeIncompatible:static start.*/
                BoneTransformModeIncompatible: function (bone) {
                    return !Spine.SpineSkeletonExtensions.InheritsScale(bone.data.transformMode);
                },
                /*Spine.Unity.SkeletonUtilityBone.BoneTransformModeIncompatible:static end.*/


            }
        },
        fields: {
            /**
             * If a bone isn't set, boneName is used to find the bone.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonUtilityBone
             * @type string
             */
            boneName: null,
            parentReference: null,
            mode: 0,
            position: false,
            rotation: false,
            scale: false,
            zPosition: false,
            overrideAlpha: 0,
            hierarchy: null,
            bone: null,
            transformLerpComplete: false,
            valid: false,
            cachedTransform: null,
            skeletonTransform: null,
            incompatibleTransformMode: false
        },
        props: {
            IncompatibleTransformMode: {
                get: function () {
                    return this.incompatibleTransformMode;
                }
            }
        },
        ctors: {
            init: function () {
                this.zPosition = true;
                this.overrideAlpha = 1;
            }
        },
        methods: {
            /*Spine.Unity.SkeletonUtilityBone.Reset start.*/
            Reset: function () {
                this.bone = null;
                this.cachedTransform = this.transform;
                this.valid = UnityEngine.MonoBehaviour.op_Inequality(this.hierarchy, null) && this.hierarchy.IsValid;
                if (!this.valid) {
                    return;
                }
                this.skeletonTransform = this.hierarchy.transform;
                this.hierarchy.removeOnReset(Bridge.fn.cacheBind(this, this.HandleOnReset));
                this.hierarchy.addOnReset(Bridge.fn.cacheBind(this, this.HandleOnReset));
                this.DoUpdate(Spine.Unity.SkeletonUtilityBone.UpdatePhase.Local);
            },
            /*Spine.Unity.SkeletonUtilityBone.Reset end.*/

            /*Spine.Unity.SkeletonUtilityBone.OnEnable start.*/
            OnEnable: function () {
                if (UnityEngine.MonoBehaviour.op_Equality(this.hierarchy, null)) {
                    this.hierarchy = this.transform.GetComponentInParent(Spine.Unity.SkeletonUtility);
                }
                if (UnityEngine.MonoBehaviour.op_Equality(this.hierarchy, null)) {
                    return;
                }

                this.hierarchy.RegisterBone(this);
                this.hierarchy.addOnReset(Bridge.fn.cacheBind(this, this.HandleOnReset));
            },
            /*Spine.Unity.SkeletonUtilityBone.OnEnable end.*/

            /*Spine.Unity.SkeletonUtilityBone.HandleOnReset start.*/
            HandleOnReset: function () {
                this.Reset();
            },
            /*Spine.Unity.SkeletonUtilityBone.HandleOnReset end.*/

            /*Spine.Unity.SkeletonUtilityBone.OnDisable start.*/
            OnDisable: function () {
                if (UnityEngine.MonoBehaviour.op_Inequality(this.hierarchy, null)) {
                    this.hierarchy.removeOnReset(Bridge.fn.cacheBind(this, this.HandleOnReset));
                    this.hierarchy.UnregisterBone(this);
                }
            },
            /*Spine.Unity.SkeletonUtilityBone.OnDisable end.*/

            /*Spine.Unity.SkeletonUtilityBone.DoUpdate start.*/
            DoUpdate: function (phase) {
                var $t;
                if (!this.valid) {
                    this.Reset();
                    return;
                }

                var skeleton = this.hierarchy.Skeleton;

                if (this.bone == null) {
                    if (System.String.isNullOrEmpty(this.boneName)) {
                        return;
                    }
                    this.bone = skeleton.findBone(this.boneName);
                    if (this.bone == null) {
                        UnityEngine.Debug.LogError$2("Bone not found: " + (this.boneName || ""), this);
                        return;
                    }
                }
                if (!this.bone.isActive()) {
                    return;
                }

                var positionScale = this.hierarchy.PositionScale;

                var thisTransform = this.cachedTransform;
                var skeletonFlipRotation = ($t = skeleton.scaleX * skeleton.scaleY, ($t === 0 ? 1 : Math.sign($t)));
                if (this.mode === Spine.Unity.SkeletonUtilityBone.Mode.Follow) {
                    switch (phase) {
                        case Spine.Unity.SkeletonUtilityBone.UpdatePhase.Local: 
                            if (this.position) {
                                thisTransform.localPosition = new pc.Vec3( this.bone.x * positionScale, this.bone.y * positionScale, 0 );
                            }
                            if (this.rotation) {
                                if (Spine.SpineSkeletonExtensions.InheritsRotation(this.bone.data.transformMode)) {
                                    thisTransform.localRotation = new pc.Quat().setFromEulerAngles_Unity( 0, 0, this.bone.rotation );
                                } else {
                                    var euler = this.skeletonTransform.rotation.getPositiveEulerAngles().$clone();
                                    thisTransform.rotation = new pc.Quat().setFromEulerAngles_Unity( euler.x, euler.y, euler.z + (this.bone.getWorldRotationX() * skeletonFlipRotation) );
                                }
                            }
                            if (this.scale) {
                                thisTransform.localScale = new pc.Vec3( this.bone.scaleX, this.bone.scaleY, 1.0 );
                                this.incompatibleTransformMode = Spine.Unity.SkeletonUtilityBone.BoneTransformModeIncompatible(this.bone);
                            }
                            break;
                        case Spine.Unity.SkeletonUtilityBone.UpdatePhase.World: 
                        case Spine.Unity.SkeletonUtilityBone.UpdatePhase.Complete: 
                            if (this.position) {
                                thisTransform.localPosition = new pc.Vec3( this.bone.ax * positionScale, this.bone.ay * positionScale, 0 );
                            }
                            if (this.rotation) {
                                if (Spine.SpineSkeletonExtensions.InheritsRotation(this.bone.data.transformMode)) {
                                    thisTransform.localRotation = new pc.Quat().setFromEulerAngles_Unity( 0, 0, this.bone.arotation );
                                } else {
                                    var euler1 = this.skeletonTransform.rotation.getPositiveEulerAngles().$clone();
                                    thisTransform.rotation = new pc.Quat().setFromEulerAngles_Unity( euler1.x, euler1.y, euler1.z + (this.bone.getWorldRotationX() * skeletonFlipRotation) );
                                }
                            }
                            if (this.scale) {
                                thisTransform.localScale = new pc.Vec3( this.bone.ascaleX, this.bone.ascaleY, 1.0 );
                                this.incompatibleTransformMode = Spine.Unity.SkeletonUtilityBone.BoneTransformModeIncompatible(this.bone);
                            }
                            break;
                    }

                } else if (this.mode === Spine.Unity.SkeletonUtilityBone.Mode.Override) {
                    if (this.transformLerpComplete) {
                        return;
                    }

                    if (UnityEngine.Component.op_Equality(this.parentReference, null)) {
                        if (this.position) {
                            var clp = thisTransform.localPosition.$clone().scale( 1.0 / ( positionScale ) );
                            this.bone.x = pc.math.lerp(this.bone.x, clp.x, this.overrideAlpha);
                            this.bone.y = pc.math.lerp(this.bone.y, clp.y, this.overrideAlpha);
                        }

                        if (this.rotation) {
                            var angle = UnityEngine.Mathf.LerpAngle(this.bone.rotation, thisTransform.localRotation.getPositiveEulerAngles().z, this.overrideAlpha);
                            this.bone.rotation = angle;
                            this.bone.arotation = angle;
                        }

                        if (this.scale) {
                            var cls = thisTransform.localScale.$clone();
                            this.bone.scaleX = pc.math.lerp(this.bone.scaleX, cls.x, this.overrideAlpha);
                            this.bone.scaleY = pc.math.lerp(this.bone.scaleY, cls.y, this.overrideAlpha);
                        }

                    } else {
                        if (this.transformLerpComplete) {
                            return;
                        }

                        if (this.position) {
                            var pos = this.parentReference.InverseTransformPoint(thisTransform.position).scale( 1.0 / ( positionScale ) );
                            this.bone.x = pc.math.lerp(this.bone.x, pos.x, this.overrideAlpha);
                            this.bone.y = pc.math.lerp(this.bone.y, pos.y, this.overrideAlpha);
                        }

                        if (this.rotation) {
                            var angle1 = UnityEngine.Mathf.LerpAngle(this.bone.rotation, new pc.Quat().setLookAt( new pc.Vec3( 0, 0, 1 ), this.parentReference.InverseTransformDirection(thisTransform.up.$clone()) ).getPositiveEulerAngles().z, this.overrideAlpha);
                            this.bone.rotation = angle1;
                            this.bone.arotation = angle1;
                        }

                        if (this.scale) {
                            var cls1 = thisTransform.localScale.$clone();
                            this.bone.scaleX = pc.math.lerp(this.bone.scaleX, cls1.x, this.overrideAlpha);
                            this.bone.scaleY = pc.math.lerp(this.bone.scaleY, cls1.y, this.overrideAlpha);
                        }

                        this.incompatibleTransformMode = Spine.Unity.SkeletonUtilityBone.BoneTransformModeIncompatible(this.bone);
                    }

                    this.transformLerpComplete = true;
                }
            },
            /*Spine.Unity.SkeletonUtilityBone.DoUpdate end.*/

            /*Spine.Unity.SkeletonUtilityBone.AddBoundingBox start.*/
            AddBoundingBox: function (skinName, slotName, attachmentName) {
                Spine.Unity.SkeletonUtility.AddBoneRigidbody2D(this.transform.gameObject);
                Spine.Unity.SkeletonUtility.AddBoundingBoxGameObject(this.bone.skeleton, skinName, slotName, attachmentName, this.transform);
            },
            /*Spine.Unity.SkeletonUtilityBone.AddBoundingBox end.*/


        }
    });
    /*Spine.Unity.SkeletonUtilityBone end.*/

    /*Spine.Unity.SkeletonUtilityBone+Mode start.*/
    Bridge.define("Spine.Unity.SkeletonUtilityBone.Mode", {
        $kind: 1006,
        statics: {
            fields: {
                Follow: 0,
                Override: 1
            }
        }
    });
    /*Spine.Unity.SkeletonUtilityBone+Mode end.*/

    /*Spine.Unity.SkeletonUtilityBone+UpdatePhase start.*/
    Bridge.define("Spine.Unity.SkeletonUtilityBone.UpdatePhase", {
        $kind: 1006,
        statics: {
            fields: {
                Local: 0,
                World: 1,
                Complete: 2
            }
        }
    });
    /*Spine.Unity.SkeletonUtilityBone+UpdatePhase end.*/

    /*Spine.Unity.SkeletonUtilityConstraint start.*/
    Bridge.define("Spine.Unity.SkeletonUtilityConstraint", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            bone: null,
            hierarchy: null
        },
        methods: {
            /*Spine.Unity.SkeletonUtilityConstraint.OnEnable start.*/
            OnEnable: function () {
                this.bone = this.GetComponent(Spine.Unity.SkeletonUtilityBone);
                this.hierarchy = this.transform.GetComponentInParent(Spine.Unity.SkeletonUtility);
                this.hierarchy.RegisterConstraint(this);
            },
            /*Spine.Unity.SkeletonUtilityConstraint.OnEnable end.*/

            /*Spine.Unity.SkeletonUtilityConstraint.OnDisable start.*/
            OnDisable: function () {
                this.hierarchy.UnregisterConstraint(this);
            },
            /*Spine.Unity.SkeletonUtilityConstraint.OnDisable end.*/


        }
    });
    /*Spine.Unity.SkeletonUtilityConstraint end.*/

    /*Spine.Unity.SpineAttributeBase start.*/
    Bridge.define("Spine.Unity.SpineAttributeBase", {
        inherits: [UnityEngine.PropertyAttribute],
        fields: {
            dataField: null,
            startsWith: null,
            includeNone: false,
            fallbackToTextField: false
        },
        ctors: {
            init: function () {
                this.dataField = "";
                this.startsWith = "";
                this.includeNone = true;
                this.fallbackToTextField = false;
            }
        }
    });
    /*Spine.Unity.SpineAttributeBase end.*/

    /*Spine.Unity.SpineAtlasRegion start.*/
    Bridge.define("Spine.Unity.SpineAtlasRegion", {
        inherits: [UnityEngine.PropertyAttribute],
        fields: {
            atlasAssetField: null
        },
        ctors: {
            ctor: function (atlasAssetField) {
                if (atlasAssetField === void 0) { atlasAssetField = ""; }

                this.$initialize();
                UnityEngine.PropertyAttribute.ctor.call(this);
                this.atlasAssetField = atlasAssetField;
            }
        }
    });
    /*Spine.Unity.SpineAtlasRegion end.*/

    /*Spine.Unity.SpineAttachment+Hierarchy start.*/
    /**
     * A struct that represents 3 strings that help identify and locate an attachment in a skeleton.
     *
     * @public
     * @class Spine.Unity.SpineAttachment.Hierarchy
     */
    Bridge.define("Spine.Unity.SpineAttachment.Hierarchy", {
        $kind: 1004,
        statics: {
            methods: {
                getDefaultValue: function () { return new Spine.Unity.SpineAttachment.Hierarchy(); }
            }
        },
        fields: {
            skin: null,
            slot: null,
            name: null
        },
        ctors: {
            $ctor1: function (fullPath) {
                this.$initialize();
                var chunks = System.String.split(fullPath, System.Array.init([47], System.Char).map(function (i) {{ return String.fromCharCode(i); }}), null, 1);
                if (chunks.length === 0) {
                    this.skin = "";
                    this.slot = "";
                    this.name = "";
                    return;
                } else if (chunks.length < 2) {
                    throw new System.Exception("Cannot generate Attachment Hierarchy from string! Not enough components! [" + (fullPath || "") + "]");
                }
                this.skin = chunks[0];
                this.slot = chunks[1];
                this.name = "";
                for (var i = 2; i < chunks.length; i = (i + 1) | 0) {
                    this.name = (this.name || "") + (chunks[i] || "");
                }
            },
            ctor: function () {
                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
                var h = Bridge.addHash([3670596642, this.skin, this.slot, this.name]);
                return h;
            },
            equals: function (o) {
                if (!Bridge.is(o, Spine.Unity.SpineAttachment.Hierarchy)) {
                    return false;
                }
                return Bridge.equals(this.skin, o.skin) && Bridge.equals(this.slot, o.slot) && Bridge.equals(this.name, o.name);
            },
            $clone: function (to) {
                var s = to || new Spine.Unity.SpineAttachment.Hierarchy();
                s.skin = this.skin;
                s.slot = this.slot;
                s.name = this.name;
                return s;
            }
        }
    });
    /*Spine.Unity.SpineAttachment+Hierarchy end.*/

    /*Spine.Unity.SpineMesh start.*/
    Bridge.define("Spine.Unity.SpineMesh", {
        statics: {
            fields: {
                MeshHideflags: 0
            },
            ctors: {
                init: function () {
                    this.MeshHideflags = 20;
                }
            },
            methods: {
                /*Spine.Unity.SpineMesh.NewSkeletonMesh:static start.*/
                /**
                 * Factory method for creating a new mesh for use in Spine components. This can be called in field initializers.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SpineMesh
                 * @memberof Spine.Unity.SpineMesh
                 * @return  {UnityEngine.Mesh}
                 */
                NewSkeletonMesh: function () {
                    var m = new UnityEngine.Mesh.ctor();
                    m.MarkDynamic();
                    m.name = "Skeleton Mesh";
                    m.hideFlags = Spine.Unity.SpineMesh.MeshHideflags;
                    return m;
                },
                /*Spine.Unity.SpineMesh.NewSkeletonMesh:static end.*/


            }
        }
    });
    /*Spine.Unity.SpineMesh end.*/

    /*Spine.Unity.SpineSpriteAtlasAsset+SavedRegionInfo start.*/
    Bridge.define("Spine.Unity.SpineSpriteAtlasAsset.SavedRegionInfo", {
        $kind: 1002,
        fields: {
            x: 0,
            y: 0,
            width: 0,
            height: 0,
            packingRotation: 0
        }
    });
    /*Spine.Unity.SpineSpriteAtlasAsset+SavedRegionInfo end.*/

    /*Spine.Unity.SubmeshInstruction start.*/
    /**
     * Instructions for how to generate a mesh or submesh: "Render this skeleton's slots: start slot, up to but not including endSlot, using this material."
     *
     * @public
     * @class Spine.Unity.SubmeshInstruction
     */
    Bridge.define("Spine.Unity.SubmeshInstruction", {
        $kind: 4,
        statics: {
            methods: {
                getDefaultValue: function () { return new Spine.Unity.SubmeshInstruction(); }
            }
        },
        fields: {
            skeleton: null,
            startSlot: 0,
            endSlot: 0,
            material: null,
            forceSeparate: false,
            preActiveClippingSlotSource: 0,
            rawTriangleCount: 0,
            rawVertexCount: 0,
            rawFirstVertexIndex: 0,
            hasClipping: false,
            hasPMAAdditiveSlot: false
        },
        props: {
            /**
             * The number of slots in this SubmeshInstruction's range. Not necessarily the number of attachments.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Unity.SubmeshInstruction
             * @function SlotCount
             * @type number
             */
            SlotCount: {
                get: function () {
                    return ((this.endSlot - this.startSlot) | 0);
                }
            }
        },
        ctors: {
            ctor: function () {
                this.$initialize();
            }
        },
        methods: {
            /*Spine.Unity.SubmeshInstruction.toString start.*/
            toString: function () {
                return System.String.format("[SubmeshInstruction: slots {0} to {1}. (Material){2}. preActiveClippingSlotSource:{3}]", Bridge.box(this.startSlot, System.Int32), Bridge.box(((this.endSlot - 1) | 0), System.Int32), this.material == null ? "<none>" : this.material.name, Bridge.box(this.preActiveClippingSlotSource, System.Int32));
            },
            /*Spine.Unity.SubmeshInstruction.toString end.*/

            getHashCode: function () {
                var h = Bridge.addHash([6756249098, this.skeleton, this.startSlot, this.endSlot, this.material, this.forceSeparate, this.preActiveClippingSlotSource, this.rawTriangleCount, this.rawVertexCount, this.rawFirstVertexIndex, this.hasClipping, this.hasPMAAdditiveSlot]);
                return h;
            },
            equals: function (o) {
                if (!Bridge.is(o, Spine.Unity.SubmeshInstruction)) {
                    return false;
                }
                return Bridge.equals(this.skeleton, o.skeleton) && Bridge.equals(this.startSlot, o.startSlot) && Bridge.equals(this.endSlot, o.endSlot) && Bridge.equals(this.material, o.material) && Bridge.equals(this.forceSeparate, o.forceSeparate) && Bridge.equals(this.preActiveClippingSlotSource, o.preActiveClippingSlotSource) && Bridge.equals(this.rawTriangleCount, o.rawTriangleCount) && Bridge.equals(this.rawVertexCount, o.rawVertexCount) && Bridge.equals(this.rawFirstVertexIndex, o.rawFirstVertexIndex) && Bridge.equals(this.hasClipping, o.hasClipping) && Bridge.equals(this.hasPMAAdditiveSlot, o.hasPMAAdditiveSlot);
            },
            $clone: function (to) {
                var s = to || new Spine.Unity.SubmeshInstruction();
                s.skeleton = this.skeleton;
                s.startSlot = this.startSlot;
                s.endSlot = this.endSlot;
                s.material = this.material;
                s.forceSeparate = this.forceSeparate;
                s.preActiveClippingSlotSource = this.preActiveClippingSlotSource;
                s.rawTriangleCount = this.rawTriangleCount;
                s.rawVertexCount = this.rawVertexCount;
                s.rawFirstVertexIndex = this.rawFirstVertexIndex;
                s.hasClipping = this.hasClipping;
                s.hasPMAAdditiveSlot = this.hasPMAAdditiveSlot;
                return s;
            }
        },
        overloads: {
            "ToString()": "toString"
        }
    });
    /*Spine.Unity.SubmeshInstruction end.*/

    /*Spine.Unity.UpdateMode start.*/
    Bridge.define("Spine.Unity.UpdateMode", {
        $kind: 6,
        statics: {
            fields: {
                Nothing: 0,
                OnlyAnimationStatus: 1,
                OnlyEventTimelines: 4,
                EverythingExceptMesh: 2,
                FullUpdate: 3
            }
        }
    });
    /*Spine.Unity.UpdateMode end.*/

    /*Spine.Unity.UpdateTiming start.*/
    Bridge.define("Spine.Unity.UpdateTiming", {
        $kind: 6,
        statics: {
            fields: {
                ManualUpdate: 0,
                InUpdate: 1,
                InFixedUpdate: 2,
                InLateUpdate: 3
            }
        }
    });
    /*Spine.Unity.UpdateTiming end.*/

    /*Spine.Unity.WaitForSpineAnimation start.*/
    /**
     * Use this as a condition-blocking yield instruction for Unity Coroutines.
     The routine will pause until the AnimationState.TrackEntry fires any of the
     configured events.
     <p />
     See the {@link }
     and {@link }
     for more information on when track events will be triggered.
     *
     * @public
     * @class Spine.Unity.WaitForSpineAnimation
     * @implements  System.Collections.IEnumerator
     */
    Bridge.define("Spine.Unity.WaitForSpineAnimation", {
        inherits: [System.Collections.IEnumerator],
        fields: {
            m_WasFired: false
        },
        props: {
            System$Collections$IEnumerator$Current: {
                get: function () {
                    return null;
                }
            }
        },
        ctors: {
            init: function () {
                this.m_WasFired = false;
            },
            ctor: function (trackEntry, eventsToWaitFor) {
                this.$initialize();
                this.SafeSubscribe(trackEntry, eventsToWaitFor);
            }
        },
        methods: {
            /*Spine.Unity.WaitForSpineAnimation.NowWaitFor start.*/
            /**
             * One optimization high-frequency YieldInstruction returns is to cache instances to minimize GC pressure.
             Use NowWaitFor to reuse the same instance of WaitForSpineAnimationComplete.
             *
             * @instance
             * @public
             * @this Spine.Unity.WaitForSpineAnimation
             * @memberof Spine.Unity.WaitForSpineAnimation
             * @param   {Spine.TrackEntry}                     trackEntry         
             * @param   {number}                               eventsToWaitFor
             * @return  {Spine.Unity.WaitForSpineAnimation}
             */
            NowWaitFor: function (trackEntry, eventsToWaitFor) {
                this.SafeSubscribe(trackEntry, eventsToWaitFor);
                return this;
            },
            /*Spine.Unity.WaitForSpineAnimation.NowWaitFor end.*/

            /*Spine.Unity.WaitForSpineAnimation.System$Collections$IEnumerator$moveNext start.*/
            System$Collections$IEnumerator$moveNext: function () {
                if (this.m_WasFired) {
                    Bridge.cast(this, System.Collections.IEnumerator).System$Collections$IEnumerator$reset(); // auto-reset for YieldInstruction reuse
                    return false;
                }

                return true;
            },
            /*Spine.Unity.WaitForSpineAnimation.System$Collections$IEnumerator$moveNext end.*/

            /*Spine.Unity.WaitForSpineAnimation.System$Collections$IEnumerator$reset start.*/
            System$Collections$IEnumerator$reset: function () {
                this.m_WasFired = false;
            },
            /*Spine.Unity.WaitForSpineAnimation.System$Collections$IEnumerator$reset end.*/

            /*Spine.Unity.WaitForSpineAnimation.SafeSubscribe start.*/
            SafeSubscribe: function (trackEntry, eventsToWaitFor) {
                if (trackEntry == null) {
                    // Break immediately if trackEntry is null.
                    UnityEngine.Debug.LogWarning$1("TrackEntry was null. Coroutine will continue immediately.");
                    this.m_WasFired = true;
                } else {
                    if ((eventsToWaitFor & Spine.Unity.WaitForSpineAnimation.AnimationEventTypes.Start) !== 0) {
                        trackEntry.addStart(Bridge.fn.cacheBind(this, this.HandleComplete));
                    }
                    if ((eventsToWaitFor & Spine.Unity.WaitForSpineAnimation.AnimationEventTypes.Interrupt) !== 0) {
                        trackEntry.addInterrupt(Bridge.fn.cacheBind(this, this.HandleComplete));
                    }
                    if ((eventsToWaitFor & Spine.Unity.WaitForSpineAnimation.AnimationEventTypes.End) !== 0) {
                        trackEntry.addEnd(Bridge.fn.cacheBind(this, this.HandleComplete));
                    }
                    if ((eventsToWaitFor & Spine.Unity.WaitForSpineAnimation.AnimationEventTypes.Dispose) !== 0) {
                        trackEntry.addDispose(Bridge.fn.cacheBind(this, this.HandleComplete));
                    }
                    if ((eventsToWaitFor & Spine.Unity.WaitForSpineAnimation.AnimationEventTypes.Complete) !== 0) {
                        trackEntry.addComplete(Bridge.fn.cacheBind(this, this.HandleComplete));
                    }
                }
            },
            /*Spine.Unity.WaitForSpineAnimation.SafeSubscribe end.*/

            /*Spine.Unity.WaitForSpineAnimation.HandleComplete start.*/
            HandleComplete: function (trackEntry) {
                this.m_WasFired = true;
            },
            /*Spine.Unity.WaitForSpineAnimation.HandleComplete end.*/


        }
    });
    /*Spine.Unity.WaitForSpineAnimation end.*/

    /*Spine.Unity.WaitForSpineAnimation+AnimationEventTypes start.*/
    Bridge.define("Spine.Unity.WaitForSpineAnimation.AnimationEventTypes", {
        $kind: 1006,
        statics: {
            fields: {
                Start: 1,
                Interrupt: 2,
                End: 4,
                Dispose: 8,
                Complete: 16
            }
        },
        $flags: true
    });
    /*Spine.Unity.WaitForSpineAnimation+AnimationEventTypes end.*/

    /*Spine.Unity.WaitForSpineEvent start.*/
    /**
     * Use this as a condition-blocking yield instruction for Unity Coroutines.
     The routine will pause until the AnimationState fires an event matching the given event name or EventData reference.
     *
     * @public
     * @class Spine.Unity.WaitForSpineEvent
     * @implements  System.Collections.IEnumerator
     */
    Bridge.define("Spine.Unity.WaitForSpineEvent", {
        inherits: [System.Collections.IEnumerator],
        fields: {
            m_TargetEvent: null,
            m_EventName: null,
            m_AnimationState: null,
            m_WasFired: false,
            m_unsubscribeAfterFiring: false
        },
        props: {
            /**
             * By default, WaitForSpineEvent will unsubscribe from the event immediately after it fires a correct matching event.
             If you want to reuse this WaitForSpineEvent instance on the same event, you can set this to false.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.WaitForSpineEvent
             * @function WillUnsubscribeAfterFiring
             * @type boolean
             */
            WillUnsubscribeAfterFiring: {
                get: function () {
                    return this.m_unsubscribeAfterFiring;
                },
                set: function (value) {
                    this.m_unsubscribeAfterFiring = value;
                }
            },
            System$Collections$IEnumerator$Current: {
                get: function () {
                    return null;
                }
            }
        },
        ctors: {
            init: function () {
                this.m_WasFired = false;
                this.m_unsubscribeAfterFiring = false;
            },
            ctor: function (state, eventDataReference, unsubscribeAfterFiring) {
                if (unsubscribeAfterFiring === void 0) { unsubscribeAfterFiring = true; }

                this.$initialize();
                this.Subscribe(state, eventDataReference, unsubscribeAfterFiring);
            },
            $ctor2: function (skeletonAnimation, eventDataReference, unsubscribeAfterFiring) {
                if (unsubscribeAfterFiring === void 0) { unsubscribeAfterFiring = true; }

                this.$initialize();
                // If skeletonAnimation is invalid, its state will be null. Subscribe handles null states just fine.
                this.Subscribe(skeletonAnimation.state, eventDataReference, unsubscribeAfterFiring);
            },
            $ctor1: function (state, eventName, unsubscribeAfterFiring) {
                if (unsubscribeAfterFiring === void 0) { unsubscribeAfterFiring = true; }

                this.$initialize();
                this.SubscribeByName(state, eventName, unsubscribeAfterFiring);
            },
            $ctor3: function (skeletonAnimation, eventName, unsubscribeAfterFiring) {
                if (unsubscribeAfterFiring === void 0) { unsubscribeAfterFiring = true; }

                this.$initialize();
                // If skeletonAnimation is invalid, its state will be null. Subscribe handles null states just fine.
                this.SubscribeByName(skeletonAnimation.state, eventName, unsubscribeAfterFiring);
            }
        },
        methods: {
            /*Spine.Unity.WaitForSpineEvent.Subscribe start.*/
            Subscribe: function (state, eventDataReference, unsubscribe) {
                if (state == null) {
                    UnityEngine.Debug.LogWarning$1("AnimationState argument was null. Coroutine will continue immediately.");
                    this.m_WasFired = true;
                    return;
                } else if (eventDataReference == null) {
                    UnityEngine.Debug.LogWarning$1("eventDataReference argument was null. Coroutine will continue immediately.");
                    this.m_WasFired = true;
                    return;
                }

                this.m_AnimationState = state;
                this.m_TargetEvent = eventDataReference;
                state.addEvent(Bridge.fn.cacheBind(this, this.HandleAnimationStateEvent));

                this.m_unsubscribeAfterFiring = unsubscribe;

            },
            /*Spine.Unity.WaitForSpineEvent.Subscribe end.*/

            /*Spine.Unity.WaitForSpineEvent.SubscribeByName start.*/
            SubscribeByName: function (state, eventName, unsubscribe) {
                if (state == null) {
                    UnityEngine.Debug.LogWarning$1("AnimationState argument was null. Coroutine will continue immediately.");
                    this.m_WasFired = true;
                    return;
                } else if (System.String.isNullOrEmpty(eventName)) {
                    UnityEngine.Debug.LogWarning$1("eventName argument was null. Coroutine will continue immediately.");
                    this.m_WasFired = true;
                    return;
                }

                this.m_AnimationState = state;
                this.m_EventName = eventName;
                state.addEvent(Bridge.fn.cacheBind(this, this.HandleAnimationStateEventByName));

                this.m_unsubscribeAfterFiring = unsubscribe;
            },
            /*Spine.Unity.WaitForSpineEvent.SubscribeByName end.*/

            /*Spine.Unity.WaitForSpineEvent.HandleAnimationStateEventByName start.*/
            HandleAnimationStateEventByName: function (trackEntry, e) {
                this.m_WasFired = !!(this.m_WasFired | (Bridge.referenceEquals(e.data.name, this.m_EventName))); // Check event name string match.
                if (this.m_WasFired && this.m_unsubscribeAfterFiring) {
                    this.m_AnimationState.removeEvent(Bridge.fn.cacheBind(this, this.HandleAnimationStateEventByName));
                } // Unsubscribe after correct event fires.
            },
            /*Spine.Unity.WaitForSpineEvent.HandleAnimationStateEventByName end.*/

            /*Spine.Unity.WaitForSpineEvent.HandleAnimationStateEvent start.*/
            HandleAnimationStateEvent: function (trackEntry, e) {
                this.m_WasFired = !!(this.m_WasFired | (Bridge.referenceEquals(e.data, this.m_TargetEvent))); // Check event data reference match.
                if (this.m_WasFired && this.m_unsubscribeAfterFiring) {
                    this.m_AnimationState.removeEvent(Bridge.fn.cacheBind(this, this.HandleAnimationStateEvent));
                } // Usubscribe after correct event fires.
            },
            /*Spine.Unity.WaitForSpineEvent.HandleAnimationStateEvent end.*/

            /*Spine.Unity.WaitForSpineEvent.NowWaitFor start.*/
            NowWaitFor: function (state, eventDataReference, unsubscribeAfterFiring) {
                if (unsubscribeAfterFiring === void 0) { unsubscribeAfterFiring = true; }
                Bridge.cast(this, System.Collections.IEnumerator).System$Collections$IEnumerator$reset();
                this.Clear(state);
                this.Subscribe(state, eventDataReference, unsubscribeAfterFiring);

                return this;
            },
            /*Spine.Unity.WaitForSpineEvent.NowWaitFor end.*/

            /*Spine.Unity.WaitForSpineEvent.NowWaitFor$1 start.*/
            NowWaitFor$1: function (state, eventName, unsubscribeAfterFiring) {
                if (unsubscribeAfterFiring === void 0) { unsubscribeAfterFiring = true; }
                Bridge.cast(this, System.Collections.IEnumerator).System$Collections$IEnumerator$reset();
                this.Clear(state);
                this.SubscribeByName(state, eventName, unsubscribeAfterFiring);

                return this;
            },
            /*Spine.Unity.WaitForSpineEvent.NowWaitFor$1 end.*/

            /*Spine.Unity.WaitForSpineEvent.Clear start.*/
            Clear: function (state) {
                state.removeEvent(Bridge.fn.cacheBind(this, this.HandleAnimationStateEvent));
                state.removeEvent(Bridge.fn.cacheBind(this, this.HandleAnimationStateEventByName));
            },
            /*Spine.Unity.WaitForSpineEvent.Clear end.*/

            /*Spine.Unity.WaitForSpineEvent.System$Collections$IEnumerator$moveNext start.*/
            System$Collections$IEnumerator$moveNext: function () {
                if (this.m_WasFired) {
                    Bridge.cast(this, System.Collections.IEnumerator).System$Collections$IEnumerator$reset(); // auto-reset for YieldInstruction reuse
                    return false;
                }

                return true;
            },
            /*Spine.Unity.WaitForSpineEvent.System$Collections$IEnumerator$moveNext end.*/

            /*Spine.Unity.WaitForSpineEvent.System$Collections$IEnumerator$reset start.*/
            System$Collections$IEnumerator$reset: function () {
                this.m_WasFired = false;
            },
            /*Spine.Unity.WaitForSpineEvent.System$Collections$IEnumerator$reset end.*/


        },
        overloads: {
            "NowWaitFor(Spine.AnimationState, string, bool)": "NowWaitFor$1"
        }
    });
    /*Spine.Unity.WaitForSpineEvent end.*/

    /*Spine.Unity.WaitForSpineTrackEntryEnd start.*/
    /**
     * Use this as a condition-blocking yield instruction for Unity Coroutines.
     The routine will pause until the AnimationState.TrackEntry fires its End event.
     *
     * @public
     * @class Spine.Unity.WaitForSpineTrackEntryEnd
     * @implements  System.Collections.IEnumerator
     */
    Bridge.define("Spine.Unity.WaitForSpineTrackEntryEnd", {
        inherits: [System.Collections.IEnumerator],
        fields: {
            m_WasFired: false
        },
        props: {
            System$Collections$IEnumerator$Current: {
                get: function () {
                    return null;
                }
            }
        },
        ctors: {
            init: function () {
                this.m_WasFired = false;
            },
            ctor: function (trackEntry) {
                this.$initialize();
                this.SafeSubscribe(trackEntry);
            }
        },
        methods: {
            /*Spine.Unity.WaitForSpineTrackEntryEnd.HandleEnd start.*/
            HandleEnd: function (trackEntry) {
                this.m_WasFired = true;
            },
            /*Spine.Unity.WaitForSpineTrackEntryEnd.HandleEnd end.*/

            /*Spine.Unity.WaitForSpineTrackEntryEnd.SafeSubscribe start.*/
            SafeSubscribe: function (trackEntry) {
                if (trackEntry == null) {
                    // Break immediately if trackEntry is null.
                    UnityEngine.Debug.LogWarning$1("TrackEntry was null. Coroutine will continue immediately.");
                    this.m_WasFired = true;
                } else {
                    trackEntry.addEnd(Bridge.fn.cacheBind(this, this.HandleEnd));
                }
            },
            /*Spine.Unity.WaitForSpineTrackEntryEnd.SafeSubscribe end.*/

            /*Spine.Unity.WaitForSpineTrackEntryEnd.NowWaitFor start.*/
            /**
             * One optimization high-frequency YieldInstruction returns is to cache instances to minimize GC pressure.
             Use NowWaitFor to reuse the same instance of WaitForSpineAnimationEnd.
             *
             * @instance
             * @public
             * @this Spine.Unity.WaitForSpineTrackEntryEnd
             * @memberof Spine.Unity.WaitForSpineTrackEntryEnd
             * @param   {Spine.TrackEntry}                         trackEntry
             * @return  {Spine.Unity.WaitForSpineTrackEntryEnd}
             */
            NowWaitFor: function (trackEntry) {
                this.SafeSubscribe(trackEntry);
                return this;
            },
            /*Spine.Unity.WaitForSpineTrackEntryEnd.NowWaitFor end.*/

            /*Spine.Unity.WaitForSpineTrackEntryEnd.System$Collections$IEnumerator$moveNext start.*/
            System$Collections$IEnumerator$moveNext: function () {
                if (this.m_WasFired) {
                    Bridge.cast(this, System.Collections.IEnumerator).System$Collections$IEnumerator$reset(); // auto-reset for YieldInstruction reuse
                    return false;
                }

                return true;
            },
            /*Spine.Unity.WaitForSpineTrackEntryEnd.System$Collections$IEnumerator$moveNext end.*/

            /*Spine.Unity.WaitForSpineTrackEntryEnd.System$Collections$IEnumerator$reset start.*/
            System$Collections$IEnumerator$reset: function () {
                this.m_WasFired = false;
            },
            /*Spine.Unity.WaitForSpineTrackEntryEnd.System$Collections$IEnumerator$reset end.*/


        }
    });
    /*Spine.Unity.WaitForSpineTrackEntryEnd end.*/

    /*test start.*/
    Bridge.define("test", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            img: null,
            sprite: null,
            bg: null,
            x: 0,
            gm: null,
            t: null,
            isClear: false,
            scaleChangeTime: 0,
            curScaleChangeTime: 0,
            prevScale: null,
            isChangeScale: false,
            changeToScale: null,
            clickScale: 0,
            clearScale: 0
        },
        ctors: {
            init: function () {
                this.prevScale = new UnityEngine.Vector3();
                this.changeToScale = new UnityEngine.Vector3();
                this.x = 1;
                this.scaleChangeTime = 0.35;
                this.curScaleChangeTime = 0.0;
                this.isChangeScale = false;
                this.changeToScale = pc.Vec3.ZERO.clone();
                this.clickScale = 1.35;
                this.clearScale = 0.0;
            }
        },
        methods: {
            /*test.Awake start.*/
            Awake: function () {
                this.t = this.transform;
                this.isClear = false;
                this.isChangeScale = false;
            },
            /*test.Awake end.*/

            /*test.setClear start.*/
            setClear: function () {
                this.isClear = true;
                this.curScaleChangeTime = 0;
                this.changeToScale = new pc.Vec3( 1, 1, 1 ).clone().scale( this.clearScale );
                this.isChangeScale = true;
                this.prevScale = this.t.localScale.$clone();
            },
            /*test.setClear end.*/

            /*test.setDisable start.*/
            setDisable: function () {
                this.bg.SetActive(false);
                this.curScaleChangeTime = 0;
                this.changeToScale = new pc.Vec3( 1, 1, 1 );
                this.isChangeScale = true;
                this.prevScale = this.t.localScale.$clone();
            },
            /*test.setDisable end.*/

            /*test.onClick start.*/
            onClick: function () {
                var $t;
                if (this.isClear) {
                    return;
                }
                if (this.gm.CanClick === false) {
                    return;
                }
                if (UnityEngine.MonoBehaviour.op_Equality(($t = this.gm.tests)[0], this)) {
                    return;
                }

                this.bg.SetActive(true);
                this.gm.onClickTest(this);

                this.changeToScale = new pc.Vec3( 1, 1, 1 ).clone().scale( this.clickScale );
                this.curScaleChangeTime = 0;
                this.prevScale = this.t.localScale.$clone();
                this.isChangeScale = true;
            },
            /*test.onClick end.*/

            /*test.Update start.*/
            Update: function () {
                if (this.isChangeScale) {
                    if (this.curScaleChangeTime < this.scaleChangeTime) {
                        this.curScaleChangeTime += UnityEngine.Time.deltaTime;
                        this.t.localScale = new pc.Vec3().lerp( this.t.localScale, this.changeToScale, this.curScaleChangeTime / this.scaleChangeTime );
                    } else {
                        this.gm.EndProc();
                        this.curScaleChangeTime = 0;
                        this.t.localScale = this.changeToScale.$clone();
                        this.isChangeScale = false;
                    }
                }
            },
            /*test.Update end.*/


        }
    });
    /*test end.*/

    /*Spine.Unity.IHasSkeletonDataAsset start.*/
    /**
     * Holds a reference to a SkeletonDataAsset.
     *
     * @abstract
     * @public
     * @class Spine.Unity.IHasSkeletonDataAsset
     * @implements  Spine.Unity.ISpineComponent
     */
    Bridge.define("Spine.Unity.IHasSkeletonDataAsset", {
        inherits: [Spine.Unity.ISpineComponent],
        $kind: 3
    });
    /*Spine.Unity.IHasSkeletonDataAsset end.*/

    /*Spine.Unity.BlendModeMaterialsAsset start.*/
    Bridge.define("Spine.Unity.BlendModeMaterialsAsset", {
        inherits: [Spine.Unity.SkeletonDataModifierAsset],
        statics: {
            methods: {
                /*Spine.Unity.BlendModeMaterialsAsset.ApplyMaterials:static start.*/
                ApplyMaterials: function (skeletonData, multiplyTemplate, screenTemplate, additiveTemplate, includeAdditiveSlots) {
                    var $t, $t1;
                    if (skeletonData == null) {
                        throw new System.ArgumentNullException.$ctor1("skeletonData");
                    }

                    var materialCache = new Spine.Unity.BlendModeMaterialsAsset.AtlasMaterialCache();
                    try {
                        var entryBuffer = new (System.Collections.Generic.List$1(spine.SkinEntry)).ctor();
                        var slotsItems = skeletonData.Slots.Items;
                        for (var slotIndex = 0, slotCount = skeletonData.Slots.Count; slotIndex < slotCount; slotIndex = (slotIndex + 1) | 0) {
                            var slot = slotsItems[slotIndex];
                            if (slot.blendMode === spine.BlendMode.Normal) {
                                continue;
                            }
                            if (!includeAdditiveSlots && slot.blendMode === spine.BlendMode.Additive) {
                                continue;
                            }

                            entryBuffer.clear();
                            $t = Bridge.getEnumerator(skeletonData.Skins);
                            try {
                                while ($t.moveNext()) {
                                    var skin = $t.Current;
                                    ( entryBuffer._items.length = 0, skin.getAttachmentsForSlot( slotIndex, entryBuffer._items ), entryBuffer._size = entryBuffer._items.length );
                                }
                            } finally {
                                if (Bridge.is($t, System.IDisposable)) {
                                    $t.System$IDisposable$Dispose();
                                }
                            }

                            var templateMaterial = null;
                            switch (slot.blendMode) {
                                case spine.BlendMode.Multiply: 
                                    templateMaterial = multiplyTemplate;
                                    break;
                                case spine.BlendMode.Screen: 
                                    templateMaterial = screenTemplate;
                                    break;
                                case spine.BlendMode.Additive: 
                                    templateMaterial = additiveTemplate;
                                    break;
                            }
                            if (templateMaterial == null) {
                                continue;
                            }

                            $t1 = Bridge.getEnumerator(entryBuffer);
                            try {
                                while ($t1.moveNext()) {
                                    var entry = $t1.Current;
                                    var renderableAttachment = Bridge.as(entry.attachment, Spine.IHasTextureRegion);
                                    if (renderableAttachment != null) {
                                        renderableAttachment.Spine$IHasTextureRegion$Region = materialCache.CloneAtlasRegionWithMaterial(Bridge.cast(renderableAttachment.Spine$IHasTextureRegion$Region, Spine.AtlasRegion), templateMaterial);
                                    }
                                }
                            } finally {
                                if (Bridge.is($t1, System.IDisposable)) {
                                    $t1.System$IDisposable$Dispose();
                                }
                            }
                        }

                    }
                    finally {
                        if (Bridge.hasValue(materialCache)) {
                            materialCache.System$IDisposable$Dispose();
                        }
                    }
                    //attachmentBuffer.Clear();
                },
                /*Spine.Unity.BlendModeMaterialsAsset.ApplyMaterials:static end.*/


            }
        },
        fields: {
            multiplyMaterialTemplate: null,
            screenMaterialTemplate: null,
            additiveMaterialTemplate: null,
            applyAdditiveMaterial: false
        },
        ctors: {
            init: function () {
                this.applyAdditiveMaterial = true;
            }
        },
        methods: {
            /*Spine.Unity.BlendModeMaterialsAsset.Apply start.*/
            Apply: function (skeletonData) {
                Spine.Unity.BlendModeMaterialsAsset.ApplyMaterials(skeletonData, this.multiplyMaterialTemplate, this.screenMaterialTemplate, this.additiveMaterialTemplate, this.applyAdditiveMaterial);
            },
            /*Spine.Unity.BlendModeMaterialsAsset.Apply end.*/


        }
    });
    /*Spine.Unity.BlendModeMaterialsAsset end.*/

    /*Spine.Unity.IAnimationStateComponent start.*/
    /**
     * A Spine-Unity Component that uses a Spine.AnimationState to animate its skeleton.
     *
     * @abstract
     * @public
     * @class Spine.Unity.IAnimationStateComponent
     * @implements  Spine.Unity.ISpineComponent
     */
    Bridge.define("Spine.Unity.IAnimationStateComponent", {
        inherits: [Spine.Unity.ISpineComponent],
        $kind: 3
    });
    /*Spine.Unity.IAnimationStateComponent end.*/

    /*Spine.Unity.IHasSkeletonComponent start.*/
    /**
     * A Spine-Unity Component that holds a reference to an ISkeletonComponent.
     *
     * @abstract
     * @public
     * @class Spine.Unity.IHasSkeletonComponent
     * @implements  Spine.Unity.ISpineComponent
     */
    Bridge.define("Spine.Unity.IHasSkeletonComponent", {
        inherits: [Spine.Unity.ISpineComponent],
        $kind: 3
    });
    /*Spine.Unity.IHasSkeletonComponent end.*/

    /*Spine.Unity.IHasSkeletonRenderer start.*/
    /**
     * A Spine-Unity Component that holds a reference to a SkeletonRenderer.
     *
     * @abstract
     * @public
     * @class Spine.Unity.IHasSkeletonRenderer
     * @implements  Spine.Unity.ISpineComponent
     */
    Bridge.define("Spine.Unity.IHasSkeletonRenderer", {
        inherits: [Spine.Unity.ISpineComponent],
        $kind: 3
    });
    /*Spine.Unity.IHasSkeletonRenderer end.*/

    /*Spine.Unity.ISkeletonAnimation start.*/
    /**
     * A Spine-Unity Component that animates a Skeleton but not necessarily with a Spine.AnimationState.
     *
     * @abstract
     * @public
     * @class Spine.Unity.ISkeletonAnimation
     * @implements  Spine.Unity.ISpineComponent
     */
    Bridge.define("Spine.Unity.ISkeletonAnimation", {
        inherits: [Spine.Unity.ISpineComponent],
        $kind: 3
    });
    /*Spine.Unity.ISkeletonAnimation end.*/

    /*Spine.Unity.ISkeletonComponent start.*/
    /**
     * A Spine-Unity Component that manages a Spine.Skeleton instance, instantiated from a SkeletonDataAsset.
     *
     * @abstract
     * @public
     * @class Spine.Unity.ISkeletonComponent
     * @implements  Spine.Unity.ISpineComponent
     */
    Bridge.define("Spine.Unity.ISkeletonComponent", {
        inherits: [Spine.Unity.ISpineComponent],
        $kind: 3
    });
    /*Spine.Unity.ISkeletonComponent end.*/

    /*Spine.Unity.SkeletonMecanimRootMotion start.*/
    /**
     * Add this component to a SkeletonMecanim GameObject
     to turn motion of a selected root bone into Transform or RigidBody motion.
     Local bone translation movement is used as motion.
     All top-level bones of the skeleton are moved to compensate the root
     motion bone location, keeping the distance relationship between bones intact.
     *
     * @public
     * @class Spine.Unity.SkeletonMecanimRootMotion
     * @augments Spine.Unity.SkeletonRootMotionBase
     */
    Bridge.define("Spine.Unity.SkeletonMecanimRootMotion", {
        inherits: [Spine.Unity.SkeletonRootMotionBase],
        statics: {
            fields: {
                DefaultMecanimLayerFlags: 0
            },
            ctors: {
                init: function () {
                    this.DefaultMecanimLayerFlags = -1;
                }
            }
        },
        fields: {
            mecanimLayerFlags: 0,
            movementDelta: null,
            rotationDelta: 0,
            skeletonMecanim: null
        },
        props: {
            SkeletonMecanim: {
                get: function () {
                    return UnityEngine.Object.op_Implicit(this.skeletonMecanim) ? this.skeletonMecanim : (this.skeletonMecanim = this.GetComponent(Spine.Unity.SkeletonMecanim));
                }
            }
        },
        ctors: {
            init: function () {
                this.movementDelta = new UnityEngine.Vector2();
                this.mecanimLayerFlags = -1;
            }
        },
        methods: {
            /*Spine.Unity.SkeletonMecanimRootMotion.GetRemainingRootMotion start.*/
            GetRemainingRootMotion: function (layerIndex) {
                var pair = this.skeletonMecanim.Translator.GetActiveAnimationAndTime(layerIndex);
                var animation = pair.key;
                var time = pair.value;
                if (animation == null) {
                    return pc.Vec2.ZERO.clone();
                }

                var start = time;
                var end = animation.duration;
                return this.GetAnimationRootMotion$1(start, end, animation);
            },
            /*Spine.Unity.SkeletonMecanimRootMotion.GetRemainingRootMotion end.*/

            /*Spine.Unity.SkeletonMecanimRootMotion.GetRootMotionInfo start.*/
            GetRootMotionInfo: function (layerIndex) {
                var pair = this.skeletonMecanim.Translator.GetActiveAnimationAndTime(layerIndex);
                var animation = pair.key;
                var time = pair.value;
                if (animation == null) {
                    return new Spine.Unity.SkeletonRootMotionBase.RootMotionInfo();
                }
                return this.GetAnimationRootMotionInfo(animation, time);
            },
            /*Spine.Unity.SkeletonMecanimRootMotion.GetRootMotionInfo end.*/

            /*Spine.Unity.SkeletonMecanimRootMotion.Reset start.*/
            Reset: function () {
                Spine.Unity.SkeletonRootMotionBase.prototype.Reset.call(this);
                this.mecanimLayerFlags = Spine.Unity.SkeletonMecanimRootMotion.DefaultMecanimLayerFlags;
            },
            /*Spine.Unity.SkeletonMecanimRootMotion.Reset end.*/

            /*Spine.Unity.SkeletonMecanimRootMotion.Start start.*/
            Start: function () {
                Spine.Unity.SkeletonRootMotionBase.prototype.Start.call(this);
                this.skeletonMecanim = this.GetComponent(Spine.Unity.SkeletonMecanim);
                if (UnityEngine.Object.op_Implicit(this.skeletonMecanim)) {
                    this.skeletonMecanim.Translator.removeOnClipApplied(Bridge.fn.cacheBind(this, this.OnClipApplied));
                    this.skeletonMecanim.Translator.addOnClipApplied(Bridge.fn.cacheBind(this, this.OnClipApplied));
                }
            },
            /*Spine.Unity.SkeletonMecanimRootMotion.Start end.*/

            /*Spine.Unity.SkeletonMecanimRootMotion.OnClipApplied start.*/
            OnClipApplied: function (animation, layerIndex, weight, time, lastTime, playsBackward) {

                if (((this.mecanimLayerFlags & 1 << layerIndex) === 0) || weight === 0) {
                    return;
                }

                if (!playsBackward) {
                    this.movementDelta = this.movementDelta.$clone().add( this.GetAnimationRootMotion$1(lastTime, time, animation).scale( weight ) );
                } else {
                    this.movementDelta = this.movementDelta.$clone().sub( this.GetAnimationRootMotion$1(time, lastTime, animation).scale( weight ) );
                }
                if (this.transformRotation) {
                    if (!playsBackward) {
                        this.rotationDelta += weight * this.GetAnimationRootMotionRotation$1(lastTime, time, animation);
                    } else {
                        this.rotationDelta -= weight * this.GetAnimationRootMotionRotation$1(time, lastTime, animation);
                    }
                }
            },
            /*Spine.Unity.SkeletonMecanimRootMotion.OnClipApplied end.*/

            /*Spine.Unity.SkeletonMecanimRootMotion.CalculateAnimationsMovementDelta start.*/
            CalculateAnimationsMovementDelta: function () {
                // Note: movement delta is not gathered after animation but
                // in OnClipApplied after every applied animation.
                var result = this.movementDelta.$clone();
                this.movementDelta = pc.Vec2.ZERO.clone();
                return result.$clone();
            },
            /*Spine.Unity.SkeletonMecanimRootMotion.CalculateAnimationsMovementDelta end.*/

            /*Spine.Unity.SkeletonMecanimRootMotion.CalculateAnimationsRotationDelta start.*/
            CalculateAnimationsRotationDelta: function () {
                // Note: movement delta is not gathered after animation but
                // in OnClipApplied after every applied animation.
                var result = this.rotationDelta;
                this.rotationDelta = 0;
                return result;
            },
            /*Spine.Unity.SkeletonMecanimRootMotion.CalculateAnimationsRotationDelta end.*/


        }
    });
    /*Spine.Unity.SkeletonMecanimRootMotion end.*/

    /*Spine.Unity.SkeletonRootMotion start.*/
    /**
     * Add this component to a SkeletonAnimation or SkeletonGraphic GameObject
     to turn motion of a selected root bone into Transform or RigidBody motion.
     Local bone translation movement is used as motion.
     All top-level bones of the skeleton are moved to compensate the root
     motion bone location, keeping the distance relationship between bones intact.
     *
     * @public
     * @class Spine.Unity.SkeletonRootMotion
     * @augments Spine.Unity.SkeletonRootMotionBase
     */
    Bridge.define("Spine.Unity.SkeletonRootMotion", {
        inherits: [Spine.Unity.SkeletonRootMotionBase],
        statics: {
            fields: {
                DefaultAnimationTrackFlags: 0
            },
            ctors: {
                init: function () {
                    this.DefaultAnimationTrackFlags = -1;
                }
            }
        },
        fields: {
            animationTrackFlags: 0,
            animationState: null,
            skeletonGraphic: null
        },
        props: {
            AdditionalScale: {
                get: function () {
                    return UnityEngine.Object.op_Implicit(this.skeletonGraphic) ? this.skeletonGraphic.MeshScale : 1.0;
                }
            }
        },
        ctors: {
            init: function () {
                this.animationTrackFlags = -1;
            }
        },
        methods: {
            /*Spine.Unity.SkeletonRootMotion.GetRemainingRootMotion start.*/
            GetRemainingRootMotion: function (trackIndex) {
                var track = this.animationState.getCurrent(trackIndex);
                if (track == null) {
                    return pc.Vec2.ZERO.clone();
                }

                var animation = track.animation;
                var start = track.getAnimationTime();
                var end = animation.duration;
                return this.GetAnimationRootMotion$1(start, end, animation);
            },
            /*Spine.Unity.SkeletonRootMotion.GetRemainingRootMotion end.*/

            /*Spine.Unity.SkeletonRootMotion.GetRootMotionInfo start.*/
            GetRootMotionInfo: function (trackIndex) {
                var track = this.animationState.getCurrent(trackIndex);
                if (track == null) {
                    return new Spine.Unity.SkeletonRootMotionBase.RootMotionInfo();
                }

                var animation = track.animation;
                var time = track.getAnimationTime();
                return this.GetAnimationRootMotionInfo(track.animation, time);
            },
            /*Spine.Unity.SkeletonRootMotion.GetRootMotionInfo end.*/

            /*Spine.Unity.SkeletonRootMotion.Reset start.*/
            Reset: function () {
                Spine.Unity.SkeletonRootMotionBase.prototype.Reset.call(this);
                this.animationTrackFlags = Spine.Unity.SkeletonRootMotion.DefaultAnimationTrackFlags;
            },
            /*Spine.Unity.SkeletonRootMotion.Reset end.*/

            /*Spine.Unity.SkeletonRootMotion.Start start.*/
            Start: function () {
                Spine.Unity.SkeletonRootMotionBase.prototype.Start.call(this);
                var animstateComponent = Bridge.as(this.skeletonComponent, Spine.Unity.IAnimationStateComponent);
                this.animationState = (animstateComponent != null) ? animstateComponent.Spine$Unity$IAnimationStateComponent$AnimationState : null;

                this.skeletonGraphic = this.GetComponent(Spine.Unity.SkeletonGraphic);
            },
            /*Spine.Unity.SkeletonRootMotion.Start end.*/

            /*Spine.Unity.SkeletonRootMotion.CalculateAnimationsMovementDelta start.*/
            CalculateAnimationsMovementDelta: function () {
                var localDelta = pc.Vec2.ZERO.clone();
                var trackCount = this.animationState.Tracks.Count;

                for (var trackIndex = 0; trackIndex < trackCount; trackIndex = (trackIndex + 1) | 0) {
                    // note: animationTrackFlags != -1 below covers trackIndex >= 32,
                    // with -1 corresponding to entry "everything" of the dropdown list.
                    if (this.animationTrackFlags !== -1 && (this.animationTrackFlags & 1 << trackIndex) === 0) {
                        continue;
                    }

                    var track = this.animationState.getCurrent(trackIndex);
                    var next = null;
                    while (track != null) {
                        var animation = track.animation;
                        var start = track.animationLast;
                        var end = track.getAnimationTime();
                        var currentDelta = { v : this.GetAnimationRootMotion$1(start, end, animation) };
                        if (!pc.Vec2.equals( currentDelta.v, pc.Vec2.ZERO.clone() )) {
                            this.ApplyMixAlphaToDelta$1(currentDelta, next, track);
                            localDelta = localDelta.$clone().add( currentDelta.v.$clone() );
                        }

                        // Traverse mixingFrom chain.
                        next = track;
                        track = track.mixingFrom;
                    }
                }
                return localDelta.$clone();
            },
            /*Spine.Unity.SkeletonRootMotion.CalculateAnimationsMovementDelta end.*/

            /*Spine.Unity.SkeletonRootMotion.CalculateAnimationsRotationDelta start.*/
            CalculateAnimationsRotationDelta: function () {
                var localDelta = 0;
                var trackCount = this.animationState.Tracks.Count;

                for (var trackIndex = 0; trackIndex < trackCount; trackIndex = (trackIndex + 1) | 0) {
                    // note: animationTrackFlags != -1 below covers trackIndex >= 32,
                    // with -1 corresponding to entry "everything" of the dropdown list.
                    if (this.animationTrackFlags !== -1 && (this.animationTrackFlags & 1 << trackIndex) === 0) {
                        continue;
                    }

                    var track = this.animationState.getCurrent(trackIndex);
                    var next = null;
                    while (track != null) {
                        var animation = track.animation;
                        var start = track.animationLast;
                        var end = track.getAnimationTime();
                        var currentDelta = { v : this.GetAnimationRootMotionRotation$1(start, end, animation) };
                        if (currentDelta.v !== 0) {
                            this.ApplyMixAlphaToDelta(currentDelta, next, track);
                            localDelta += currentDelta.v;
                        }

                        // Traverse mixingFrom chain.
                        next = track;
                        track = track.mixingFrom;
                    }
                }
                return localDelta;
            },
            /*Spine.Unity.SkeletonRootMotion.CalculateAnimationsRotationDelta end.*/

            /*Spine.Unity.SkeletonRootMotion.ApplyMixAlphaToDelta$1 start.*/
            ApplyMixAlphaToDelta$1: function (currentDelta, next, track) {
                var mixAlpha = { v : 1 };
                this.GetMixAlpha(mixAlpha, next, track);
                currentDelta.v = currentDelta.v.$clone().scale( mixAlpha.v );
            },
            /*Spine.Unity.SkeletonRootMotion.ApplyMixAlphaToDelta$1 end.*/

            /*Spine.Unity.SkeletonRootMotion.ApplyMixAlphaToDelta start.*/
            ApplyMixAlphaToDelta: function (currentDelta, next, track) {
                var mixAlpha = { v : 1 };
                this.GetMixAlpha(mixAlpha, next, track);
                currentDelta.v *= mixAlpha.v;
            },
            /*Spine.Unity.SkeletonRootMotion.ApplyMixAlphaToDelta end.*/

            /*Spine.Unity.SkeletonRootMotion.GetMixAlpha start.*/
            GetMixAlpha: function (cumulatedMixAlpha, next, track) {
                // code below based on AnimationState.cs
                var mix;
                if (next != null) {
                    if (next.mixDuration === 0) { // Single frame mix to undo mixingFrom changes.
                        mix = 1;
                    } else {
                        mix = next.mixTime / next.mixDuration;
                        if (mix > 1) {
                            mix = 1;
                        }
                    }
                    var mixAndAlpha = track.alpha * next.interruptAlpha * (1 - mix);
                    cumulatedMixAlpha.v *= mixAndAlpha;
                } else {
                    if (track.mixDuration === 0) {
                        mix = 1;
                    } else {
                        mix = track.alpha * (track.mixTime / track.mixDuration);
                        if (mix > 1) {
                            mix = 1;
                        }
                    }
                    cumulatedMixAlpha.v *= mix;
                }
            },
            /*Spine.Unity.SkeletonRootMotion.GetMixAlpha end.*/


        },
        overloads: {
            "ApplyMixAlphaToDelta(Vector2, TrackEntry, TrackEntry)": "ApplyMixAlphaToDelta$1"
        }
    });
    /*Spine.Unity.SkeletonRootMotion end.*/

    /*Spine.Unity.SpineAnimation start.*/
    Bridge.define("Spine.Unity.SpineAnimation", {
        inherits: [Spine.Unity.SpineAttributeBase],
        ctors: {
            
            ctor: function (startsWith, dataField, includeNone, fallbackToTextField) {
                if (startsWith === void 0) { startsWith = ""; }
                if (dataField === void 0) { dataField = ""; }
                if (includeNone === void 0) { includeNone = true; }
                if (fallbackToTextField === void 0) { fallbackToTextField = false; }

                this.$initialize();
                Spine.Unity.SpineAttributeBase.ctor.call(this);
                this.startsWith = startsWith;
                this.dataField = dataField;
                this.includeNone = includeNone;
                this.fallbackToTextField = fallbackToTextField;
            }
        }
    });
    /*Spine.Unity.SpineAnimation end.*/
    /** @namespace System */

    /**
     * @memberof System
     * @callback System.Func
     * @param   {Spine.Unity.SpineAtlasAsset}    arg
     * @return  {Spine.TextureLoader}
     */


    /*Spine.Unity.SpineAtlasAsset start.*/
    /**
     * Loads and stores a Spine atlas and list of materials.
     *
     * @public
     * @class Spine.Unity.SpineAtlasAsset
     * @augments Spine.Unity.AtlasAssetBase
     */
    Bridge.define("Spine.Unity.SpineAtlasAsset", {
        inherits: [Spine.Unity.AtlasAssetBase],
        statics: {
            methods: {
                /*Spine.Unity.SpineAtlasAsset.CreateRuntimeInstance:static start.*/
                /**
                 * Creates a runtime AtlasAsset
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SpineAtlasAsset
                 * @memberof Spine.Unity.SpineAtlasAsset
                 * @param   {UnityEngine.TextAsset}           atlasText                 
                 * @param   {Array.<UnityEngine.Material>}    materials                 
                 * @param   {boolean}                         initialize                
                 * @param   {System.Func}                     newCustomTextureLoader    When not null, a function instantiating
                 a custom <pre><code>TextureLoader</code></pre> with the newly created <pre><code>SpineAtlasAsset</code></pre> as argument
                 is used instead of instantiating the default <pre><code>MaterialsTextureLoader</code></pre>.
                 A valid parameter is e.g. <pre><code>(a) =&gt; new CustomTextureLoader(a)</code></pre>
                 * @return  {Spine.Unity.SpineAtlasAsset}
                 */
                CreateRuntimeInstance: function (atlasText, materials, initialize, newCustomTextureLoader) {
                    if (newCustomTextureLoader === void 0) { newCustomTextureLoader = null; }

                    var atlasAsset = UnityEngine.ScriptableObject.CreateInstance(Spine.Unity.SpineAtlasAsset);
                    atlasAsset.Reset();
                    atlasAsset.atlasFile = atlasText;
                    atlasAsset.materials = materials;
                    if (!Bridge.staticEquals(newCustomTextureLoader, null)) {
                        atlasAsset.customTextureLoader = newCustomTextureLoader(atlasAsset);
                    }

                    if (initialize) {
                        atlasAsset.GetAtlas();
                    }

                    return atlasAsset;
                },
                /*Spine.Unity.SpineAtlasAsset.CreateRuntimeInstance:static end.*/

                /*Spine.Unity.SpineAtlasAsset.CreateRuntimeInstance$1:static start.*/
                /**
                 * Creates a runtime AtlasAsset. Only providing the textures is slower
                 because it has to search for atlas page matches.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SpineAtlasAsset
                 * @memberof Spine.Unity.SpineAtlasAsset
                 * @param   {UnityEngine.TextAsset}            atlasText                 
                 * @param   {Array.<UnityEngine.Texture2D>}    textures                  An array of all textures referenced in the provided <pre><code>atlasText</code></pre>
                 atlas asset JSON file. When procedurally creating textures, each <pre><code>Texture.name</code></pre>
                 needs to be set to the atlas page texture filename without the .png extension,
                 e.g. 'my_skeleton' if the png filename listed in the atlas asset file is 'my_skeleton.png'.
                 * @param   {UnityEngine.Material}             materialPropertySource    
                 * @param   {boolean}                          initialize                
                 * @param   {System.Func}                      newCustomTextureLoader
                 * @return  {Spine.Unity.SpineAtlasAsset}
                 * @see {@link SpineAtlasAsset.CreateRuntimeInstance(TextAsset, Material[], bool, Func{SpineAtlasAsset, TextureLoader})}
                 */
                CreateRuntimeInstance$1: function (atlasText, textures, materialPropertySource, initialize, newCustomTextureLoader) {
                    if (newCustomTextureLoader === void 0) { newCustomTextureLoader = null; }

                    // Get atlas page names.
                    var atlasString = atlasText.text;
                    atlasString = System.String.replaceAll(atlasString, "\r", "");
                    var atlasLines = System.String.split(atlasString, [10].map(function (i) {{ return String.fromCharCode(i); }}));
                    var pages = new (System.Collections.Generic.List$1(System.String)).ctor();
                    for (var i = 0; i < ((atlasLines.length - 1) | 0); i = (i + 1) | 0) {
                        var line = atlasLines[i].trim();
                        if (System.String.endsWith(line, ".png")) {
                            pages.add(System.String.replaceAll(line, ".png", ""));
                        }
                    }

                    // Populate Materials[] by matching texture names with page names.
                    var materials = System.Array.init(pages.Count, null, UnityEngine.Material);
                    for (var i1 = 0, n = pages.Count; i1 < n; i1 = (i1 + 1) | 0) {
                        var mat = null;

                        // Search for a match.
                        var pageName = pages.getItem(i1);
                        for (var j = 0, m = textures.length; j < m; j = (j + 1) | 0) {
                            if (System.String.equals(pageName, textures[j].name, 5)) {
                                // Match found.
                                mat = new UnityEngine.Material.$ctor1(materialPropertySource);
                                mat.mainTexture = textures[j];
                                break;
                            }
                        }

                        if (mat != null) {
                            materials[i1] = mat;
                        } else {
                            throw new System.ArgumentException.$ctor1("Could not find matching atlas page in the texture array.");
                        }
                    }

                    // Create AtlasAsset normally
                    return Spine.Unity.SpineAtlasAsset.CreateRuntimeInstance(atlasText, materials, initialize, newCustomTextureLoader);
                },
                /*Spine.Unity.SpineAtlasAsset.CreateRuntimeInstance$1:static end.*/

                /*Spine.Unity.SpineAtlasAsset.CreateRuntimeInstance$2:static start.*/
                
                CreateRuntimeInstance$2: function (atlasText, textures, shader, initialize, newCustomTextureLoader) {
                    if (newCustomTextureLoader === void 0) { newCustomTextureLoader = null; }

                    if (shader == null) {
                        shader = UnityEngine.Shader.Find("Spine/Skeleton");
                    }

                    var materialProperySource = new UnityEngine.Material.$ctor2(shader);
                    return Spine.Unity.SpineAtlasAsset.CreateRuntimeInstance$1(atlasText, textures, materialProperySource, initialize, newCustomTextureLoader);
                },
                /*Spine.Unity.SpineAtlasAsset.CreateRuntimeInstance$2:static end.*/


            }
        },
        fields: {
            atlasFile: null,
            materials: null,
            customTextureLoader: null,
            atlas: null
        },
        props: {
            IsLoaded: {
                get: function () {
                    return this.atlas != null;
                }
            },
            Materials: {
                get: function () {
                    return this.materials;
                }
            },
            MaterialCount: {
                get: function () {
                    return this.materials == null ? 0 : this.materials.length;
                }
            },
            PrimaryMaterial: {
                get: function () {
                    return this.materials[0];
                }
            }
        },
        methods: {
            /*Spine.Unity.SpineAtlasAsset.Reset start.*/
            Reset: function () {
                this.Clear();
            },
            /*Spine.Unity.SpineAtlasAsset.Reset end.*/

            /*Spine.Unity.SpineAtlasAsset.Clear start.*/
            Clear: function () {
                this.atlas = null;
            },
            /*Spine.Unity.SpineAtlasAsset.Clear end.*/

            /*Spine.Unity.SpineAtlasAsset.GetAtlas start.*/
            /**
             * @instance
             * @public
             * @override
             * @this Spine.Unity.SpineAtlasAsset
             * @memberof Spine.Unity.SpineAtlasAsset
             * @param   {boolean}        onlyMetaData
             * @return  {Spine.Atlas}                    The atlas or null if it could not be loaded.
             */
            GetAtlas: function (onlyMetaData) {
                if (onlyMetaData === void 0) { onlyMetaData = false; }
                if (this.atlasFile == null) {
                    UnityEngine.Debug.LogError$2("Atlas file not set for atlas asset: " + (this.name || ""), this);
                    this.Clear();
                    return null;
                }

                if (!onlyMetaData && (this.materials == null || this.materials.length === 0)) {
                    UnityEngine.Debug.LogError$2("Materials not set for atlas asset: " + (this.name || ""), this);
                    this.Clear();
                    return null;
                }

                if (this.atlas != null) {
                    return this.atlas;
                }

                try {
                    var loader;
                    if (!onlyMetaData) {
                        loader = this.customTextureLoader == null ? new Spine.Unity.MaterialsTextureLoader(this) : this.customTextureLoader;
                    } else {
                        loader = new Spine.Unity.NoOpTextureLoader();
                    }
                    this.atlas = new Spine.Atlas.$ctor1(new System.IO.StringReader(this.atlasFile.text), "", loader);
                    this.atlas.FlipV();
                    return this.atlas;
                } catch (ex) {
                    ex = System.Exception.create(ex);
                    UnityEngine.Debug.LogError$2("Error reading atlas file for atlas asset: " + (this.name || "") + "\n" + (ex.Message || "") + "\n" + (ex.StackTrace || ""), this);
                    return null;
                }
            },
            /*Spine.Unity.SpineAtlasAsset.GetAtlas end.*/

            /*Spine.Unity.SpineAtlasAsset.GenerateMesh start.*/
            GenerateMesh: function (name, mesh, material, scale) {
                if (scale === void 0) { scale = 0.01; }
                var region = this.atlas.findRegion(name);
                material.v = null;
                if (region != null) {
                    if (mesh == null) {
                        mesh = new UnityEngine.Mesh.ctor();
                        mesh.name = name;
                    }

                    var verts = System.Array.init(4, function (){
                        return new UnityEngine.Vector3();
                    }, UnityEngine.Vector3);
                    var uvs = System.Array.init(4, function (){
                        return new UnityEngine.Vector2();
                    }, UnityEngine.Vector2);
                    var colors = System.Array.init([
                        new pc.Color( 1, 1, 1, 1 ), 
                        new pc.Color( 1, 1, 1, 1 ), 
                        new pc.Color( 1, 1, 1, 1 ), 
                        new pc.Color( 1, 1, 1, 1 )
                    ], UnityEngine.Color);
                    var triangles = System.Array.init([
                        0, 
                        1, 
                        2, 
                        2, 
                        3, 
                        0
                    ], System.Int32);

                    var left, right, top, bottom;
                    left = region.width / -2.0;
                    right = left * -1.0;
                    top = region.height / 2.0;
                    bottom = top * -1;

                    verts[0] = new pc.Vec3( left, bottom, 0 ).clone().scale( scale );
                    verts[1] = new pc.Vec3( left, top, 0 ).clone().scale( scale );
                    verts[2] = new pc.Vec3( right, top, 0 ).clone().scale( scale );
                    verts[3] = new pc.Vec3( right, bottom, 0 ).clone().scale( scale );
                    var u, v, u2, v2;
                    u = region.u;
                    v = region.v;
                    u2 = region.u2;
                    v2 = region.v2;

                    if (region.degrees === 90) {
                        uvs[0] = new pc.Vec2( u2, v2 );
                        uvs[1] = new pc.Vec2( u, v2 );
                        uvs[2] = new pc.Vec2( u, v );
                        uvs[3] = new pc.Vec2( u2, v );
                    } else {
                        uvs[0] = new pc.Vec2( u, v2 );
                        uvs[1] = new pc.Vec2( u, v );
                        uvs[2] = new pc.Vec2( u2, v );
                        uvs[3] = new pc.Vec2( u2, v2 );
                    }

                    mesh.triangles = System.Array.init(0, 0, System.Int32);
                    mesh.vertices = verts;
                    mesh.uv = uvs;
                    mesh.colors = colors;
                    mesh.triangles = triangles;
                    mesh.RecalculateNormals();
                    mesh.RecalculateBounds();

                    material.v = Bridge.cast(region.page.rendererObject, UnityEngine.Material);
                } else {
                    mesh = null;
                }

                return mesh;
            },
            /*Spine.Unity.SpineAtlasAsset.GenerateMesh end.*/


        }
    });
    /*Spine.Unity.SpineAtlasAsset end.*/

    /*Spine.Unity.SpineAttachment start.*/
    Bridge.define("Spine.Unity.SpineAttachment", {
        inherits: [Spine.Unity.SpineAttributeBase],
        statics: {
            methods: {
                /*Spine.Unity.SpineAttachment.getHierarchy:static start.*/
                getHierarchy: function (fullPath) {
                    return new Spine.Unity.SpineAttachment.Hierarchy.$ctor1(fullPath);
                },
                /*Spine.Unity.SpineAttachment.getHierarchy:static end.*/

                /*Spine.Unity.SpineAttachment.getAttachment:static start.*/
                getAttachment: function (attachmentPath, skeletonData) {
                    var hierarchy = Spine.Unity.SpineAttachment.getHierarchy(attachmentPath);
                    if (System.String.isNullOrEmpty(hierarchy.name)) {
                        return null;
                    }

                    var slot = skeletonData.findSlot(hierarchy.slot);
                    if (slot == null) {
                        return null;
                    }
                    return skeletonData.findSkin(hierarchy.skin).getAttachment(slot.index, hierarchy.name);
                },
                /*Spine.Unity.SpineAttachment.getAttachment:static end.*/

                /*Spine.Unity.SpineAttachment.getAttachment$1:static start.*/
                getAttachment$1: function (attachmentPath, skeletonDataAsset) {
                    return Spine.Unity.SpineAttachment.getAttachment(attachmentPath, skeletonDataAsset.GetSkeletonData(true));
                },
                /*Spine.Unity.SpineAttachment.getAttachment$1:static end.*/


            }
        },
        fields: {
            returnAttachmentPath: false,
            currentSkinOnly: false,
            placeholdersOnly: false,
            skinField: null,
            slotField: null
        },
        ctors: {
            init: function () {
                this.returnAttachmentPath = false;
                this.currentSkinOnly = false;
                this.placeholdersOnly = false;
                this.skinField = "";
                this.slotField = "";
            },
            
            ctor: function (currentSkinOnly, returnAttachmentPath, placeholdersOnly, slotField, dataField, skinField, includeNone, fallbackToTextField) {
                if (currentSkinOnly === void 0) { currentSkinOnly = true; }
                if (returnAttachmentPath === void 0) { returnAttachmentPath = false; }
                if (placeholdersOnly === void 0) { placeholdersOnly = false; }
                if (slotField === void 0) { slotField = ""; }
                if (dataField === void 0) { dataField = ""; }
                if (skinField === void 0) { skinField = ""; }
                if (includeNone === void 0) { includeNone = true; }
                if (fallbackToTextField === void 0) { fallbackToTextField = false; }

                this.$initialize();
                Spine.Unity.SpineAttributeBase.ctor.call(this);
                this.currentSkinOnly = currentSkinOnly;
                this.returnAttachmentPath = returnAttachmentPath;
                this.placeholdersOnly = placeholdersOnly;
                this.slotField = slotField;
                this.dataField = dataField;
                this.skinField = skinField;
                this.includeNone = includeNone;
                this.fallbackToTextField = fallbackToTextField;
            }
        }
    });
    /*Spine.Unity.SpineAttachment end.*/

    /*Spine.Unity.SpineBone start.*/
    Bridge.define("Spine.Unity.SpineBone", {
        inherits: [Spine.Unity.SpineAttributeBase],
        statics: {
            methods: {
                /*Spine.Unity.SpineBone.getBone:static start.*/
                getBone: function (boneName, renderer) {
                    return renderer.skeleton == null ? null : renderer.skeleton.findBone(boneName);
                },
                /*Spine.Unity.SpineBone.getBone:static end.*/

                /*Spine.Unity.SpineBone.getBoneData:static start.*/
                getBoneData: function (boneName, skeletonDataAsset) {
                    var data = skeletonDataAsset.GetSkeletonData(true);
                    return data.findBone(boneName);
                },
                /*Spine.Unity.SpineBone.getBoneData:static end.*/


            }
        },
        ctors: {
            
            ctor: function (startsWith, dataField, includeNone, fallbackToTextField) {
                if (startsWith === void 0) { startsWith = ""; }
                if (dataField === void 0) { dataField = ""; }
                if (includeNone === void 0) { includeNone = true; }
                if (fallbackToTextField === void 0) { fallbackToTextField = false; }

                this.$initialize();
                Spine.Unity.SpineAttributeBase.ctor.call(this);
                this.startsWith = startsWith;
                this.dataField = dataField;
                this.includeNone = includeNone;
                this.fallbackToTextField = fallbackToTextField;
            }
        }
    });
    /*Spine.Unity.SpineBone end.*/

    /*Spine.Unity.SpineEvent start.*/
    Bridge.define("Spine.Unity.SpineEvent", {
        inherits: [Spine.Unity.SpineAttributeBase],
        fields: {
            /**
             * Smart popup menu for Spine Events (Spine.EventData)
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SpineEvent
             * @default false
             * @type boolean
             */
            audioOnly: false
        },
        ctors: {
            init: function () {
                this.audioOnly = false;
            },
            ctor: function (startsWith, dataField, includeNone, fallbackToTextField, audioOnly) {
                if (startsWith === void 0) { startsWith = ""; }
                if (dataField === void 0) { dataField = ""; }
                if (includeNone === void 0) { includeNone = true; }
                if (fallbackToTextField === void 0) { fallbackToTextField = false; }
                if (audioOnly === void 0) { audioOnly = false; }

                this.$initialize();
                Spine.Unity.SpineAttributeBase.ctor.call(this);
                this.startsWith = startsWith;
                this.dataField = dataField;
                this.includeNone = includeNone;
                this.fallbackToTextField = fallbackToTextField;
                this.audioOnly = audioOnly;
            }
        }
    });
    /*Spine.Unity.SpineEvent end.*/

    /*Spine.Unity.SpineIkConstraint start.*/
    Bridge.define("Spine.Unity.SpineIkConstraint", {
        inherits: [Spine.Unity.SpineAttributeBase],
        ctors: {
            /**
             * Smart popup menu for Spine IK Constraints (Spine.IkConstraint)
             *
             * @instance
             * @public
             * @this Spine.Unity.SpineIkConstraint
             * @memberof Spine.Unity.SpineIkConstraint
             * @param   {string}     startsWith             Filters popup results to elements that begin with supplied string.
             * @param   {string}     dataField              If specified, a locally scoped field with the name supplied by in dataField will be used to fill the popup results.
             Valid types are SkeletonDataAsset and SkeletonRenderer (and derivatives).
             If left empty and the script the attribute is applied to is derived from Component, GetComponent(SkeletonRenderer)() will be called as a fallback.
             * @param   {boolean}    includeNone            If true, the dropdown list will include a "none" option which stored as an empty string.
             * @param   {boolean}    fallbackToTextField    If true, and an animation list source can't be found, the field will fall back to a normal text field. If false, it will show an error.
             * @return  {void}
             */
            ctor: function (startsWith, dataField, includeNone, fallbackToTextField) {
                if (startsWith === void 0) { startsWith = ""; }
                if (dataField === void 0) { dataField = ""; }
                if (includeNone === void 0) { includeNone = true; }
                if (fallbackToTextField === void 0) { fallbackToTextField = false; }

                this.$initialize();
                Spine.Unity.SpineAttributeBase.ctor.call(this);
                this.startsWith = startsWith;
                this.dataField = dataField;
                this.includeNone = includeNone;
                this.fallbackToTextField = fallbackToTextField;
            }
        }
    });
    /*Spine.Unity.SpineIkConstraint end.*/

    /*Spine.Unity.SpinePathConstraint start.*/
    Bridge.define("Spine.Unity.SpinePathConstraint", {
        inherits: [Spine.Unity.SpineAttributeBase],
        ctors: {
            /**
             * Smart popup menu for Spine Events (Spine.PathConstraint)
             *
             * @instance
             * @public
             * @this Spine.Unity.SpinePathConstraint
             * @memberof Spine.Unity.SpinePathConstraint
             * @param   {string}     startsWith             Filters popup results to elements that begin with supplied string.
             * @param   {string}     dataField              If specified, a locally scoped field with the name supplied by in dataField will be used to fill the popup results.
             Valid types are SkeletonDataAsset and SkeletonRenderer (and derivatives).
             If left empty and the script the attribute is applied to is derived from Component, GetComponent(SkeletonRenderer)() will be called as a fallback.
             * @param   {boolean}    includeNone            If true, the dropdown list will include a "none" option which stored as an empty string.
             * @param   {boolean}    fallbackToTextField
             * @return  {void}
             */
            ctor: function (startsWith, dataField, includeNone, fallbackToTextField) {
                if (startsWith === void 0) { startsWith = ""; }
                if (dataField === void 0) { dataField = ""; }
                if (includeNone === void 0) { includeNone = true; }
                if (fallbackToTextField === void 0) { fallbackToTextField = false; }

                this.$initialize();
                Spine.Unity.SpineAttributeBase.ctor.call(this);
                this.startsWith = startsWith;
                this.dataField = dataField;
                this.includeNone = includeNone;
                this.fallbackToTextField = fallbackToTextField;
            }
        }
    });
    /*Spine.Unity.SpinePathConstraint end.*/

    /*Spine.Unity.SpineSkin start.*/
    Bridge.define("Spine.Unity.SpineSkin", {
        inherits: [Spine.Unity.SpineAttributeBase],
        fields: {
            
            defaultAsEmptyString: false
        },
        ctors: {
            init: function () {
                this.defaultAsEmptyString = false;
            },
            ctor: function (startsWith, dataField, includeNone, fallbackToTextField, defaultAsEmptyString) {
                if (startsWith === void 0) { startsWith = ""; }
                if (dataField === void 0) { dataField = ""; }
                if (includeNone === void 0) { includeNone = true; }
                if (fallbackToTextField === void 0) { fallbackToTextField = false; }
                if (defaultAsEmptyString === void 0) { defaultAsEmptyString = false; }

                this.$initialize();
                Spine.Unity.SpineAttributeBase.ctor.call(this);
                this.startsWith = startsWith;
                this.dataField = dataField;
                this.includeNone = includeNone;
                this.fallbackToTextField = fallbackToTextField;
                this.defaultAsEmptyString = defaultAsEmptyString;
            }
        }
    });
    /*Spine.Unity.SpineSkin end.*/

    /*Spine.Unity.SpineSlot start.*/
    Bridge.define("Spine.Unity.SpineSlot", {
        inherits: [Spine.Unity.SpineAttributeBase],
        fields: {
            containsBoundingBoxes: false
        },
        ctors: {
            init: function () {
                this.containsBoundingBoxes = false;
            },
            
            ctor: function (startsWith, dataField, containsBoundingBoxes, includeNone, fallbackToTextField) {
                if (startsWith === void 0) { startsWith = ""; }
                if (dataField === void 0) { dataField = ""; }
                if (containsBoundingBoxes === void 0) { containsBoundingBoxes = false; }
                if (includeNone === void 0) { includeNone = true; }
                if (fallbackToTextField === void 0) { fallbackToTextField = false; }

                this.$initialize();
                Spine.Unity.SpineAttributeBase.ctor.call(this);
                this.startsWith = startsWith;
                this.dataField = dataField;
                this.containsBoundingBoxes = containsBoundingBoxes;
                this.includeNone = includeNone;
                this.fallbackToTextField = fallbackToTextField;
            }
        }
    });
    /*Spine.Unity.SpineSlot end.*/

    /*Spine.Unity.SpineSpriteAtlasAsset start.*/
    /**
     * Loads and stores a Spine atlas and list of materials.
     *
     * @public
     * @class Spine.Unity.SpineSpriteAtlasAsset
     * @augments Spine.Unity.AtlasAssetBase
     */
    Bridge.define("Spine.Unity.SpineSpriteAtlasAsset", {
        inherits: [Spine.Unity.AtlasAssetBase],
        statics: {
            methods: {
                /*Spine.Unity.SpineSpriteAtlasAsset.CreateRuntimeInstance:static start.*/
                /**
                 * Creates a runtime AtlasAsset
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SpineSpriteAtlasAsset
                 * @memberof Spine.Unity.SpineSpriteAtlasAsset
                 * @param   {UnityEngine.U2D.SpriteAtlas}          spriteAtlasFile    
                 * @param   {Array.<UnityEngine.Material>}         materials          
                 * @param   {boolean}                              initialize
                 * @return  {Spine.Unity.SpineSpriteAtlasAsset}
                 */
                CreateRuntimeInstance: function (spriteAtlasFile, materials, initialize) {
                    var atlasAsset = UnityEngine.ScriptableObject.CreateInstance(Spine.Unity.SpineSpriteAtlasAsset);
                    atlasAsset.Reset();
                    atlasAsset.spriteAtlasFile = spriteAtlasFile;
                    atlasAsset.materials = materials;

                    if (initialize) {
                        atlasAsset.GetAtlas();
                    }

                    return atlasAsset;
                },
                /*Spine.Unity.SpineSpriteAtlasAsset.CreateRuntimeInstance:static end.*/

                /*Spine.Unity.SpineSpriteAtlasAsset.AccessPackedTexture:static start.*/
                AccessPackedTexture: function (sprites) {
                    return sprites[0].texture;
                },
                /*Spine.Unity.SpineSpriteAtlasAsset.AccessPackedTexture:static end.*/

                /*Spine.Unity.SpineSpriteAtlasAsset.AccessPackedSprites:static start.*/
                AccessPackedSprites: function (spriteAtlas) {
                    var sprites = null;
                    if (sprites == null) {
                        sprites = System.Array.init(spriteAtlas.spriteCount, null, UnityEngine.Sprite);
                        spriteAtlas.GetSprites(sprites);
                        if (sprites.length === 0) {
                            return null;
                        }
                    }
                    return sprites;
                },
                /*Spine.Unity.SpineSpriteAtlasAsset.AccessPackedSprites:static end.*/


            }
        },
        fields: {
            spriteAtlasFile: null,
            materials: null,
            atlas: null,
            updateRegionsInPlayMode: false,
            savedRegions: null
        },
        props: {
            IsLoaded: {
                get: function () {
                    return this.atlas != null;
                }
            },
            Materials: {
                get: function () {
                    return this.materials;
                }
            },
            MaterialCount: {
                get: function () {
                    return this.materials == null ? 0 : this.materials.length;
                }
            },
            PrimaryMaterial: {
                get: function () {
                    return this.materials[0];
                }
            }
        },
        methods: {
            /*Spine.Unity.SpineSpriteAtlasAsset.Reset start.*/
            Reset: function () {
                this.Clear();
            },
            /*Spine.Unity.SpineSpriteAtlasAsset.Reset end.*/

            /*Spine.Unity.SpineSpriteAtlasAsset.Clear start.*/
            Clear: function () {
                this.atlas = null;
            },
            /*Spine.Unity.SpineSpriteAtlasAsset.Clear end.*/

            /*Spine.Unity.SpineSpriteAtlasAsset.GetAtlas start.*/
            /**
             * @instance
             * @public
             * @override
             * @this Spine.Unity.SpineSpriteAtlasAsset
             * @memberof Spine.Unity.SpineSpriteAtlasAsset
             * @param   {boolean}        onlyMetaData
             * @return  {Spine.Atlas}                    The atlas or null if it could not be loaded.
             */
            GetAtlas: function (onlyMetaData) {
                if (onlyMetaData === void 0) { onlyMetaData = false; }
                if (this.spriteAtlasFile == null) {
                    UnityEngine.Debug.LogError$2("SpriteAtlas file not set for SpineSpriteAtlasAsset: " + (this.name || ""), this);
                    this.Clear();
                    return null;
                }

                if (!onlyMetaData && (this.materials == null || this.materials.length === 0)) {
                    UnityEngine.Debug.LogError$2("Materials not set for SpineSpriteAtlasAsset: " + (this.name || ""), this);
                    this.Clear();
                    return null;
                }

                if (this.atlas != null) {
                    return this.atlas;
                }

                try {
                    this.atlas = this.LoadAtlas(this.spriteAtlasFile);
                    return this.atlas;
                } catch (ex) {
                    ex = System.Exception.create(ex);
                    UnityEngine.Debug.LogError$2("Error analyzing SpriteAtlas for SpineSpriteAtlasAsset: " + (this.name || "") + "\n" + (ex.Message || "") + "\n" + (ex.StackTrace || ""), this);
                    return null;
                }
            },
            /*Spine.Unity.SpineSpriteAtlasAsset.GetAtlas end.*/

            /*Spine.Unity.SpineSpriteAtlasAsset.AssignRegionsFromSavedRegions start.*/
            AssignRegionsFromSavedRegions: function (sprites, usedAtlas) {
                var $t;

                if (this.savedRegions == null || this.savedRegions.length !== sprites.length) {
                    return;
                }

                var i = 0;
                $t = Bridge.getEnumerator(usedAtlas);
                try {
                    while ($t.moveNext()) {
                        var region = $t.Current;
                        var savedRegion = this.savedRegions[i];
                        var page = region.page;

                        region.degrees = savedRegion.packingRotation === UnityEngine.SpritePackingRotation.None ? 0 : 90;

                        var x = savedRegion.x;
                        var y = savedRegion.y;
                        var width = savedRegion.width;
                        var height = savedRegion.height;

                        region.u = x / page.width;
                        region.v = y / page.height;
                        if (region.degrees === 90) {
                            region.u2 = (x + height) / page.width;
                            region.v2 = (y + width) / page.height;
                        } else {
                            region.u2 = (x + width) / page.width;
                            region.v2 = (y + height) / page.height;
                        }
                        region.x = Bridge.Int.clip32(x);
                        region.y = Bridge.Int.clip32(y);
                        region.width = Math.abs(Bridge.Int.clip32(width));
                        region.height = Math.abs(Bridge.Int.clip32(height));

                        // flip upside down
                        var temp = region.v;
                        region.v = region.v2;
                        region.v2 = temp;

                        region.originalWidth = Bridge.Int.clip32(width);
                        region.originalHeight = Bridge.Int.clip32(height);

                        // note: currently sprite pivot offsets are ignored.
                        // Sprite sprite = sprites[i];
                        region.offsetX = 0; //sprite.pivot.x;
                        region.offsetY = 0; //sprite.pivot.y;

                        i = (i + 1) | 0;
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.Unity.SpineSpriteAtlasAsset.AssignRegionsFromSavedRegions end.*/

            /*Spine.Unity.SpineSpriteAtlasAsset.LoadAtlas start.*/
            LoadAtlas: function (spriteAtlas) {

                var pages = new (System.Collections.Generic.List$1(Spine.AtlasPage)).ctor();
                var regions = new (System.Collections.Generic.List$1(Spine.AtlasRegion)).ctor();

                var sprites = System.Array.init(spriteAtlas.spriteCount, null, UnityEngine.Sprite);
                spriteAtlas.GetSprites(sprites);
                if (sprites.length === 0) {
                    return new Spine.Atlas.ctor(pages, regions);
                }

                var texture = null;
                texture = Spine.Unity.SpineSpriteAtlasAsset.AccessPackedTexture(sprites);

                var material = this.materials[0];
                material.mainTexture = texture;

                var page = new Spine.AtlasPage();
                page.name = spriteAtlas.name;
                page.width = texture.width;
                page.height = texture.height;
                page.format = Spine.Format.RGBA8888;

                page.minFilter = spine.TextureFilter.Linear;
                page.magFilter = spine.TextureFilter.Linear;
                page.uWrap = spine.TextureWrap.ClampToEdge;
                page.vWrap = spine.TextureWrap.ClampToEdge;
                page.rendererObject = material;
                pages.add(page);

                sprites = Spine.Unity.SpineSpriteAtlasAsset.AccessPackedSprites(spriteAtlas);

                var i = 0;
                for (; i < sprites.length; i = (i + 1) | 0) {
                    var sprite = sprites[i];
                    var region = new Spine.AtlasRegion();
                    region.name = System.String.replaceAll(sprite.name, "(Clone)", "");
                    region.page = page;
                    region.degrees = sprite.packingRotation === UnityEngine.SpritePackingRotation.None ? 0 : 90;

                    region.u2 = 1;
                    region.v2 = 1;
                    region.width = page.width;
                    region.height = page.height;
                    region.originalWidth = page.width;
                    region.originalHeight = page.height;

                    region.index = i;
                    regions.add(region);
                }

                var atlas = new Spine.Atlas.ctor(pages, regions);
                this.AssignRegionsFromSavedRegions(sprites, atlas);

                return atlas;
            },
            /*Spine.Unity.SpineSpriteAtlasAsset.LoadAtlas end.*/


        }
    });
    /*Spine.Unity.SpineSpriteAtlasAsset end.*/

    /*Spine.Unity.SpineTransformConstraint start.*/
    Bridge.define("Spine.Unity.SpineTransformConstraint", {
        inherits: [Spine.Unity.SpineAttributeBase],
        ctors: {
            
            ctor: function (startsWith, dataField, includeNone, fallbackToTextField) {
                if (startsWith === void 0) { startsWith = ""; }
                if (dataField === void 0) { dataField = ""; }
                if (includeNone === void 0) { includeNone = true; }
                if (fallbackToTextField === void 0) { fallbackToTextField = false; }

                this.$initialize();
                Spine.Unity.SpineAttributeBase.ctor.call(this);
                this.startsWith = startsWith;
                this.dataField = dataField;
                this.includeNone = includeNone;
                this.fallbackToTextField = fallbackToTextField;
            }
        }
    });
    /*Spine.Unity.SpineTransformConstraint end.*/

    /*Spine.Unity.WaitForSpineAnimationComplete start.*/
    /**
     * Use this as a condition-blocking yield instruction for Unity Coroutines.
     The routine will pause until the AnimationState.TrackEntry fires its Complete event.
     It can be configured to trigger on the End event as well to cover interruption.
     <p />
     See the {@link }
     and {@link }
     for more information on when track events will be triggered.
     *
     * @public
     * @class Spine.Unity.WaitForSpineAnimationComplete
     * @augments Spine.Unity.WaitForSpineAnimation
     * @implements  System.Collections.IEnumerator
     */
    Bridge.define("Spine.Unity.WaitForSpineAnimationComplete", {
        inherits: [Spine.Unity.WaitForSpineAnimation,System.Collections.IEnumerator],
        ctors: {
            ctor: function (trackEntry, includeEndEvent) {
                if (includeEndEvent === void 0) { includeEndEvent = false; }

                this.$initialize();
                Spine.Unity.WaitForSpineAnimation.ctor.call(this, trackEntry, includeEndEvent ? (20) : Spine.Unity.WaitForSpineAnimation.AnimationEventTypes.Complete);
            }
        },
        methods: {
            /*Spine.Unity.WaitForSpineAnimationComplete.NowWaitFor$1 start.*/
            /**
             * One optimization high-frequency YieldInstruction returns is to cache instances to minimize GC pressure.
             Use NowWaitFor to reuse the same instance of WaitForSpineAnimationComplete.
             *
             * @instance
             * @public
             * @this Spine.Unity.WaitForSpineAnimationComplete
             * @memberof Spine.Unity.WaitForSpineAnimationComplete
             * @param   {Spine.TrackEntry}                             trackEntry         
             * @param   {boolean}                                      includeEndEvent
             * @return  {Spine.Unity.WaitForSpineAnimationComplete}
             */
            NowWaitFor$1: function (trackEntry, includeEndEvent) {
                if (includeEndEvent === void 0) { includeEndEvent = false; }
                this.SafeSubscribe(trackEntry, includeEndEvent ? (20) : Spine.Unity.WaitForSpineAnimation.AnimationEventTypes.Complete);
                return this;
            },
            /*Spine.Unity.WaitForSpineAnimationComplete.NowWaitFor$1 end.*/


        },
        overloads: {
            "NowWaitFor(Spine.TrackEntry, bool)": "NowWaitFor$1"
        }
    });
    /*Spine.Unity.WaitForSpineAnimationComplete end.*/

    /*Spine.Unity.WaitForSpineAnimationEnd start.*/
    /**
     * Use this as a condition-blocking yield instruction for Unity Coroutines.
     The routine will pause until the AnimationState.TrackEntry fires its End event.
     <p />
     See the {@link }
     and {@link }
     for more information on when track events will be triggered.
     *
     * @public
     * @class Spine.Unity.WaitForSpineAnimationEnd
     * @augments Spine.Unity.WaitForSpineAnimation
     * @implements  System.Collections.IEnumerator
     */
    Bridge.define("Spine.Unity.WaitForSpineAnimationEnd", {
        inherits: [Spine.Unity.WaitForSpineAnimation,System.Collections.IEnumerator],
        ctors: {
            ctor: function (trackEntry) {
                this.$initialize();
                Spine.Unity.WaitForSpineAnimation.ctor.call(this, trackEntry, Spine.Unity.WaitForSpineAnimation.AnimationEventTypes.End);
            }
        },
        methods: {
            /*Spine.Unity.WaitForSpineAnimationEnd.NowWaitFor$1 start.*/
            /**
             * One optimization high-frequency YieldInstruction returns is to cache instances to minimize GC pressure.
             Use NowWaitFor to reuse the same instance of WaitForSpineAnimationComplete.
             *
             * @instance
             * @public
             * @this Spine.Unity.WaitForSpineAnimationEnd
             * @memberof Spine.Unity.WaitForSpineAnimationEnd
             * @param   {Spine.TrackEntry}                        trackEntry
             * @return  {Spine.Unity.WaitForSpineAnimationEnd}
             */
            NowWaitFor$1: function (trackEntry) {
                this.SafeSubscribe(trackEntry, Spine.Unity.WaitForSpineAnimation.AnimationEventTypes.End);
                return this;
            },
            /*Spine.Unity.WaitForSpineAnimationEnd.NowWaitFor$1 end.*/


        },
        overloads: {
            "NowWaitFor(Spine.TrackEntry)": "NowWaitFor$1"
        }
    });
    /*Spine.Unity.WaitForSpineAnimationEnd end.*/

    /*Spine.Unity.AnimationReferenceAsset start.*/
    Bridge.define("Spine.Unity.AnimationReferenceAsset", {
        inherits: [UnityEngine.ScriptableObject,Spine.Unity.IHasSkeletonDataAsset],
        statics: {
            fields: {
                QuietSkeletonData: false
            },
            ctors: {
                init: function () {
                    this.QuietSkeletonData = true;
                }
            },
            methods: {
                op_Implicit: function (asset) {
                    return asset.Animation;
                }
            }
        },
        fields: {
            skeletonDataAsset: null,
            animationName: null,
            animation: null
        },
        props: {
            SkeletonDataAsset: {
                get: function () {
                    return this.skeletonDataAsset;
                }
            },
            Animation: {
                get: function () {
                    if (this.animation == null) {
                        this.Initialize();
                    }
                    return this.animation;
                }
            }
        },
        alias: ["SkeletonDataAsset", "Spine$Unity$IHasSkeletonDataAsset$SkeletonDataAsset"],
        methods: {
            /*Spine.Unity.AnimationReferenceAsset.Clear start.*/
            /**
             * Clears the cached animation corresponding to a loaded SkeletonData object.
             Use this to force a reload for the next time Animation is called.
             *
             * @instance
             * @public
             * @this Spine.Unity.AnimationReferenceAsset
             * @memberof Spine.Unity.AnimationReferenceAsset
             * @return  {void}
             */
            Clear: function () {
                this.animation = null;
            },
            /*Spine.Unity.AnimationReferenceAsset.Clear end.*/

            /*Spine.Unity.AnimationReferenceAsset.Initialize start.*/
            Initialize: function () {
                if (this.skeletonDataAsset == null) {
                    return;
                }
                var skeletonData = this.skeletonDataAsset.GetSkeletonData(Spine.Unity.AnimationReferenceAsset.QuietSkeletonData);
                this.animation = skeletonData != null ? skeletonData.findAnimation(this.animationName) : null;
                if (this.animation == null) {
                    UnityEngine.Debug.LogWarningFormat("Animation '{0}' not found in SkeletonData : {1}.", [this.animationName, this.skeletonDataAsset.name]);
                }
            },
            /*Spine.Unity.AnimationReferenceAsset.Initialize end.*/


        }
    });
    /*Spine.Unity.AnimationReferenceAsset end.*/

    /*Spine.Unity.PointFollower start.*/
    Bridge.define("Spine.Unity.PointFollower", {
        inherits: [UnityEngine.MonoBehaviour,Spine.Unity.IHasSkeletonRenderer,Spine.Unity.IHasSkeletonComponent],
        fields: {
            skeletonRenderer: null,
            slotName: null,
            pointAttachmentName: null,
            followRotation: false,
            followSkeletonFlip: false,
            followSkeletonZPosition: false,
            skeletonTransform: null,
            skeletonTransformIsParent: false,
            point: null,
            bone: null,
            valid: false
        },
        props: {
            SkeletonRenderer: {
                get: function () {
                    return this.skeletonRenderer;
                }
            },
            SkeletonComponent: {
                get: function () {
                    return Bridge.as(this.skeletonRenderer, Spine.Unity.ISkeletonComponent);
                }
            },
            IsValid: {
                get: function () {
                    return this.valid;
                }
            }
        },
        alias: [
            "SkeletonRenderer", "Spine$Unity$IHasSkeletonRenderer$SkeletonRenderer",
            "SkeletonComponent", "Spine$Unity$IHasSkeletonComponent$SkeletonComponent"
        ],
        ctors: {
            init: function () {
                this.followRotation = true;
                this.followSkeletonFlip = true;
                this.followSkeletonZPosition = false;
            }
        },
        methods: {
            /*Spine.Unity.PointFollower.Initialize start.*/
            Initialize: function () {
                this.valid = UnityEngine.MonoBehaviour.op_Inequality(this.skeletonRenderer, null) && this.skeletonRenderer.valid;
                if (!this.valid) {
                    return;
                }

                this.UpdateReferences();

            },
            /*Spine.Unity.PointFollower.Initialize end.*/

            /*Spine.Unity.PointFollower.HandleRebuildRenderer start.*/
            HandleRebuildRenderer: function (skeletonRenderer) {
                this.Initialize();
            },
            /*Spine.Unity.PointFollower.HandleRebuildRenderer end.*/

            /*Spine.Unity.PointFollower.UpdateReferences start.*/
            UpdateReferences: function () {
                this.skeletonTransform = this.skeletonRenderer.transform;
                this.skeletonRenderer.removeOnRebuild(Bridge.fn.cacheBind(this, this.HandleRebuildRenderer));
                this.skeletonRenderer.addOnRebuild(Bridge.fn.cacheBind(this, this.HandleRebuildRenderer));
                this.skeletonTransformIsParent = Bridge.referenceEquals(this.skeletonTransform, this.transform.parent);

                this.bone = null;
                this.point = null;
                if (!System.String.isNullOrEmpty(this.pointAttachmentName)) {
                    var skeleton = this.skeletonRenderer.Skeleton;

                    var slot = skeleton.findSlot(this.slotName);
                    if (slot != null) {
                        var slotIndex = slot.data.index;
                        this.bone = slot.bone;
                        this.point = Bridge.as(skeleton.getAttachment(slotIndex, this.pointAttachmentName), Spine.PointAttachment);
                    }
                }
            },
            /*Spine.Unity.PointFollower.UpdateReferences end.*/

            /*Spine.Unity.PointFollower.OnDestroy start.*/
            OnDestroy: function () {
                if (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonRenderer, null)) {
                    this.skeletonRenderer.removeOnRebuild(Bridge.fn.cacheBind(this, this.HandleRebuildRenderer));
                }
            },
            /*Spine.Unity.PointFollower.OnDestroy end.*/

            /*Spine.Unity.PointFollower.LateUpdate start.*/
            LateUpdate: function () {
                var $t;

                if (this.point == null) {
                    if (System.String.isNullOrEmpty(this.pointAttachmentName)) {
                        return;
                    }
                    this.UpdateReferences();
                    if (this.point == null) {
                        return;
                    }
                }

                var worldPos = new UnityEngine.Vector2();
                this.point.ComputeWorldPosition(this.bone, Bridge.ref(worldPos, "x"), Bridge.ref(worldPos, "y"));
                var rotation = this.point.computeWorldRotation(this.bone);

                var thisTransform = this.transform;
                if (this.skeletonTransformIsParent) {
                    // Recommended setup: Use local transform properties if Spine GameObject is the immediate parent
                    thisTransform.localPosition = new pc.Vec3( worldPos.x, worldPos.y, this.followSkeletonZPosition ? 0.0 : thisTransform.localPosition.z );
                    if (this.followRotation) {
                        var halfRotation = rotation * 0.5 * UnityEngine.Mathf.Deg2Rad;

                        var q = Bridge.getDefaultValue(UnityEngine.Quaternion);
                        q.z = Math.sin(halfRotation);
                        q.w = Math.cos(halfRotation);
                        thisTransform.localRotation = q.$clone();
                    }
                } else {
                    // For special cases: Use transform world properties if transform relationship is complicated
                    var targetWorldPosition = this.skeletonTransform.TransformPoint$1(new pc.Vec3( worldPos.x, worldPos.y, 0.0 ));
                    if (!this.followSkeletonZPosition) {
                        targetWorldPosition.z = thisTransform.position.z;
                    }

                    var transformParent = thisTransform.parent;
                    if (UnityEngine.Component.op_Inequality(transformParent, null)) {
                        var m = transformParent.localToWorldMatrix.$clone();
                        if (m.e00 * m.e11 - m.e01 * m.e10 < 0) {
                            rotation = -rotation;
                        }
                    }

                    if (this.followRotation) {
                        var transformWorldRotation = this.skeletonTransform.rotation.getPositiveEulerAngles().$clone();
                        thisTransform.SetPositionAndRotation(targetWorldPosition.$clone(), new pc.Quat().setFromEulerAngles_Unity( transformWorldRotation.x, transformWorldRotation.y, transformWorldRotation.z + rotation ));
                    } else {
                        thisTransform.position = targetWorldPosition.$clone();
                    }
                }

                if (this.followSkeletonFlip) {
                    var localScale = thisTransform.localScale.$clone();
                    localScale.y = Math.abs(localScale.y) * ($t = this.bone.skeleton.scaleX * this.bone.skeleton.scaleY, ($t === 0 ? 1 : Math.sign($t)));
                    thisTransform.localScale = localScale.$clone();
                }
            },
            /*Spine.Unity.PointFollower.LateUpdate end.*/


        }
    });
    /*Spine.Unity.PointFollower end.*/
    /**
     * @memberof Spine.Unity
     * @callback Spine.Unity.SkeletonRenderer.InstructionDelegate
     * @param   {Spine.Unity.SkeletonRendererInstruction}    instruction
     * @return  {void}
     */

    /**
     * @memberof Spine.Unity
     * @callback Spine.Unity.MeshGeneratorDelegate
     * @param   {Spine.Unity.MeshGeneratorBuffers}    buffers
     * @return  {void}
     */


    /*Spine.Unity.SkeletonRenderer start.*/
    /**
     * Base class of animated Spine skeleton components. This component manages and renders a skeleton.
     *
     * @public
     * @class Spine.Unity.SkeletonRenderer
     * @augments UnityEngine.MonoBehaviour
     * @implements  Spine.Unity.ISkeletonComponent
     * @implements  Spine.Unity.IHasSkeletonDataAsset
     */
    Bridge.define("Spine.Unity.SkeletonRenderer", {
        inherits: [UnityEngine.MonoBehaviour,Spine.Unity.ISkeletonComponent,Spine.Unity.IHasSkeletonDataAsset],
        statics: {
            fields: {
                /**
                 * Shader property value used as Stencil comparison function for {@link }.
                 *
                 * @static
                 * @public
                 * @memberof Spine.Unity.SkeletonRenderer
                 * @constant
                 * @default 8
                 * @type UnityEngine.Rendering.CompareFunction
                 */
                STENCIL_COMP_MASKINTERACTION_NONE: 0,
                /**
                 * Shader property value used as Stencil comparison function for {@link }.
                 *
                 * @static
                 * @public
                 * @memberof Spine.Unity.SkeletonRenderer
                 * @constant
                 * @default 4
                 * @type UnityEngine.Rendering.CompareFunction
                 */
                STENCIL_COMP_MASKINTERACTION_VISIBLE_INSIDE: 0,
                /**
                 * Shader property value used as Stencil comparison function for {@link }.
                 *
                 * @static
                 * @public
                 * @memberof Spine.Unity.SkeletonRenderer
                 * @constant
                 * @default 5
                 * @type UnityEngine.Rendering.CompareFunction
                 */
                STENCIL_COMP_MASKINTERACTION_VISIBLE_OUTSIDE: 0,
                /**
                 * Shader property ID used for the Stencil comparison function.
                 *
                 * @static
                 * @public
                 * @readonly
                 * @memberof Spine.Unity.SkeletonRenderer
                 * @type number
                 */
                STENCIL_COMP_PARAM_ID: 0,
                SUBMESH_DUMMY_PARAM_ID: 0
            },
            ctors: {
                init: function () {
                    this.STENCIL_COMP_MASKINTERACTION_NONE = UnityEngine.Rendering.CompareFunction.Always;
                    this.STENCIL_COMP_MASKINTERACTION_VISIBLE_INSIDE = UnityEngine.Rendering.CompareFunction.LessEqual;
                    this.STENCIL_COMP_MASKINTERACTION_VISIBLE_OUTSIDE = UnityEngine.Rendering.CompareFunction.Greater;
                    this.STENCIL_COMP_PARAM_ID = UnityEngine.Shader.PropertyToID("_StencilComp");
                    this.SUBMESH_DUMMY_PARAM_ID = UnityEngine.Shader.PropertyToID("_Submesh");
                }
            },
            methods: {
                /*Spine.Unity.SkeletonRenderer.NewSpineGameObject:static start.*/
                NewSpineGameObject: function (T, skeletonDataAsset, quiet) {
                    if (quiet === void 0) { quiet = false; }
                    return Spine.Unity.SkeletonRenderer.AddSpineComponent(T, new UnityEngine.GameObject.$ctor2("New Spine GameObject"), skeletonDataAsset, quiet);
                },
                /*Spine.Unity.SkeletonRenderer.NewSpineGameObject:static end.*/

                /*Spine.Unity.SkeletonRenderer.AddSpineComponent:static start.*/
                /**
                 * Add and prepare a Spine component that derives from SkeletonRenderer to a GameObject at runtime.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonRenderer
                 * @memberof Spine.Unity.SkeletonRenderer
                 * @param   {Function}                         T                    T should be SkeletonRenderer or any of its derived classes.
                 * @param   {UnityEngine.GameObject}           gameObject           
                 * @param   {Spine.Unity.SkeletonDataAsset}    skeletonDataAsset    
                 * @param   {boolean}                          quiet
                 * @return  {T}
                 */
                AddSpineComponent: function (T, gameObject, skeletonDataAsset, quiet) {
                    if (quiet === void 0) { quiet = false; }
                    var c = Bridge.rValue(gameObject.AddComponent(T));
                    if (skeletonDataAsset != null) {
Bridge.rValue(                        c).skeletonDataAsset = skeletonDataAsset;
Bridge.rValue(                        c).Initialize(false, quiet);
                    }
                    return Bridge.rValue(c);
                },
                /*Spine.Unity.SkeletonRenderer.AddSpineComponent:static end.*/


            }
        },
        fields: {
            skeletonDataAsset: null,
            /**
             * Skin name to use when the Skeleton is initialized.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @type string
             */
            initialSkinName: null,
            /**
             * Enable this parameter when overwriting the Skeleton's skin from an editor script.
             Otherwise any changes will be overwritten by the next inspector update.
             * Flip X and Y to use when the Skeleton is initialized.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @type boolean
             */
            initialFlipX: false,
            /**
             * Enable this parameter when overwriting the Skeleton's skin from an editor script.
             Otherwise any changes will be overwritten by the next inspector update.
             * Flip X and Y to use when the Skeleton is initialized.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @type boolean
             */
            initialFlipY: false,
            updateMode: 0,
            /**
             * Update mode used when the MeshRenderer becomes invisible
             (when <pre><code>OnBecameInvisible()</code></pre> is called). Update mode is automatically
             reset to <pre><code>UpdateMode.FullUpdate</code></pre> when the mesh becomes visible again.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @type Spine.Unity.UpdateMode
             */
            updateWhenInvisible: 0,
            /**
             * Slot names used to populate separatorSlots list when the Skeleton is initialized. Changing this after initialization does nothing.
             *
             * @instance
             * @protected
             * @memberof Spine.Unity.SkeletonRenderer
             * @type Array.<string>
             */
            separatorSlotNames: null,
            /**
             * Slots that determine where the render is split. This is used by components such as SkeletonRenderSeparator so that the skeleton can be rendered by two separate renderers on different GameObjects.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Unity.SkeletonRenderer
             * @type System.Collections.Generic.List$1
             */
            separatorSlots: null,
            zSpacing: 0,
            /**
             * Use Spine's clipping feature. If false, ClippingAttachments will be ignored.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @default true
             * @type boolean
             */
            useClipping: false,
            /**
             * If true, triangles will not be updated. Enable this as an optimization if the skeleton does not make use of attachment swapping or hiding, or draw order keys. Otherwise, setting this to false may cause errors in rendering.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @default false
             * @type boolean
             */
            immutableTriangles: false,
            /**
             * Multiply vertex color RGB with vertex color alpha. Set this to true if the shader used for rendering is a premultiplied alpha shader. Setting this to false disables single-batch additive slots.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @default true
             * @type boolean
             */
            pmaVertexColors: false,
            /**
             * Clears the state of the render and skeleton when this component or its GameObject is disabled. This prevents previous state from being retained when it is enabled again. When pooling your skeleton, setting this to true can be helpful.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @default false
             * @type boolean
             */
            clearStateOnDisable: false,
            /**
             * If true, second colors on slots will be added to the output Mesh as UV2 and UV3. A special "tint black" shader that interprets UV2 and UV3 as black point colors is required to render this properly.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @default false
             * @type boolean
             */
            tintBlack: false,
            /**
             * If true, the renderer assumes the skeleton only requires one Material and one submesh to render. This allows the MeshGenerator to skip checking for changes in Materials. Enable this as an optimization if the skeleton only uses one Material.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @default false
             * @type boolean
             */
            singleSubmesh: false,
            /**
             * Applies only when 3+ submeshes are used (2+ materials with alternating order, e.g. "A B A").
             If true, GPU instancing is disabled at all materials and MaterialPropertyBlocks are assigned at each
             material to prevent aggressive batching of submeshes by e.g. the LWRP renderer, leading to incorrect
             draw order (e.g. "A1 B A2" changed to "A1A2 B").
             You can disable this parameter when everything is drawn correctly to save the additional performance cost.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @default false
             * @type boolean
             */
            fixDrawOrder: false,
            /**
             * If true, the mesh generator adds normals to the output mesh. For better performance and reduced memory requirements, use a shader that assumes the desired normal.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @default false
             * @type boolean
             */
            addNormals: false,
            /**
             * If true, tangents are calculated every frame and added to the Mesh. Enable this when using a shader that uses lighting that requires tangents.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @default false
             * @type boolean
             */
            calculateTangents: false,
            /**
             * This enum controls the mode under which the sprite will interact with the masking system.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @type UnityEngine.SpriteMaskInteraction
             */
            maskInteraction: 0,
            /**
             * Material references for switching material sets at runtime when {@link } changes.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @type Spine.Unity.SkeletonRenderer.SpriteMaskInteractionMaterials
             */
            maskMaterials: null,
            disableRenderingOnOverride: false,
            customMaterialOverride: null,
            customSlotMaterials: null,
            currentInstructions: null,
            meshGenerator: null,
            rendererBuffers: null,
            meshRenderer: null,
            meshFilter: null,
            valid: false,
            skeleton: null,
            reusedPropertyBlock: null
        },
        events: {
            generateMeshOverride: null,
            /**
             * Occurs after the vertex data is populated every frame, before the vertices are pushed into the mesh.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonRenderer
             * @memberof Spine.Unity.SkeletonRenderer
             * @function addOnPostProcessVertices
             * @param   {Spine.Unity.MeshGeneratorDelegate}    value
             * @return  {void}
             */
            /**
             * Occurs after the vertex data is populated every frame, before the vertices are pushed into the mesh.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonRenderer
             * @memberof Spine.Unity.SkeletonRenderer
             * @function removeOnPostProcessVertices
             * @param   {Spine.Unity.MeshGeneratorDelegate}    value
             * @return  {void}
             */
            OnPostProcessVertices: null,
            /**
             * OnRebuild is raised after the Skeleton is successfully initialized.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonRenderer
             * @memberof Spine.Unity.SkeletonRenderer
             * @function addOnRebuild
             * @param   {Spine.Unity.SkeletonRenderer.SkeletonRendererDelegate}    value
             * @return  {void}
             */
            /**
             * OnRebuild is raised after the Skeleton is successfully initialized.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonRenderer
             * @memberof Spine.Unity.SkeletonRenderer
             * @function removeOnRebuild
             * @param   {Spine.Unity.SkeletonRenderer.SkeletonRendererDelegate}    value
             * @return  {void}
             */
            OnRebuild: null,
            /**
             * OnMeshAndMaterialsUpdated is called at the end of LateUpdate after the Mesh and
             all materials have been updated.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonRenderer
             * @memberof Spine.Unity.SkeletonRenderer
             * @function addOnMeshAndMaterialsUpdated
             * @param   {Spine.Unity.SkeletonRenderer.SkeletonRendererDelegate}    value
             * @return  {void}
             */
            /**
             * OnMeshAndMaterialsUpdated is called at the end of LateUpdate after the Mesh and
             all materials have been updated.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonRenderer
             * @memberof Spine.Unity.SkeletonRenderer
             * @function removeOnMeshAndMaterialsUpdated
             * @param   {Spine.Unity.SkeletonRenderer.SkeletonRendererDelegate}    value
             * @return  {void}
             */
            OnMeshAndMaterialsUpdated: null
        },
        props: {
            /**
             * Update mode to optionally limit updates to e.g. only apply animations but not update the mesh.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @function UpdateMode
             * @type Spine.Unity.UpdateMode
             */
            UpdateMode: {
                get: function () {
                    return this.updateMode;
                },
                set: function (value) {
                    this.updateMode = value;
                }
            },
            /**
             * Use this Dictionary to override a Material with a different Material.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Unity.SkeletonRenderer
             * @function CustomMaterialOverride
             * @type System.Collections.Generic.Dictionary$2
             */
            CustomMaterialOverride: {
                get: function () {
                    return this.customMaterialOverride;
                }
            },
            /**
             * Use this Dictionary to use a different Material to render specific Slots.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Unity.SkeletonRenderer
             * @function CustomSlotMaterials
             * @type System.Collections.Generic.Dictionary$2
             */
            CustomSlotMaterials: {
                get: function () {
                    return this.customSlotMaterials;
                }
            },
            Skeleton: {
                get: function () {
                    this.Initialize(false);
                    return this.skeleton;
                }
            },
            SkeletonDataAsset: {
                get: function () {
                    return this.skeletonDataAsset;
                }
            }
        },
        alias: [
            "Skeleton", "Spine$Unity$ISkeletonComponent$Skeleton",
            "SkeletonDataAsset", "Spine$Unity$IHasSkeletonDataAsset$SkeletonDataAsset",
            "SkeletonDataAsset", "Spine$Unity$ISkeletonComponent$SkeletonDataAsset"
        ],
        ctors: {
            init: function () {
                this.updateMode = Spine.Unity.UpdateMode.FullUpdate;
                this.updateWhenInvisible = Spine.Unity.UpdateMode.FullUpdate;
                this.separatorSlotNames = System.Array.init(0, null, System.String);
                this.separatorSlots = new (System.Collections.Generic.List$1(Spine.Slot)).ctor();
                this.useClipping = true;
                this.immutableTriangles = false;
                this.pmaVertexColors = true;
                this.clearStateOnDisable = false;
                this.tintBlack = false;
                this.singleSubmesh = false;
                this.fixDrawOrder = false;
                this.addNormals = false;
                this.calculateTangents = false;
                this.maskInteraction = UnityEngine.SpriteMaskInteraction.None;
                this.maskMaterials = new Spine.Unity.SkeletonRenderer.SpriteMaskInteractionMaterials();
                this.disableRenderingOnOverride = true;
                this.customMaterialOverride = new (System.Collections.Generic.Dictionary$2(UnityEngine.Material,UnityEngine.Material)).ctor();
                this.customSlotMaterials = new (System.Collections.Generic.Dictionary$2(Spine.Slot,UnityEngine.Material)).ctor();
                this.currentInstructions = new Spine.Unity.SkeletonRendererInstruction();
                this.meshGenerator = new Spine.Unity.MeshGenerator();
                this.rendererBuffers = new Spine.Unity.MeshRendererBuffers();
            }
        },
        methods: {
            /**
             * Allows separate code to take over rendering for this SkeletonRenderer component. The subscriber is passed a SkeletonRendererInstruction argument to determine how to render a skeleton.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @event Spine.Unity.SkeletonRenderer#GenerateMeshOverride
             * @return  {Spine.Unity.SkeletonRenderer.InstructionDelegate}
             */
            addGenerateMeshOverride: function (value) {
                this.addgenerateMeshOverride(value);
                if (this.disableRenderingOnOverride && !Bridge.staticEquals(this.generateMeshOverride, null)) {
                    this.Initialize(false);
                    if (UnityEngine.Object.op_Implicit(this.meshRenderer)) {
                        this.meshRenderer.enabled = false;
                    }
                    this.updateMode = Spine.Unity.UpdateMode.FullUpdate;
                }
            },
            /**
             * Allows separate code to take over rendering for this SkeletonRenderer component. The subscriber is passed a SkeletonRendererInstruction argument to determine how to render a skeleton.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @event Spine.Unity.SkeletonRenderer#GenerateMeshOverride
             * @return  {Spine.Unity.SkeletonRenderer.InstructionDelegate}
             */
            removeGenerateMeshOverride: function (value) {
                this.removegenerateMeshOverride(value);
                if (this.disableRenderingOnOverride && Bridge.staticEquals(this.generateMeshOverride, null)) {
                    this.Initialize(false);
                    if (UnityEngine.Object.op_Implicit(this.meshRenderer)) {
                        this.meshRenderer.enabled = true;
                    }
                }
            },
            /*Spine.Unity.SkeletonRenderer.SetMeshSettings start.*/
            /**
             * Applies MeshGenerator settings to the SkeletonRenderer and its internal MeshGenerator.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonRenderer
             * @memberof Spine.Unity.SkeletonRenderer
             * @param   {Spine.Unity.MeshGenerator.Settings}    settings
             * @return  {void}
             */
            SetMeshSettings: function (settings) {
                this.calculateTangents = settings.calculateTangents;
                this.immutableTriangles = settings.immutableTriangles;
                this.pmaVertexColors = settings.pmaVertexColors;
                this.tintBlack = settings.tintBlack;
                this.useClipping = settings.useClipping;
                this.zSpacing = settings.zSpacing;

                this.meshGenerator.settings = settings.$clone();
            },
            /*Spine.Unity.SkeletonRenderer.SetMeshSettings end.*/

            /*Spine.Unity.SkeletonRenderer.Awake start.*/
            Awake: function () {
                this.Initialize(false);
                if (Bridge.staticEquals(this.generateMeshOverride, null) || !this.disableRenderingOnOverride) {
                    this.updateMode = this.updateWhenInvisible;
                }
            },
            /*Spine.Unity.SkeletonRenderer.Awake end.*/

            /*Spine.Unity.SkeletonRenderer.OnDisable start.*/
            OnDisable: function () {
                if (this.clearStateOnDisable && this.valid) {
                    this.ClearState();
                }
            },
            /*Spine.Unity.SkeletonRenderer.OnDisable end.*/

            /*Spine.Unity.SkeletonRenderer.OnDestroy start.*/
            OnDestroy: function () {
                this.rendererBuffers.Dispose();
                this.valid = false;
            },
            /*Spine.Unity.SkeletonRenderer.OnDestroy end.*/

            /*Spine.Unity.SkeletonRenderer.ClearState start.*/
            /**
             * Clears the previously generated mesh and resets the skeleton's pose.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonRenderer
             * @memberof Spine.Unity.SkeletonRenderer
             * @return  {void}
             */
            ClearState: function () {
                var meshFilter = this.GetComponent(UnityEngine.MeshFilter);
                if (UnityEngine.Component.op_Inequality(meshFilter, null)) {
                    meshFilter.sharedMesh = null;
                }
                this.currentInstructions.Clear();
                if (this.skeleton != null) {
                    this.skeleton.setToSetupPose();
                }
            },
            /*Spine.Unity.SkeletonRenderer.ClearState end.*/

            /*Spine.Unity.SkeletonRenderer.EnsureMeshGeneratorCapacity start.*/
            /**
             * Sets a minimum buffer size for the internal MeshGenerator to prevent excess allocations during animation.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonRenderer
             * @memberof Spine.Unity.SkeletonRenderer
             * @param   {number}    minimumVertexCount
             * @return  {void}
             */
            EnsureMeshGeneratorCapacity: function (minimumVertexCount) {
                this.meshGenerator.EnsureVertexCapacity(minimumVertexCount);
            },
            /*Spine.Unity.SkeletonRenderer.EnsureMeshGeneratorCapacity end.*/

            /*Spine.Unity.SkeletonRenderer.Initialize start.*/
            /**
             * Initialize this component. Attempts to load the SkeletonData and creates the internal Skeleton object and buffers.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonRenderer
             * @memberof Spine.Unity.SkeletonRenderer
             * @param   {boolean}    overwrite    If set to <pre><code>true</code></pre>, it will overwrite internal objects if they were already generated. Otherwise, the initialized component will ignore subsequent calls to initialize.
             * @param   {boolean}    quiet
             * @return  {void}
             */
            Initialize: function (overwrite, quiet) {
                var $t;
                if (quiet === void 0) { quiet = false; }
                if (this.valid && !overwrite) {
                    return;
                }
                // Clear
                {
                    // Note: do not reset meshFilter.sharedMesh or meshRenderer.sharedMaterial to null,
                    // otherwise constant reloading will be triggered at prefabs.
                    this.currentInstructions.Clear();
                    this.rendererBuffers.Clear();
                    this.meshGenerator.Begin();
                    this.skeleton = null;
                    this.valid = false;
                }

                if (this.skeletonDataAsset == null) {
                    return;
                }

                var skeletonData = this.skeletonDataAsset.GetSkeletonData(false);
                if (skeletonData == null) {
                    return;
                }
                this.valid = true;

                this.meshFilter = this.GetComponent(UnityEngine.MeshFilter);
                if (UnityEngine.Component.op_Equality(this.meshFilter, null)) {
                    this.meshFilter = this.gameObject.AddComponent(UnityEngine.MeshFilter);
                }

                this.meshRenderer = this.GetComponent(UnityEngine.MeshRenderer);
                this.rendererBuffers.Initialize();

                this.skeleton = ($t = new Spine.Skeleton.$ctor1(skeletonData), $t.scaleX = this.initialFlipX ? -1 : 1, $t.scaleY = this.initialFlipY ? -1 : 1, $t);

                if (!System.String.isNullOrEmpty(this.initialSkinName) && !System.String.equals(this.initialSkinName, "default", 4)) {
                    this.skeleton.setSkinByName(this.initialSkinName);
                }

                this.separatorSlots.clear();
                for (var i = 0; i < this.separatorSlotNames.length; i = (i + 1) | 0) {
                    this.separatorSlots.add(this.skeleton.findSlot(this.separatorSlotNames[i]));
                }

                // Generate mesh once, required to update mesh bounds for visibility
                var updateModeSaved = this.updateMode;
                this.updateMode = Spine.Unity.UpdateMode.FullUpdate;
                this.skeleton.updateWorldTransform();
                this.LateUpdate();
                this.updateMode = updateModeSaved;

                if (!Bridge.staticEquals(this.OnRebuild, null)) {
                    this.OnRebuild(this);
                }

            },
            /*Spine.Unity.SkeletonRenderer.Initialize end.*/

            /*Spine.Unity.SkeletonRenderer.LateUpdate start.*/
            /**
             * Generates a new UnityEngine.Mesh from the internal Skeleton.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonRenderer
             * @memberof Spine.Unity.SkeletonRenderer
             * @return  {void}
             */
            LateUpdate: function () {
                if (!this.valid) {
                    return;
                }


                if (this.updateMode !== Spine.Unity.UpdateMode.FullUpdate) {
                    return;
                }

                this.LateUpdateMesh();
            },
            /*Spine.Unity.SkeletonRenderer.LateUpdate end.*/

            /*Spine.Unity.SkeletonRenderer.LateUpdateMesh start.*/
            LateUpdateMesh: function () {
                var $t, $t1;
                var doMeshOverride = !Bridge.staticEquals(this.generateMeshOverride, null);
                if ((!UnityEngine.Object.op_Implicit(this.meshRenderer) || !this.meshRenderer.enabled) && !doMeshOverride) {
                    return;
                }
                var currentInstructions = this.currentInstructions;
                var workingSubmeshInstructions = currentInstructions.submeshInstructions;
                var currentSmartMesh = this.rendererBuffers.GetNextMesh(); // Double-buffer for performance.

                var updateTriangles;

                if (this.singleSubmesh) {
                    // STEP 1. Determine a SmartMesh.Instruction. Split up instructions into submeshes. =============================================
                    Spine.Unity.MeshGenerator.GenerateSingleSubmeshInstruction(currentInstructions, this.skeleton, ($t = this.skeletonDataAsset.atlasAssets)[0].PrimaryMaterial);

                    // STEP 1.9. Post-process workingInstructions. ==================================================================================
                    if (this.customMaterialOverride.Count > 0) {
                        Spine.Unity.MeshGenerator.TryReplaceMaterials(workingSubmeshInstructions, this.customMaterialOverride);
                    }

                    // STEP 2. Update vertex buffer based on verts from the attachments. ===========================================================
                    this.meshGenerator.settings = ($t1 = new Spine.Unity.MeshGenerator.Settings(), $t1.pmaVertexColors = this.pmaVertexColors, $t1.zSpacing = this.zSpacing, $t1.useClipping = this.useClipping, $t1.tintBlack = this.tintBlack, $t1.calculateTangents = this.calculateTangents, $t1.addNormals = this.addNormals, $t1);
                    this.meshGenerator.Begin();
                    updateTriangles = Spine.Unity.SkeletonRendererInstruction.GeometryNotEqual(currentInstructions, currentSmartMesh.instructionUsed);
                    if (currentInstructions.hasActiveClipping) {
                        this.meshGenerator.AddSubmesh(workingSubmeshInstructions.Items[0].$clone(), updateTriangles);
                    } else {
                        this.meshGenerator.BuildMeshWithArrays(currentInstructions, updateTriangles);
                    }

                } else {
                    // STEP 1. Determine a SmartMesh.Instruction. Split up instructions into submeshes. =============================================
                    Spine.Unity.MeshGenerator.GenerateSkeletonRendererInstruction(currentInstructions, this.skeleton, this.customSlotMaterials, this.separatorSlots, doMeshOverride, this.immutableTriangles);

                    // STEP 1.9. Post-process workingInstructions. ==================================================================================
                    if (this.customMaterialOverride.Count > 0) {
                        Spine.Unity.MeshGenerator.TryReplaceMaterials(workingSubmeshInstructions, this.customMaterialOverride);
                    }

                    if (doMeshOverride) {
                        this.generateMeshOverride(currentInstructions);
                        if (this.disableRenderingOnOverride) {
                            return;
                        }
                    }

                    updateTriangles = Spine.Unity.SkeletonRendererInstruction.GeometryNotEqual(currentInstructions, currentSmartMesh.instructionUsed);

                    // STEP 2. Update vertex buffer based on verts from the attachments. ===========================================================
                    this.meshGenerator.settings = ($t1 = new Spine.Unity.MeshGenerator.Settings(), $t1.pmaVertexColors = this.pmaVertexColors, $t1.zSpacing = this.zSpacing, $t1.useClipping = this.useClipping, $t1.tintBlack = this.tintBlack, $t1.calculateTangents = this.calculateTangents, $t1.addNormals = this.addNormals, $t1);
                    this.meshGenerator.Begin();
                    if (currentInstructions.hasActiveClipping) {
                        this.meshGenerator.BuildMesh(currentInstructions, updateTriangles);
                    } else {
                        this.meshGenerator.BuildMeshWithArrays(currentInstructions, updateTriangles);
                    }
                }

                if (!Bridge.staticEquals(this.OnPostProcessVertices, null)) {
                    this.OnPostProcessVertices(this.meshGenerator.Buffers.$clone());
                }

                // STEP 3. Move the mesh data into a UnityEngine.Mesh ===========================================================================
                var currentMesh = currentSmartMesh.mesh;
                this.meshGenerator.FillVertexData(currentMesh);

                this.rendererBuffers.UpdateSharedMaterials(workingSubmeshInstructions);

                var materialsChanged = this.rendererBuffers.MaterialsChangedInLastUpdate();
                if (updateTriangles) { // Check if the triangles should also be updated.
                    this.meshGenerator.FillTriangles(currentMesh);
                    this.meshRenderer.sharedMaterials = this.rendererBuffers.GetUpdatedSharedMaterialsArray();
                } else if (materialsChanged) {
                    this.meshRenderer.sharedMaterials = this.rendererBuffers.GetUpdatedSharedMaterialsArray();
                }
                if (materialsChanged && (this.maskMaterials.AnyMaterialCreated)) {
                    this.maskMaterials = new Spine.Unity.SkeletonRenderer.SpriteMaskInteractionMaterials();
                }

                this.meshGenerator.FillLateVertexData(currentMesh);

                // STEP 4. The UnityEngine.Mesh is ready. Set it as the MeshFilter's mesh. Store the instructions used for that mesh. ===========
                if (UnityEngine.Object.op_Implicit(this.meshFilter)) {
                    this.meshFilter.sharedMesh = currentMesh;
                }
                currentSmartMesh.instructionUsed.Set(currentInstructions);

                if (UnityEngine.Component.op_Inequality(this.meshRenderer, null)) {
                    this.AssignSpriteMaskMaterials();
                }
                if (UnityEngine.Application.isPlaying) {
                    this.HandleOnDemandLoading();
                }

                if (this.fixDrawOrder && this.meshRenderer.sharedMaterials.length > 2) {
                    this.SetMaterialSettingsToFixDrawOrder();
                }

                if (!Bridge.staticEquals(this.OnMeshAndMaterialsUpdated, null)) {
                    this.OnMeshAndMaterialsUpdated(this);
                }
            },
            /*Spine.Unity.SkeletonRenderer.LateUpdateMesh end.*/

            /*Spine.Unity.SkeletonRenderer.OnBecameVisible start.*/
            OnBecameVisible: function () {
                var previousUpdateMode = this.updateMode;
                this.updateMode = Spine.Unity.UpdateMode.FullUpdate;

                // OnBecameVisible is called after LateUpdate()
                if (previousUpdateMode !== Spine.Unity.UpdateMode.FullUpdate) {
                    this.LateUpdate();
                }
            },
            /*Spine.Unity.SkeletonRenderer.OnBecameVisible end.*/

            /*Spine.Unity.SkeletonRenderer.OnBecameInvisible start.*/
            OnBecameInvisible: function () {
                this.updateMode = this.updateWhenInvisible;
            },
            /*Spine.Unity.SkeletonRenderer.OnBecameInvisible end.*/

            /*Spine.Unity.SkeletonRenderer.FindAndApplySeparatorSlots$1 start.*/
            FindAndApplySeparatorSlots$1: function (startsWith, clearExistingSeparators, updateStringArray) {
                if (clearExistingSeparators === void 0) { clearExistingSeparators = true; }
                if (updateStringArray === void 0) { updateStringArray = false; }
                if (System.String.isNullOrEmpty(startsWith)) {
                    return;
                }

                this.FindAndApplySeparatorSlots(function (slotName) {
                    return System.String.startsWith(slotName, startsWith);
                }, clearExistingSeparators, updateStringArray);
            },
            /*Spine.Unity.SkeletonRenderer.FindAndApplySeparatorSlots$1 end.*/

            /*Spine.Unity.SkeletonRenderer.FindAndApplySeparatorSlots start.*/
            FindAndApplySeparatorSlots: function (slotNamePredicate, clearExistingSeparators, updateStringArray) {
                var $t, $t1, $t2;
                if (clearExistingSeparators === void 0) { clearExistingSeparators = true; }
                if (updateStringArray === void 0) { updateStringArray = false; }
                if (Bridge.staticEquals(slotNamePredicate, null)) {
                    return;
                }
                if (!this.valid) {
                    return;
                }

                if (clearExistingSeparators) {
                    this.separatorSlots.clear();
                }

                var slots = this.skeleton.Slots;
                $t = Bridge.getEnumerator(slots);
                try {
                    while ($t.moveNext()) {
                        var slot = $t.Current;
                        if (slotNamePredicate(slot.data.name)) {
                            this.separatorSlots.add(slot);
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }

                if (updateStringArray) {
                    var detectedSeparatorNames = new (System.Collections.Generic.List$1(System.String)).ctor();
                    $t1 = Bridge.getEnumerator(this.skeleton.Slots);
                    try {
                        while ($t1.moveNext()) {
                            var slot1 = $t1.Current;
                            var slotName = slot1.data.name;
                            if (slotNamePredicate(slotName)) {
                                detectedSeparatorNames.add(slotName);
                            }
                        }
                    } finally {
                        if (Bridge.is($t1, System.IDisposable)) {
                            $t1.System$IDisposable$Dispose();
                        }
                    }
                    if (!clearExistingSeparators) {
                        var originalNames = this.separatorSlotNames;
                        $t2 = Bridge.getEnumerator(originalNames);
                        try {
                            while ($t2.moveNext()) {
                                var originalName = $t2.Current;
                                detectedSeparatorNames.add(originalName);
                            }
                        } finally {
                            if (Bridge.is($t2, System.IDisposable)) {
                                $t2.System$IDisposable$Dispose();
                            }
                        }
                    }

                    this.separatorSlotNames = detectedSeparatorNames.ToArray();
                }

            },
            /*Spine.Unity.SkeletonRenderer.FindAndApplySeparatorSlots end.*/

            /*Spine.Unity.SkeletonRenderer.ReapplySeparatorSlotNames start.*/
            ReapplySeparatorSlotNames: function () {
                if (!this.valid) {
                    return;
                }

                this.separatorSlots.clear();
                for (var i = 0, n = this.separatorSlotNames.length; i < n; i = (i + 1) | 0) {
                    var slot = this.skeleton.findSlot(this.separatorSlotNames[i]);
                    if (slot != null) {
                        this.separatorSlots.add(slot);
                    }
                }
            },
            /*Spine.Unity.SkeletonRenderer.ReapplySeparatorSlotNames end.*/

            /*Spine.Unity.SkeletonRenderer.AssignSpriteMaskMaterials start.*/
            AssignSpriteMaskMaterials: function () {
                var $t, $t1, $t2;

                if (UnityEngine.Application.isPlaying) {
                    if (this.maskInteraction !== UnityEngine.SpriteMaskInteraction.None && this.maskMaterials.materialsMaskDisabled.length === 0) {
                        this.maskMaterials.materialsMaskDisabled = this.meshRenderer.sharedMaterials;
                    }
                }

                if (this.maskMaterials.materialsMaskDisabled.length > 0 && ($t = this.maskMaterials.materialsMaskDisabled)[0] != null && this.maskInteraction === UnityEngine.SpriteMaskInteraction.None) {
                    this.meshRenderer.materials = this.maskMaterials.materialsMaskDisabled;
                } else if (this.maskInteraction === UnityEngine.SpriteMaskInteraction.VisibleInsideMask) {
                    if (this.maskMaterials.materialsInsideMask.length === 0 || ($t1 = this.maskMaterials.materialsInsideMask)[0] == null) {
                        if (!this.InitSpriteMaskMaterialsInsideMask()) {
                            return;
                        }
                    }
                    this.meshRenderer.materials = this.maskMaterials.materialsInsideMask;
                } else if (this.maskInteraction === UnityEngine.SpriteMaskInteraction.VisibleOutsideMask) {
                    if (this.maskMaterials.materialsOutsideMask.length === 0 || ($t2 = this.maskMaterials.materialsOutsideMask)[0] == null) {
                        if (!this.InitSpriteMaskMaterialsOutsideMask()) {
                            return;
                        }
                    }
                    this.meshRenderer.materials = this.maskMaterials.materialsOutsideMask;
                }
            },
            /*Spine.Unity.SkeletonRenderer.AssignSpriteMaskMaterials end.*/

            /*Spine.Unity.SkeletonRenderer.InitSpriteMaskMaterialsInsideMask start.*/
            InitSpriteMaskMaterialsInsideMask: function () {
                return this.InitSpriteMaskMaterialsForMaskType(Spine.Unity.SkeletonRenderer.STENCIL_COMP_MASKINTERACTION_VISIBLE_INSIDE, Bridge.ref(this.maskMaterials, "materialsInsideMask"));
            },
            /*Spine.Unity.SkeletonRenderer.InitSpriteMaskMaterialsInsideMask end.*/

            /*Spine.Unity.SkeletonRenderer.InitSpriteMaskMaterialsOutsideMask start.*/
            InitSpriteMaskMaterialsOutsideMask: function () {
                return this.InitSpriteMaskMaterialsForMaskType(Spine.Unity.SkeletonRenderer.STENCIL_COMP_MASKINTERACTION_VISIBLE_OUTSIDE, Bridge.ref(this.maskMaterials, "materialsOutsideMask"));
            },
            /*Spine.Unity.SkeletonRenderer.InitSpriteMaskMaterialsOutsideMask end.*/

            /*Spine.Unity.SkeletonRenderer.InitSpriteMaskMaterialsForMaskType start.*/
            InitSpriteMaskMaterialsForMaskType: function (maskFunction, materialsToFill) {
                var originalMaterials = this.maskMaterials.materialsMaskDisabled;
                materialsToFill.v = System.Array.init(originalMaterials.length, null, UnityEngine.Material);
                for (var i = 0; i < originalMaterials.length; i = (i + 1) | 0) {
                    var originalMaterial = originalMaterials[i];
                    if (originalMaterial == null) {
                        materialsToFill.v[i] = null;
                        continue;
                    }
                    var newMaterial = new UnityEngine.Material.$ctor1(originalMaterial);
                    newMaterial.SetFloat(Spine.Unity.SkeletonRenderer.STENCIL_COMP_PARAM_ID, maskFunction);
                    materialsToFill.v[i] = newMaterial;
                }
                return true;
            },
            /*Spine.Unity.SkeletonRenderer.InitSpriteMaskMaterialsForMaskType end.*/

            /*Spine.Unity.SkeletonRenderer.HandleOnDemandLoading start.*/
            HandleOnDemandLoading: function () {
                var $t, $t1, $t2;
                $t = Bridge.getEnumerator(this.skeletonDataAsset.atlasAssets);
                try {
                    while ($t.moveNext()) {
                        var atlasAsset = $t.Current;
                        if (atlasAsset.TextureLoadingMode !== Spine.Unity.AtlasAssetBase.LoadingMode.Normal) {
                            atlasAsset.BeginCustomTextureLoading();
                            for (var i = 0, count = this.meshRenderer.sharedMaterials.length; i < count; i = (i + 1) | 0) {
                                var overrideMaterial = { v : null };
                                atlasAsset.RequireTexturesLoaded(($t1 = this.meshRenderer.sharedMaterials)[i], overrideMaterial);
                                if (overrideMaterial.v != null) {
                                    ($t2 = this.meshRenderer.sharedMaterials)[i] = overrideMaterial.v;
                                }
                            }
                            atlasAsset.EndCustomTextureLoading();
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.Unity.SkeletonRenderer.HandleOnDemandLoading end.*/

            /*Spine.Unity.SkeletonRenderer.SetMaterialSettingsToFixDrawOrder start.*/
            /**
             * This method was introduced as a workaround for too aggressive submesh draw call batching,
             leading to incorrect draw order when 3+ materials are used at submeshes in alternating order.
             Otherwise, e.g. when using Lightweight Render Pipeline, deliberately separated draw calls
             "A1 B A2" are reordered to "A1A2 B", regardless of batching-related project settings.
             *
             * @instance
             * @private
             * @this Spine.Unity.SkeletonRenderer
             * @memberof Spine.Unity.SkeletonRenderer
             * @return  {void}
             */
            SetMaterialSettingsToFixDrawOrder: function () {
                var $t, $t1;
                if (this.reusedPropertyBlock == null) {
                    this.reusedPropertyBlock = new UnityEngine.MaterialPropertyBlock();
                }

                var hasPerRendererBlock = this.meshRenderer.HasPropertyBlock();
                if (hasPerRendererBlock) {
                    this.meshRenderer.GetPropertyBlock(this.reusedPropertyBlock);
                }

                for (var i = 0; i < this.meshRenderer.sharedMaterials.length; i = (i + 1) | 0) {
                    if (!UnityEngine.Object.op_Implicit(($t = this.meshRenderer.sharedMaterials)[i])) {
                        continue;
                    }

                    if (!hasPerRendererBlock) {
                        this.meshRenderer.GetPropertyBlock$1(this.reusedPropertyBlock, i);
                    }
                    // Note: this parameter shall not exist at any shader, then Unity will create separate
                    // material instances (not in terms of memory cost or leakage).
                    this.reusedPropertyBlock.SetFloat(Spine.Unity.SkeletonRenderer.SUBMESH_DUMMY_PARAM_ID, i);
                    this.meshRenderer.SetPropertyBlock$1(this.reusedPropertyBlock, i);

                    ($t1 = this.meshRenderer.sharedMaterials)[i].enableInstancing = false;
                }
            },
            /*Spine.Unity.SkeletonRenderer.SetMaterialSettingsToFixDrawOrder end.*/


        },
        overloads: {
            "FindAndApplySeparatorSlots(string, bool, bool)": "FindAndApplySeparatorSlots$1"
        }
    });
    /*Spine.Unity.SkeletonRenderer end.*/
    /**
     * @memberof Spine.Unity
     * @callback Spine.Unity.SkeletonGraphic.MeshAssignmentDelegateMultiple
     * @param   {number}                          meshCount           
     * @param   {Array.<UnityEngine.Mesh>}        meshes              
     * @param   {Array.<UnityEngine.Material>}    graphicMaterials    
     * @param   {Array.<UnityEngine.Texture>}     textures
     * @return  {void}
     */

    /**
     * @memberof Spine.Unity
     * @callback Spine.Unity.SkeletonGraphic.MeshAssignmentDelegateSingle
     * @param   {UnityEngine.Mesh}        mesh               
     * @param   {UnityEngine.Material}    graphicMaterial    
     * @param   {UnityEngine.Texture}     texture
     * @return  {void}
     */

    /**
     * @memberof Spine.Unity
     * @callback Spine.Unity.ISkeletonAnimationDelegate
     * @param   {Spine.Unity.ISkeletonAnimation}    animated
     * @return  {void}
     */

    /**
     * @memberof Spine.Unity
     * @callback Spine.Unity.SkeletonGraphic.InstructionDelegate
     * @param   {Spine.Unity.SkeletonRendererInstruction}    instruction
     * @return  {void}
     */

    /**
     * @memberof Spine.Unity
     * @callback Spine.Unity.SkeletonGraphic.SkeletonRendererDelegate
     * @param   {Spine.Unity.SkeletonGraphic}    skeletonGraphic
     * @return  {void}
     */


    /*Spine.Unity.SkeletonGraphic start.*/
    Bridge.define("Spine.Unity.SkeletonGraphic", {
        inherits: [UnityEngine.UI.MaskableGraphic,Spine.Unity.ISkeletonComponent,Spine.Unity.IAnimationStateComponent,Spine.Unity.ISkeletonAnimation,Spine.Unity.IHasSkeletonDataAsset],
        statics: {
            fields: {
                EditReferenceRect: false,
                SeparatorPartGameObjectName: null
            },
            ctors: {
                init: function () {
                    this.EditReferenceRect = false;
                    this.SeparatorPartGameObjectName = "Part";
                }
            },
            methods: {
                /*Spine.Unity.SkeletonGraphic.NewSkeletonGraphicGameObject:static start.*/
                /**
                 * Create a new GameObject with a SkeletonGraphic component.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonGraphic
                 * @memberof Spine.Unity.SkeletonGraphic
                 * @param   {Spine.Unity.SkeletonDataAsset}    skeletonDataAsset    
                 * @param   {UnityEngine.Transform}            parent               
                 * @param   {UnityEngine.Material}             material             Material for the canvas renderer to use. Usually, the default SkeletonGraphic material will work.
                 * @return  {Spine.Unity.SkeletonGraphic}
                 */
                NewSkeletonGraphicGameObject: function (skeletonDataAsset, parent, material) {
                    var sg = Spine.Unity.SkeletonGraphic.AddSkeletonGraphicComponent(new UnityEngine.GameObject.$ctor2("New Spine GameObject"), skeletonDataAsset, material);
                    if (UnityEngine.Component.op_Inequality(parent, null)) {
                        sg.transform.SetParent(parent, false);
                    }
                    return sg;
                },
                /*Spine.Unity.SkeletonGraphic.NewSkeletonGraphicGameObject:static end.*/

                /*Spine.Unity.SkeletonGraphic.AddSkeletonGraphicComponent:static start.*/
                /**
                 * Add a SkeletonGraphic component to a GameObject.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonGraphic
                 * @memberof Spine.Unity.SkeletonGraphic
                 * @param   {UnityEngine.GameObject}           gameObject           
                 * @param   {Spine.Unity.SkeletonDataAsset}    skeletonDataAsset    
                 * @param   {UnityEngine.Material}             material             Material for the canvas renderer to use. Usually, the default SkeletonGraphic material will work.
                 * @return  {Spine.Unity.SkeletonGraphic}
                 */
                AddSkeletonGraphicComponent: function (gameObject, skeletonDataAsset, material) {
                    var skeletonGraphic = gameObject.AddComponent(Spine.Unity.SkeletonGraphic);
                    if (skeletonDataAsset != null) {
                        skeletonGraphic.material = material;
                        skeletonGraphic.skeletonDataAsset = skeletonDataAsset;
                        skeletonGraphic.Initialize(false);
                    }
                    var canvasRenderer = gameObject.GetComponent(UnityEngine.CanvasRenderer);
                    if (UnityEngine.Object.op_Implicit(canvasRenderer)) {
                        canvasRenderer.cullTransparentMesh = false;
                    }
                    return skeletonGraphic;
                },
                /*Spine.Unity.SkeletonGraphic.AddSkeletonGraphicComponent:static end.*/

                /*Spine.Unity.SkeletonGraphic.SetRectTransformSize$1:static start.*/
                SetRectTransformSize$1: function (target, size) {
                    Spine.Unity.SkeletonGraphic.SetRectTransformSize(target.rectTransform, size.$clone());
                },
                /*Spine.Unity.SkeletonGraphic.SetRectTransformSize$1:static end.*/

                /*Spine.Unity.SkeletonGraphic.SetRectTransformSize:static start.*/
                SetRectTransformSize: function (targetRectTransform, size) {
                    var $t;
                    var parentSize = pc.Vec2.ZERO.clone();
                    if (UnityEngine.Component.op_Inequality(targetRectTransform.parent, null)) {
                        var parentTransform = targetRectTransform.parent.GetComponent(UnityEngine.RectTransform);
                        if (UnityEngine.Object.op_Implicit(parentTransform)) {
                            parentSize = parentTransform.rect.size.$clone();
                        }
                    }
                    var anchorAreaSize = ($t = targetRectTransform.anchorMax.$clone().sub( targetRectTransform.anchorMin ), new pc.Vec2( $t.x * parentSize.x, $t.y * parentSize.y ));
                    targetRectTransform.sizeDelta = size.$clone().sub( anchorAreaSize );
                },
                /*Spine.Unity.SkeletonGraphic.SetRectTransformSize:static end.*/


            }
        },
        fields: {
            skeletonDataAsset: null,
            additiveMaterial: null,
            multiplyMaterial: null,
            screenMaterial: null,
            initialSkinName: null,
            initialFlipX: false,
            initialFlipY: false,
            startingAnimation: null,
            startingLoop: false,
            timeScale: 0,
            freeze: false,
            meshScale: 0,
            layoutScaleMode: 0,
            referenceSize: null,
            referenceScale: 0,
            updateMode: 0,
            /**
             * Update mode used when the MeshRenderer becomes invisible
             (when <pre><code>OnBecameInvisible()</code></pre> is called). Update mode is automatically
             reset to <pre><code>UpdateMode.FullUpdate</code></pre> when the mesh becomes visible again.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonGraphic
             * @type Spine.Unity.UpdateMode
             */
            updateWhenInvisible: 0,
            allowMultipleCanvasRenderers: false,
            canvasRenderers: null,
            submeshGraphics: null,
            usedRenderersCount: 0,
            /**
             * Slot names used to populate separatorSlots list when the Skeleton is initialized. Changing this after initialization does nothing.
             *
             * @instance
             * @protected
             * @memberof Spine.Unity.SkeletonGraphic
             * @type Array.<string>
             */
            separatorSlotNames: null,
            /**
             * Slots that determine where the render is split. This is used by components such as SkeletonRenderSeparator so that the skeleton can be rendered by two separate renderers on different GameObjects.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Unity.SkeletonGraphic
             * @type System.Collections.Generic.List$1
             */
            separatorSlots: null,
            enableSeparatorSlots: false,
            separatorParts: null,
            updateSeparatorPartLocation: false,
            updateSeparatorPartScale: false,
            wasUpdatedAfterInit: false,
            baseTexture: null,
            /**
             * When true, no meshes and materials are assigned at CanvasRenderers if the used override
             AssignMeshOverrideSingleRenderer or AssignMeshOverrideMultipleRenderers is non-null.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonGraphic
             * @default true
             * @type boolean
             */
            disableMeshAssignmentOnOverride: false,
            customTextureOverride: null,
            customMaterialOverride: null,
            overrideTexture: null,
            skeleton: null,
            state: null,
            meshGenerator: null,
            meshBuffers: null,
            currentInstructions: null,
            meshes: null,
            usedMaterials: null,
            usedTextures: null,
            updateTiming: 0,
            unscaledTime: false
        },
        events: {
            assignMeshOverrideSingle: null,
            assignMeshOverrideMultiple: null,
            /**
             * OnRebuild is raised after the Skeleton is successfully initialized.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonGraphic
             * @memberof Spine.Unity.SkeletonGraphic
             * @function addOnRebuild
             * @param   {Spine.Unity.SkeletonGraphic.SkeletonRendererDelegate}    value
             * @return  {void}
             */
            /**
             * OnRebuild is raised after the Skeleton is successfully initialized.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonGraphic
             * @memberof Spine.Unity.SkeletonGraphic
             * @function removeOnRebuild
             * @param   {Spine.Unity.SkeletonGraphic.SkeletonRendererDelegate}    value
             * @return  {void}
             */
            OnRebuild: null,
            /**
             * OnInstructionsPrepared is raised at the end of <pre><code>LateUpdate</code></pre> after render instructions
             are done, target renderers are prepared, and the mesh is ready to be generated.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonGraphic
             * @memberof Spine.Unity.SkeletonGraphic
             * @function addOnInstructionsPrepared
             * @param   {Spine.Unity.SkeletonGraphic.InstructionDelegate}    value
             * @return  {void}
             */
            /**
             * OnInstructionsPrepared is raised at the end of <pre><code>LateUpdate</code></pre> after render instructions
             are done, target renderers are prepared, and the mesh is ready to be generated.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonGraphic
             * @memberof Spine.Unity.SkeletonGraphic
             * @function removeOnInstructionsPrepared
             * @param   {Spine.Unity.SkeletonGraphic.InstructionDelegate}    value
             * @return  {void}
             */
            OnInstructionsPrepared: null,
            /**
             * OnMeshAndMaterialsUpdated is raised at the end of <pre><code>Rebuild</code></pre> after the Mesh and
             all materials have been updated. Note that some Unity API calls are not permitted to be issued from
             <pre><code>Rebuild</code></pre>, so you may want to subscribe to {@link } instead
             from where you can issue such preparation calls.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonGraphic
             * @memberof Spine.Unity.SkeletonGraphic
             * @function addOnMeshAndMaterialsUpdated
             * @param   {Spine.Unity.SkeletonGraphic.SkeletonRendererDelegate}    value
             * @return  {void}
             */
            /**
             * OnMeshAndMaterialsUpdated is raised at the end of <pre><code>Rebuild</code></pre> after the Mesh and
             all materials have been updated. Note that some Unity API calls are not permitted to be issued from
             <pre><code>Rebuild</code></pre>, so you may want to subscribe to {@link } instead
             from where you can issue such preparation calls.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonGraphic
             * @memberof Spine.Unity.SkeletonGraphic
             * @function removeOnMeshAndMaterialsUpdated
             * @param   {Spine.Unity.SkeletonGraphic.SkeletonRendererDelegate}    value
             * @return  {void}
             */
            OnMeshAndMaterialsUpdated: null,
            /**
             * OnAnimationRebuild is raised after the SkeletonAnimation component is successfully initialized.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonGraphic
             * @memberof Spine.Unity.SkeletonGraphic
             * @function addOnAnimationRebuild
             * @param   {Spine.Unity.ISkeletonAnimationDelegate}    value
             * @return  {void}
             */
            /**
             * OnAnimationRebuild is raised after the SkeletonAnimation component is successfully initialized.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonGraphic
             * @memberof Spine.Unity.SkeletonGraphic
             * @function removeOnAnimationRebuild
             * @param   {Spine.Unity.ISkeletonAnimationDelegate}    value
             * @return  {void}
             */
            OnAnimationRebuild: null,
            BeforeApply: null,
            UpdateLocal: null,
            UpdateWorld: null,
            UpdateComplete: null,
            /**
             * Occurs after the vertex data populated every frame, before the vertices are pushed into the mesh.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonGraphic
             * @memberof Spine.Unity.SkeletonGraphic
             * @function addOnPostProcessVertices
             * @param   {Spine.Unity.MeshGeneratorDelegate}    value
             * @return  {void}
             */
            /**
             * Occurs after the vertex data populated every frame, before the vertices are pushed into the mesh.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonGraphic
             * @memberof Spine.Unity.SkeletonGraphic
             * @function removeOnPostProcessVertices
             * @param   {Spine.Unity.MeshGeneratorDelegate}    value
             * @return  {void}
             */
            OnPostProcessVertices: null
        },
        props: {
            SkeletonDataAsset: {
                get: function () {
                    return this.skeletonDataAsset;
                }
            },
            MeshScale: {
                get: function () {
                    return this.meshScale;
                }
            },
            /**
             * Update mode to optionally limit updates to e.g. only apply animations but not update the mesh.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonGraphic
             * @function UpdateMode
             * @type Spine.Unity.UpdateMode
             */
            UpdateMode: {
                get: function () {
                    return this.updateMode;
                },
                set: function (value) {
                    this.updateMode = value;
                }
            },
            SeparatorParts: {
                get: function () {
                    return this.separatorParts;
                }
            },
            /**
             * Use this Dictionary to override a Texture with a different Texture.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Unity.SkeletonGraphic
             * @function CustomTextureOverride
             * @type System.Collections.Generic.Dictionary$2
             */
            CustomTextureOverride: {
                get: function () {
                    return this.customTextureOverride;
                }
            },
            /**
             * Use this Dictionary to override the Material where the Texture was used at the original atlas.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Unity.SkeletonGraphic
             * @function CustomMaterialOverride
             * @type System.Collections.Generic.Dictionary$2
             */
            CustomMaterialOverride: {
                get: function () {
                    return this.customMaterialOverride;
                }
            },
            OverrideTexture: {
                get: function () {
                    return this.overrideTexture;
                },
                set: function (value) {
                    this.overrideTexture = value;
                    this.canvasRenderer.SetTexture(this.mainTexture); // Refresh canvasRenderer's texture. Make sure it handles null.
                }
            },
            mainTexture: {
                get: function () {
                    if (this.overrideTexture != null) {
                        return this.overrideTexture;
                    }
                    return this.baseTexture;
                }
            },
            Skeleton: {
                get: function () {
                    this.Initialize(false);
                    return this.skeleton;
                },
                set: function (value) {
                    this.skeleton = value;
                }
            },
            SkeletonData: {
                get: function () {
                    this.Initialize(false);
                    return this.skeleton == null ? null : this.skeleton.data;
                }
            },
            IsValid: {
                get: function () {
                    return this.skeleton != null;
                }
            },
            AnimationState: {
                get: function () {
                    this.Initialize(false);
                    return this.state;
                }
            },
            MeshGenerator: {
                get: function () {
                    return this.meshGenerator;
                }
            },
            MeshesMultipleCanvasRenderers: {
                get: function () {
                    return this.meshes;
                }
            },
            MaterialsMultipleCanvasRenderers: {
                get: function () {
                    return this.usedMaterials;
                }
            },
            TexturesMultipleCanvasRenderers: {
                get: function () {
                    return this.usedTextures;
                }
            },
            UpdateTiming: {
                get: function () {
                    return this.updateTiming;
                },
                set: function (value) {
                    this.updateTiming = value;
                }
            },
            UnscaledTime: {
                get: function () {
                    return this.unscaledTime;
                },
                set: function (value) {
                    this.unscaledTime = value;
                }
            }
        },
        alias: [
            "SkeletonDataAsset", "Spine$Unity$IHasSkeletonDataAsset$SkeletonDataAsset",
            "SkeletonDataAsset", "Spine$Unity$ISkeletonComponent$SkeletonDataAsset",
            "Rebuild", "UnityEngine$UI$ICanvasElement$Rebuild",
            "Skeleton", "Spine$Unity$ISkeletonAnimation$Skeleton",
            "Skeleton", "Spine$Unity$ISkeletonComponent$Skeleton",
            "AnimationState", "Spine$Unity$IAnimationStateComponent$AnimationState",
            "addOnAnimationRebuild", "Spine$Unity$ISkeletonAnimation$addOnAnimationRebuild",
            "removeOnAnimationRebuild", "Spine$Unity$ISkeletonAnimation$removeOnAnimationRebuild",
            "addUpdateLocal", "Spine$Unity$ISkeletonAnimation$addUpdateLocal",
            "removeUpdateLocal", "Spine$Unity$ISkeletonAnimation$removeUpdateLocal",
            "addUpdateWorld", "Spine$Unity$ISkeletonAnimation$addUpdateWorld",
            "removeUpdateWorld", "Spine$Unity$ISkeletonAnimation$removeUpdateWorld",
            "addUpdateComplete", "Spine$Unity$ISkeletonAnimation$addUpdateComplete",
            "removeUpdateComplete", "Spine$Unity$ISkeletonAnimation$removeUpdateComplete",
            "UpdateTiming", "Spine$Unity$ISkeletonAnimation$UpdateTiming",
            "UnscaledTime", "Spine$Unity$IAnimationStateComponent$UnscaledTime"
        ],
        ctors: {
            init: function () {
                this.referenceSize = new UnityEngine.Vector2();
                this.timeScale = 1.0;
                this.meshScale = 1.0;
                this.layoutScaleMode = Spine.Unity.SkeletonGraphic.LayoutMode.None;
                this.referenceSize = pc.Vec2.ONE.clone();
                this.referenceScale = 1.0;
                this.updateMode = Spine.Unity.UpdateMode.FullUpdate;
                this.updateWhenInvisible = Spine.Unity.UpdateMode.FullUpdate;
                this.allowMultipleCanvasRenderers = false;
                this.canvasRenderers = new (System.Collections.Generic.List$1(UnityEngine.CanvasRenderer)).ctor();
                this.submeshGraphics = new (System.Collections.Generic.List$1(Spine.Unity.SkeletonSubmeshGraphic)).ctor();
                this.usedRenderersCount = 0;
                this.separatorSlotNames = System.Array.init(0, null, System.String);
                this.separatorSlots = new (System.Collections.Generic.List$1(Spine.Slot)).ctor();
                this.enableSeparatorSlots = false;
                this.separatorParts = new (System.Collections.Generic.List$1(UnityEngine.Transform)).ctor();
                this.updateSeparatorPartLocation = true;
                this.updateSeparatorPartScale = false;
                this.wasUpdatedAfterInit = true;
                this.disableMeshAssignmentOnOverride = true;
                this.customTextureOverride = new (System.Collections.Generic.Dictionary$2(UnityEngine.Texture,UnityEngine.Texture)).ctor();
                this.customMaterialOverride = new (System.Collections.Generic.Dictionary$2(UnityEngine.Texture,UnityEngine.Material)).ctor();
                this.meshGenerator = new Spine.Unity.MeshGenerator();
                this.currentInstructions = new Spine.Unity.SkeletonRendererInstruction();
                this.meshes = new (Spine.ExposedList$1(UnityEngine.Mesh)).ctor();
                this.usedMaterials = new (Spine.ExposedList$1(UnityEngine.Material)).ctor();
                this.usedTextures = new (Spine.ExposedList$1(UnityEngine.Texture)).ctor();
                this.updateTiming = Spine.Unity.UpdateTiming.InUpdate;
            }
        },
        methods: {
            /**
             * Allows separate code to take over mesh and material assignment for this SkeletonGraphic component.
             Used when <pre><code>allowMultipleCanvasRenderers</code></pre> is false.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonGraphic
             * @event Spine.Unity.SkeletonGraphic#AssignMeshOverrideSingleRenderer
             * @return  {Spine.Unity.SkeletonGraphic.MeshAssignmentDelegateSingle}
             */
            addAssignMeshOverrideSingleRenderer: function (value) {
                this.addassignMeshOverrideSingle(value);
                if (this.disableMeshAssignmentOnOverride && !Bridge.staticEquals(this.assignMeshOverrideSingle, null)) {
                    this.Initialize(false);
                }
            },
            /**
             * Allows separate code to take over mesh and material assignment for this SkeletonGraphic component.
             Used when <pre><code>allowMultipleCanvasRenderers</code></pre> is false.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonGraphic
             * @event Spine.Unity.SkeletonGraphic#AssignMeshOverrideSingleRenderer
             * @return  {Spine.Unity.SkeletonGraphic.MeshAssignmentDelegateSingle}
             */
            removeAssignMeshOverrideSingleRenderer: function (value) {
                this.removeassignMeshOverrideSingle(value);
                if (this.disableMeshAssignmentOnOverride && Bridge.staticEquals(this.assignMeshOverrideSingle, null)) {
                    this.Initialize(false);
                }
            },
            /**
             * Allows separate code to take over mesh and material assignment for this SkeletonGraphic component.
             Used when <pre><code>allowMultipleCanvasRenderers</code></pre> is true.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonGraphic
             * @event Spine.Unity.SkeletonGraphic#AssignMeshOverrideMultipleRenderers
             * @return  {Spine.Unity.SkeletonGraphic.MeshAssignmentDelegateMultiple}
             */
            addAssignMeshOverrideMultipleRenderers: function (value) {
                this.addassignMeshOverrideMultiple(value);
                if (this.disableMeshAssignmentOnOverride && !Bridge.staticEquals(this.assignMeshOverrideMultiple, null)) {
                    this.Initialize(false);
                }
            },
            /**
             * Allows separate code to take over mesh and material assignment for this SkeletonGraphic component.
             Used when <pre><code>allowMultipleCanvasRenderers</code></pre> is true.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonGraphic
             * @event Spine.Unity.SkeletonGraphic#AssignMeshOverrideMultipleRenderers
             * @return  {Spine.Unity.SkeletonGraphic.MeshAssignmentDelegateMultiple}
             */
            removeAssignMeshOverrideMultipleRenderers: function (value) {
                this.removeassignMeshOverrideMultiple(value);
                if (this.disableMeshAssignmentOnOverride && Bridge.staticEquals(this.assignMeshOverrideMultiple, null)) {
                    this.Initialize(false);
                }
            },
            /*Spine.Unity.SkeletonGraphic.Awake start.*/
            Awake: function () {
                UnityEngine.UI.MaskableGraphic.prototype.Awake.call(this);
                this.onCullStateChanged.AddListener(Bridge.fn.cacheBind(this, this.OnCullStateChanged));

                this.SyncSubmeshGraphicsWithCanvasRenderers();
                if (!this.IsValid) {
                    this.Initialize(false);
                    if (this.IsValid) {
                        this.Rebuild(UnityEngine.UI.CanvasUpdate.PreRender);
                    }
                }

            },
            /*Spine.Unity.SkeletonGraphic.Awake end.*/

            /*Spine.Unity.SkeletonGraphic.OnDestroy start.*/
            OnDestroy: function () {
                this.Clear();
                UnityEngine.UI.MaskableGraphic.prototype.OnDestroy.call(this);
            },
            /*Spine.Unity.SkeletonGraphic.OnDestroy end.*/

            /*Spine.Unity.SkeletonGraphic.Rebuild start.*/
            Rebuild: function (update) {
                UnityEngine.UI.MaskableGraphic.prototype.Rebuild.call(this, update);
                if (!this.IsValid) {
                    return;
                }
                if (this.canvasRenderer.cull) {
                    return;
                }
                if (update === UnityEngine.UI.CanvasUpdate.PreRender) {
                    this.PrepareInstructionsAndRenderers(true);
                    this.UpdateMeshToInstructions();
                }
                if (this.allowMultipleCanvasRenderers) {
                    this.canvasRenderer.Clear();
                }
            },
            /*Spine.Unity.SkeletonGraphic.Rebuild end.*/

            /*Spine.Unity.SkeletonGraphic.OnDisable start.*/
            OnDisable: function () {
                var $t;
                UnityEngine.UI.MaskableGraphic.prototype.OnDisable.call(this);
                $t = Bridge.getEnumerator(this.canvasRenderers);
                try {
                    while ($t.moveNext()) {
                        var canvasRenderer = $t.Current;
                        canvasRenderer.Clear();
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.Unity.SkeletonGraphic.OnDisable end.*/

            /*Spine.Unity.SkeletonGraphic.Update start.*/
            Update: function () {
                if (this.freeze || this.updateTiming !== Spine.Unity.UpdateTiming.InUpdate) {
                    return;
                }
                this.Update$1(this.unscaledTime ? UnityEngine.Time.unscaledDeltaTime : UnityEngine.Time.deltaTime);
            },
            /*Spine.Unity.SkeletonGraphic.Update end.*/

            /*Spine.Unity.SkeletonGraphic.Update$1 start.*/
            Update$1: function (deltaTime) {
                if (!this.IsValid) {
                    return;
                }

                this.wasUpdatedAfterInit = true;
                if (this.updateMode < Spine.Unity.UpdateMode.OnlyAnimationStatus) {
                    return;
                }
                this.UpdateAnimationStatus(deltaTime);

                if (this.updateMode === Spine.Unity.UpdateMode.OnlyAnimationStatus) {
                    this.state.ApplyEventTimelinesOnly(this.skeleton, false);
                    return;
                }
                this.ApplyAnimation();
            },
            /*Spine.Unity.SkeletonGraphic.Update$1 end.*/

            /*Spine.Unity.SkeletonGraphic.FixedUpdate start.*/
            FixedUpdate: function () {
                if (this.freeze || this.updateTiming !== Spine.Unity.UpdateTiming.InFixedUpdate) {
                    return;
                }
                this.Update$1(this.unscaledTime ? UnityEngine.Time.unscaledDeltaTime : UnityEngine.Time.deltaTime);
            },
            /*Spine.Unity.SkeletonGraphic.FixedUpdate end.*/

            /*Spine.Unity.SkeletonGraphic.SyncSubmeshGraphicsWithCanvasRenderers start.*/
            SyncSubmeshGraphicsWithCanvasRenderers: function () {
                var $t;
                this.submeshGraphics.clear();

                $t = Bridge.getEnumerator(this.canvasRenderers);
                try {
                    while ($t.moveNext()) {
                        var canvasRenderer = $t.Current;
                        var submeshGraphic = canvasRenderer.GetComponent(Spine.Unity.SkeletonSubmeshGraphic);
                        if (UnityEngine.MonoBehaviour.op_Equality(submeshGraphic, null)) {
                            submeshGraphic = canvasRenderer.gameObject.AddComponent(Spine.Unity.SkeletonSubmeshGraphic);
                            submeshGraphic.maskable = this.maskable;
                            submeshGraphic.raycastTarget = false;
                        }
                        this.submeshGraphics.add(submeshGraphic);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.Unity.SkeletonGraphic.SyncSubmeshGraphicsWithCanvasRenderers end.*/

            /*Spine.Unity.SkeletonGraphic.UpdateAnimationStatus start.*/
            UpdateAnimationStatus: function (deltaTime) {
                deltaTime *= this.timeScale;
                this.state.update(deltaTime);
            },
            /*Spine.Unity.SkeletonGraphic.UpdateAnimationStatus end.*/

            /*Spine.Unity.SkeletonGraphic.ApplyAnimation start.*/
            ApplyAnimation: function () {
                if (!Bridge.staticEquals(this.BeforeApply, null)) {
                    this.BeforeApply(this);
                }

                if (this.updateMode !== Spine.Unity.UpdateMode.OnlyEventTimelines) {
                    this.state.apply(this.skeleton);
                } else {
                    this.state.ApplyEventTimelinesOnly(this.skeleton, true);
                }

                this.AfterAnimationApplied();
            },
            /*Spine.Unity.SkeletonGraphic.ApplyAnimation end.*/

            /*Spine.Unity.SkeletonGraphic.AfterAnimationApplied start.*/
            AfterAnimationApplied: function () {
                if (!Bridge.staticEquals(this.UpdateLocal, null)) {
                    this.UpdateLocal(this);
                }

                this.skeleton.updateWorldTransform();

                if (!Bridge.staticEquals(this.UpdateWorld, null)) {
                    this.UpdateWorld(this);
                    this.skeleton.updateWorldTransform();
                }

                if (!Bridge.staticEquals(this.UpdateComplete, null)) {
                    this.UpdateComplete(this);
                }
            },
            /*Spine.Unity.SkeletonGraphic.AfterAnimationApplied end.*/

            /*Spine.Unity.SkeletonGraphic.LateUpdate start.*/
            LateUpdate: function () {
                if (!this.IsValid) {
                    return;
                }
                // instantiation can happen from Update() after this component, leading to a missing Update() call.
                if (!this.wasUpdatedAfterInit) {
                    this.Update$1(0);
                }
                if (this.freeze) {
                    return;
                }
                if (this.updateMode !== Spine.Unity.UpdateMode.FullUpdate) {
                    return;
                }

                if (this.updateTiming === Spine.Unity.UpdateTiming.InLateUpdate) {
                    this.Update$1(this.unscaledTime ? UnityEngine.Time.unscaledDeltaTime : UnityEngine.Time.deltaTime);
                }

                this.UpdateMesh();
            },
            /*Spine.Unity.SkeletonGraphic.LateUpdate end.*/

            /*Spine.Unity.SkeletonGraphic.OnCullStateChanged start.*/
            OnCullStateChanged: function (culled) {
                if (culled) {
                    this.OnBecameInvisible();
                } else {
                    this.OnBecameVisible();
                }
            },
            /*Spine.Unity.SkeletonGraphic.OnCullStateChanged end.*/

            /*Spine.Unity.SkeletonGraphic.OnBecameVisible start.*/
            OnBecameVisible: function () {
                this.updateMode = Spine.Unity.UpdateMode.FullUpdate;
            },
            /*Spine.Unity.SkeletonGraphic.OnBecameVisible end.*/

            /*Spine.Unity.SkeletonGraphic.OnBecameInvisible start.*/
            OnBecameInvisible: function () {
                this.updateMode = this.updateWhenInvisible;
            },
            /*Spine.Unity.SkeletonGraphic.OnBecameInvisible end.*/

            /*Spine.Unity.SkeletonGraphic.ReapplySeparatorSlotNames start.*/
            ReapplySeparatorSlotNames: function () {
                if (!this.IsValid) {
                    return;
                }

                this.separatorSlots.clear();
                for (var i = 0, n = this.separatorSlotNames.length; i < n; i = (i + 1) | 0) {
                    var slotName = this.separatorSlotNames[i];
                    if (Bridge.referenceEquals(slotName, "")) {
                        continue;
                    }
                    var slot = this.skeleton.findSlot(slotName);
                    if (slot != null) {
                        this.separatorSlots.add(slot);
                    }
                }
                this.UpdateSeparatorPartParents();
            },
            /*Spine.Unity.SkeletonGraphic.ReapplySeparatorSlotNames end.*/

            /*Spine.Unity.SkeletonGraphic.GetLastMesh start.*/
            GetLastMesh: function () {
                return this.meshBuffers.GetCurrent().mesh;
            },
            /*Spine.Unity.SkeletonGraphic.GetLastMesh end.*/

            /*Spine.Unity.SkeletonGraphic.MatchRectTransformWithBounds start.*/
            MatchRectTransformWithBounds: function () {
                if (!this.wasUpdatedAfterInit) {
                    this.Update$1(0);
                }
                this.UpdateMesh();

                if (!this.allowMultipleCanvasRenderers) {
                    return this.MatchRectTransformSingleRenderer();
                } else {
                    return this.MatchRectTransformMultipleRenderers();
                }
            },
            /*Spine.Unity.SkeletonGraphic.MatchRectTransformWithBounds end.*/

            /*Spine.Unity.SkeletonGraphic.MatchRectTransformSingleRenderer start.*/
            MatchRectTransformSingleRenderer: function () {
                var mesh = this.GetLastMesh();
                if (mesh == null) {
                    return false;
                }
                if (mesh.vertexCount === 0 || pc.Vec3.equals( mesh.bounds.halfExtents.$clone().scale( 2 ), pc.Vec3.ZERO.clone() )) {
                    this.rectTransform.sizeDelta = new pc.Vec2( 50.0, 50.0 );
                    this.rectTransform.pivot = new pc.Vec2( 0.5, 0.5 );
                    return false;
                }
                mesh.RecalculateBounds();
                this.SetRectTransformBounds(mesh.bounds);
                return true;
            },
            /*Spine.Unity.SkeletonGraphic.MatchRectTransformSingleRenderer end.*/

            /*Spine.Unity.SkeletonGraphic.MatchRectTransformMultipleRenderers start.*/
            MatchRectTransformMultipleRenderers: function () {
                var $t;
                var anyBoundsAdded = false;
                var combinedBounds = new pc.BoundingBox.ctor();
                for (var i = 0; i < this.canvasRenderers.Count; i = (i + 1) | 0) {
                    var canvasRenderer = this.canvasRenderers.getItem(i);
                    if (!canvasRenderer.gameObject.activeSelf) {
                        continue;
                    }

                    var mesh = ($t = this.meshes.Items)[i];
                    if (mesh == null || mesh.vertexCount === 0) {
                        continue;
                    }

                    mesh.RecalculateBounds();
                    var bounds = mesh.bounds;
                    if (anyBoundsAdded) {
                        combinedBounds.add( bounds );
                    } else {
                        anyBoundsAdded = true;
                        combinedBounds = bounds;
                    }
                }

                if (!anyBoundsAdded || pc.Vec3.equals( combinedBounds.halfExtents.$clone().scale( 2 ), pc.Vec3.ZERO.clone() )) {
                    this.rectTransform.sizeDelta = new pc.Vec2( 50.0, 50.0 );
                    this.rectTransform.pivot = new pc.Vec2( 0.5, 0.5 );
                    return false;
                }

                this.SetRectTransformBounds(combinedBounds);
                return true;
            },
            /*Spine.Unity.SkeletonGraphic.MatchRectTransformMultipleRenderers end.*/

            /*Spine.Unity.SkeletonGraphic.SetRectTransformBounds start.*/
            SetRectTransformBounds: function (combinedBounds) {
                var $t, $t1;
                var size = combinedBounds.halfExtents.$clone().scale( 2 ).$clone();
                var center = combinedBounds.center.$clone();
                var p = new pc.Vec2( 0.5 - (center.x / size.x), 0.5 - (center.y / size.y) );

                Spine.Unity.SkeletonGraphic.SetRectTransformSize$1(this, UnityEngine.Vector2.FromVector3(size.$clone()));
                this.rectTransform.pivot = p.$clone();

                $t = Bridge.getEnumerator(this.separatorParts);
                try {
                    while ($t.moveNext()) {
                        var separatorPart = $t.Current;
                        var separatorTransform = separatorPart.GetComponent(UnityEngine.RectTransform);
                        if (UnityEngine.Object.op_Implicit(separatorTransform)) {
                            Spine.Unity.SkeletonGraphic.SetRectTransformSize(separatorTransform, UnityEngine.Vector2.FromVector3(size.$clone()));
                            separatorTransform.pivot = p.$clone();
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                $t1 = Bridge.getEnumerator(this.submeshGraphics);
                try {
                    while ($t1.moveNext()) {
                        var submeshGraphic = $t1.Current;
                        Spine.Unity.SkeletonGraphic.SetRectTransformSize$1(submeshGraphic, UnityEngine.Vector2.FromVector3(size.$clone()));
                        submeshGraphic.rectTransform.pivot = p.$clone();
                    }
                } finally {
                    if (Bridge.is($t1, System.IDisposable)) {
                        $t1.System$IDisposable$Dispose();
                    }
                }

                this.referenceSize = UnityEngine.Vector2.FromVector3(size.$clone());
            },
            /*Spine.Unity.SkeletonGraphic.SetRectTransformBounds end.*/

            /*Spine.Unity.SkeletonGraphic.Clear start.*/
            Clear: function () {
                this.skeleton = null;
                this.canvasRenderer.Clear();

                for (var i = 0; i < this.canvasRenderers.Count; i = (i + 1) | 0) {
                    this.canvasRenderers.getItem(i).Clear();
                }
                this.DestroyMeshes();
                this.usedMaterials.Clear();
                this.usedTextures.Clear();
                this.DisposeMeshBuffers();
            },
            /*Spine.Unity.SkeletonGraphic.Clear end.*/

            /*Spine.Unity.SkeletonGraphic.TrimRenderers start.*/
            TrimRenderers: function () {
                var $t;
                var newList = new (System.Collections.Generic.List$1(UnityEngine.CanvasRenderer)).ctor();
                $t = Bridge.getEnumerator(this.canvasRenderers);
                try {
                    while ($t.moveNext()) {
                        var canvasRenderer = $t.Current;
                        if (canvasRenderer.gameObject.activeSelf) {
                            newList.add(canvasRenderer);
                        } else {
                            if (UnityEngine.Application.isEditor && !UnityEngine.Application.isPlaying) {
                                UnityEngine.Object.DestroyImmediate(canvasRenderer.gameObject);
                            } else {
                                UnityEngine.MonoBehaviour.Destroy(canvasRenderer.gameObject);
                            }
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                this.canvasRenderers = newList;
                this.SyncSubmeshGraphicsWithCanvasRenderers();
            },
            /*Spine.Unity.SkeletonGraphic.TrimRenderers end.*/

            /*Spine.Unity.SkeletonGraphic.Initialize start.*/
            Initialize: function (overwrite) {
                var $t, $t1;
                if (this.IsValid && !overwrite) {
                    return;
                }
                if (this.skeletonDataAsset == null) {
                    return;
                }
                var skeletonData = this.skeletonDataAsset.GetSkeletonData(false);
                if (skeletonData == null) {
                    return;
                }

                if (this.skeletonDataAsset.atlasAssets.length <= 0 || ($t = this.skeletonDataAsset.atlasAssets)[0].MaterialCount <= 0) {
                    return;
                }

                this.skeleton = ($t1 = new Spine.Skeleton.$ctor1(skeletonData), $t1.scaleX = this.initialFlipX ? -1 : 1, $t1.scaleY = this.initialFlipY ? -1 : 1, $t1);

                this.InitMeshBuffers();
                this.baseTexture = ($t1 = this.skeletonDataAsset.atlasAssets)[0].PrimaryMaterial.mainTexture;
                this.canvasRenderer.SetTexture(this.mainTexture); // Needed for overwriting initializations.

                // Set the initial Skin and Animation
                if (!System.String.isNullOrEmpty(this.initialSkinName)) {
                    this.skeleton.setSkinByName(this.initialSkinName);
                }

                this.separatorSlots.clear();
                for (var i = 0; i < this.separatorSlotNames.length; i = (i + 1) | 0) {
                    this.separatorSlots.add(this.skeleton.findSlot(this.separatorSlotNames[i]));
                }

                if (!Bridge.staticEquals(this.OnRebuild, null)) {
                    this.OnRebuild(this);
                }

                this.wasUpdatedAfterInit = false;
                this.state = new Spine.AnimationState(this.skeletonDataAsset.GetAnimationStateData());
                if (this.state == null) {
                    this.Clear();
                    return;
                }

                if (!System.String.isNullOrEmpty(this.startingAnimation)) {
                    var animationObject = this.skeletonDataAsset.GetSkeletonData(false).findAnimation(this.startingAnimation);
                    if (animationObject != null) {
                        this.state.setAnimationWith( 0, animationObject, this.startingLoop );
                    }
                }

                if (!Bridge.staticEquals(this.OnAnimationRebuild, null)) {
                    this.OnAnimationRebuild(this);
                }
            },
            /*Spine.Unity.SkeletonGraphic.Initialize end.*/

            /*Spine.Unity.SkeletonGraphic.PrepareInstructionsAndRenderers start.*/
            PrepareInstructionsAndRenderers: function (isInRebuild) {
                if (isInRebuild === void 0) { isInRebuild = false; }
                if (!this.allowMultipleCanvasRenderers) {
                    Spine.Unity.MeshGenerator.GenerateSingleSubmeshInstruction(this.currentInstructions, this.skeleton, null);
                    if (this.canvasRenderers.Count > 0) {
                        this.DisableUnusedCanvasRenderers(0, isInRebuild);
                    }
                    this.usedRenderersCount = 0;
                } else {
                    Spine.Unity.MeshGenerator.GenerateSkeletonRendererInstruction(this.currentInstructions, this.skeleton, null, this.enableSeparatorSlots ? this.separatorSlots : null, this.enableSeparatorSlots ? this.separatorSlots.Count > 0 : false, false);

                    var submeshCount = this.currentInstructions.submeshInstructions.Count;
                    this.EnsureCanvasRendererCount(submeshCount);
                    this.EnsureMeshesCount(submeshCount);
                    this.EnsureUsedTexturesAndMaterialsCount(submeshCount);
                    this.EnsureSeparatorPartCount();
                    this.PrepareRendererGameObjects(this.currentInstructions, isInRebuild);
                }
                if (!Bridge.staticEquals(this.OnInstructionsPrepared, null)) {
                    this.OnInstructionsPrepared(this.currentInstructions);
                }
            },
            /*Spine.Unity.SkeletonGraphic.PrepareInstructionsAndRenderers end.*/

            /*Spine.Unity.SkeletonGraphic.UpdateMesh start.*/
            UpdateMesh: function () {
                this.PrepareInstructionsAndRenderers();
                this.UpdateMeshToInstructions();
            },
            /*Spine.Unity.SkeletonGraphic.UpdateMesh end.*/

            /*Spine.Unity.SkeletonGraphic.UpdateMeshToInstructions start.*/
            UpdateMeshToInstructions: function () {
                if (!this.IsValid || this.currentInstructions.rawVertexCount < 0) {
                    return;
                }
                Spine.Unity.SkeletonExtensions.SetColor$4(this.skeleton, this.color.$clone());

                if (!this.allowMultipleCanvasRenderers) {
                    this.UpdateMeshSingleCanvasRenderer(this.currentInstructions);
                } else {
                    this.UpdateMaterialsMultipleCanvasRenderers(this.currentInstructions);
                    this.UpdateMeshMultipleCanvasRenderers(this.currentInstructions);
                }

                if (!Bridge.staticEquals(this.OnMeshAndMaterialsUpdated, null)) {
                    this.OnMeshAndMaterialsUpdated(this);
                }
            },
            /*Spine.Unity.SkeletonGraphic.UpdateMeshToInstructions end.*/

            /*Spine.Unity.SkeletonGraphic.HasMultipleSubmeshInstructions start.*/
            HasMultipleSubmeshInstructions: function () {
                if (!this.IsValid) {
                    return false;
                }
                return Spine.Unity.MeshGenerator.RequiresMultipleSubmeshesByDrawOrder(this.skeleton);
            },
            /*Spine.Unity.SkeletonGraphic.HasMultipleSubmeshInstructions end.*/

            /*Spine.Unity.SkeletonGraphic.InitMeshBuffers start.*/
            InitMeshBuffers: function () {
                if (this.meshBuffers != null) {
                    this.meshBuffers.GetNext().Clear();
                    this.meshBuffers.GetNext().Clear();
                } else {
                    this.meshBuffers = new (Spine.Unity.DoubleBuffered$1(Spine.Unity.MeshRendererBuffers.SmartMesh))();
                }
            },
            /*Spine.Unity.SkeletonGraphic.InitMeshBuffers end.*/

            /*Spine.Unity.SkeletonGraphic.DisposeMeshBuffers start.*/
            DisposeMeshBuffers: function () {
                if (this.meshBuffers != null) {
                    this.meshBuffers.GetNext().Dispose();
                    this.meshBuffers.GetNext().Dispose();
                    this.meshBuffers = null;
                }
            },
            /*Spine.Unity.SkeletonGraphic.DisposeMeshBuffers end.*/

            /*Spine.Unity.SkeletonGraphic.UpdateMeshSingleCanvasRenderer start.*/
            UpdateMeshSingleCanvasRenderer: function (currentInstructions) {
                var $t, $t1;
                var smartMesh = this.meshBuffers.GetNext();
                var updateTriangles = Spine.Unity.SkeletonRendererInstruction.GeometryNotEqual(currentInstructions, smartMesh.instructionUsed);
                this.meshGenerator.Begin();

                var useAddSubmesh = currentInstructions.hasActiveClipping && currentInstructions.submeshInstructions.Count > 0;
                if (useAddSubmesh) {
                    this.meshGenerator.AddSubmesh(($t = currentInstructions.submeshInstructions.Items)[0].$clone(), updateTriangles);
                } else {
                    this.meshGenerator.BuildMeshWithArrays(currentInstructions, updateTriangles);
                }

                this.meshScale = (UnityEngine.Component.op_Equality(this.canvas, null)) ? 100 : this.canvas.referencePixelsPerUnit;
                if (this.layoutScaleMode !== Spine.Unity.SkeletonGraphic.LayoutMode.None) {
                    this.meshScale *= this.referenceScale;
                    if (true) {
                        this.meshScale *= this.GetLayoutScale(this.layoutScaleMode);
                    }
                }
                this.meshGenerator.ScaleVertexData(this.meshScale);
                if (!Bridge.staticEquals(this.OnPostProcessVertices, null)) {
                    this.OnPostProcessVertices(this.meshGenerator.Buffers.$clone());
                }

                var mesh = smartMesh.mesh;
                this.meshGenerator.FillVertexData(mesh);
                if (updateTriangles) {
                    this.meshGenerator.FillTriangles(mesh);
                }
                this.meshGenerator.FillLateVertexData(mesh);

                smartMesh.instructionUsed.Set(currentInstructions);
                if (!Bridge.staticEquals(this.assignMeshOverrideSingle, null)) {
                    this.assignMeshOverrideSingle(mesh, this.canvasRenderer.GetMaterial(), this.mainTexture);
                }

                var assignAtCanvasRenderer = (Bridge.staticEquals(this.assignMeshOverrideSingle, null) || !this.disableMeshAssignmentOnOverride);
                if (assignAtCanvasRenderer) {
                    this.canvasRenderer.SetMesh(mesh);
                } else {
                    this.canvasRenderer.SetMesh(null);
                }

                var assignTexture = false;
                if (currentInstructions.submeshInstructions.Count > 0) {
                    var material = ($t1 = currentInstructions.submeshInstructions.Items)[0].material;
                    if (material != null && !Bridge.referenceEquals(this.baseTexture, material.mainTexture)) {
                        this.baseTexture = material.mainTexture;
                        if (this.overrideTexture == null && assignAtCanvasRenderer) {
                            assignTexture = true;
                        }
                    }
                }

                if (UnityEngine.Application.isPlaying) {
                    this.HandleOnDemandLoading();
                }
                if (assignTexture) {
                    this.canvasRenderer.SetTexture(this.mainTexture);
                }
            },
            /*Spine.Unity.SkeletonGraphic.UpdateMeshSingleCanvasRenderer end.*/

            /*Spine.Unity.SkeletonGraphic.UpdateMaterialsMultipleCanvasRenderers start.*/
            UpdateMaterialsMultipleCanvasRenderers: function (currentInstructions) {
                var $t;
                var submeshCount = currentInstructions.submeshInstructions.Count;
                var useOriginalTextureAndMaterial = (this.customMaterialOverride.Count === 0 && this.customTextureOverride.Count === 0);

                var blendModeMaterials = this.skeletonDataAsset.blendModeMaterials;
                var hasBlendModeMaterials = blendModeMaterials.RequiresBlendModeMaterials;

                var pmaVertexColors = this.meshGenerator.settings.pmaVertexColors;
                var usedMaterialItems = this.usedMaterials.Items;
                var usedTextureItems = this.usedTextures.Items;
                for (var i = 0; i < submeshCount; i = (i + 1) | 0) {
                    var submeshInstructionItem = ($t = currentInstructions.submeshInstructions.Items)[i].$clone();
                    var submeshMaterial = submeshInstructionItem.material;
                    if (useOriginalTextureAndMaterial) {
                        if (submeshMaterial == null) {
                            usedMaterialItems[i] = null;
                            usedTextureItems[i] = null;
                            continue;
                        }
                        usedTextureItems[i] = submeshMaterial.mainTexture;
                        if (!hasBlendModeMaterials) {
                            usedMaterialItems[i] = this.materialForRendering;
                        } else {
                            var blendMode = blendModeMaterials.BlendModeForMaterial(submeshMaterial);
                            var usedMaterial = this.materialForRendering;
                            if (blendMode === spine.BlendMode.Additive && !pmaVertexColors && UnityEngine.Object.op_Implicit(this.additiveMaterial)) {
                                usedMaterial = this.additiveMaterial;
                            } else if (blendMode === spine.BlendMode.Multiply && UnityEngine.Object.op_Implicit(this.multiplyMaterial)) {
                                usedMaterial = this.multiplyMaterial;
                            } else {
                                if (blendMode === spine.BlendMode.Screen && UnityEngine.Object.op_Implicit(this.screenMaterial)) {
                                    usedMaterial = this.screenMaterial;
                                }
                            }
                            usedMaterialItems[i] = this.submeshGraphics.getItem(i).GetModifiedMaterial(usedMaterial);
                        }
                    } else {
                        var originalTexture = submeshMaterial.mainTexture;
                        var usedMaterial1 = { };
                        var usedTexture = { };
                        if (!this.customMaterialOverride.tryGetValue(originalTexture, usedMaterial1)) {
                            usedMaterial1.v = this.material;
                        }
                        if (!this.customTextureOverride.tryGetValue(originalTexture, usedTexture)) {
                            usedTexture.v = originalTexture;
                        }

                        usedMaterialItems[i] = this.submeshGraphics.getItem(i).GetModifiedMaterial(usedMaterial1.v);
                        usedTextureItems[i] = usedTexture.v;
                    }
                }
            },
            /*Spine.Unity.SkeletonGraphic.UpdateMaterialsMultipleCanvasRenderers end.*/

            /*Spine.Unity.SkeletonGraphic.UpdateMeshMultipleCanvasRenderers start.*/
            UpdateMeshMultipleCanvasRenderers: function (currentInstructions) {
                var $t;
                this.meshScale = (UnityEngine.Component.op_Equality(this.canvas, null)) ? 100 : this.canvas.referencePixelsPerUnit;
                if (this.layoutScaleMode !== Spine.Unity.SkeletonGraphic.LayoutMode.None) {
                    this.meshScale *= this.referenceScale;
                    if (true) {
                        this.meshScale *= this.GetLayoutScale(this.layoutScaleMode);
                    }
                }
                // Generate meshes.
                var submeshCount = currentInstructions.submeshInstructions.Count;
                var meshesItems = this.meshes.Items;
                var useOriginalTextureAndMaterial = (this.customMaterialOverride.Count === 0 && this.customTextureOverride.Count === 0);

                var blendModeMaterials = this.skeletonDataAsset.blendModeMaterials;
                var hasBlendModeMaterials = blendModeMaterials.RequiresBlendModeMaterials;
                var mainCullTransparentMesh = this.canvasRenderer.cullTransparentMesh;
                var pmaVertexColors = this.meshGenerator.settings.pmaVertexColors;
                var usedMaterialItems = this.usedMaterials.Items;
                var usedTextureItems = this.usedTextures.Items;
                for (var i = 0; i < submeshCount; i = (i + 1) | 0) {
                    var submeshInstructionItem = ($t = currentInstructions.submeshInstructions.Items)[i].$clone();
                    this.meshGenerator.Begin();
                    this.meshGenerator.AddSubmesh(submeshInstructionItem.$clone());

                    var targetMesh = meshesItems[i];
                    this.meshGenerator.ScaleVertexData(this.meshScale);
                    if (!Bridge.staticEquals(this.OnPostProcessVertices, null)) {
                        this.OnPostProcessVertices(this.meshGenerator.Buffers.$clone());
                    }
                    this.meshGenerator.FillVertexData(targetMesh);
                    this.meshGenerator.FillTriangles(targetMesh);
                    this.meshGenerator.FillLateVertexData(targetMesh);

                    var canvasRenderer = this.canvasRenderers.getItem(i);
                    if (Bridge.staticEquals(this.assignMeshOverrideSingle, null) || !this.disableMeshAssignmentOnOverride) {
                        canvasRenderer.SetMesh(targetMesh);
                    } else {
                        canvasRenderer.SetMesh(null);
                    }

                    var submeshGraphic = this.submeshGraphics.getItem(i);
                    if (useOriginalTextureAndMaterial && hasBlendModeMaterials) {
                        var allowCullTransparentMesh = true;
                        var materialBlendMode = blendModeMaterials.BlendModeForMaterial(usedMaterialItems[i]);
                        if ((materialBlendMode === spine.BlendMode.Normal && submeshInstructionItem.hasPMAAdditiveSlot) || (materialBlendMode === spine.BlendMode.Additive && pmaVertexColors)) {
                            allowCullTransparentMesh = false;
                        }
                        canvasRenderer.cullTransparentMesh = allowCullTransparentMesh ? mainCullTransparentMesh : false;
                    }
                    canvasRenderer.materialCount = 1;
                }

                if (UnityEngine.Application.isPlaying) {
                    this.HandleOnDemandLoading();
                }
                var assignAtCanvasRenderer = (Bridge.staticEquals(this.assignMeshOverrideSingle, null) || !this.disableMeshAssignmentOnOverride);
                if (assignAtCanvasRenderer) {
                    for (var i1 = 0; i1 < submeshCount; i1 = (i1 + 1) | 0) {
                        var canvasRenderer1 = this.canvasRenderers.getItem(i1);
                        canvasRenderer1.SetMaterial$1(usedMaterialItems[i1], usedTextureItems[i1]);
                    }
                }

                if (!Bridge.staticEquals(this.assignMeshOverrideMultiple, null)) {
                    this.assignMeshOverrideMultiple(submeshCount, meshesItems, usedMaterialItems, usedTextureItems);
                }
            },
            /*Spine.Unity.SkeletonGraphic.UpdateMeshMultipleCanvasRenderers end.*/

            /*Spine.Unity.SkeletonGraphic.HandleOnDemandLoading start.*/
            HandleOnDemandLoading: function () {
                var $t, $t1;
                $t = Bridge.getEnumerator(this.skeletonDataAsset.atlasAssets);
                try {
                    while ($t.moveNext()) {
                        var atlasAsset = $t.Current;
                        if (atlasAsset.TextureLoadingMode !== Spine.Unity.AtlasAssetBase.LoadingMode.Normal) {
                            atlasAsset.BeginCustomTextureLoading();

                            if (!this.allowMultipleCanvasRenderers) {
                                var loadedTexture = { v : null };
                                atlasAsset.RequireTextureLoaded(this.mainTexture, loadedTexture, null);
                                if (UnityEngine.Object.op_Implicit(loadedTexture.v)) {
                                    this.baseTexture = loadedTexture.v;
                                }
                            } else {
                                var textureItems = this.usedTextures.Items;
                                for (var i = 0, count = this.usedTextures.Count; i < count; i = (i + 1) | 0) {
                                    var loadedTexture1 = { v : null };
                                    atlasAsset.RequireTextureLoaded(textureItems[i], loadedTexture1, null);
                                    if (UnityEngine.Object.op_Implicit(loadedTexture1.v)) {
                                        ($t1 = this.usedTextures.Items)[i] = loadedTexture1.v;
                                    }
                                }
                            }
                            atlasAsset.EndCustomTextureLoading();
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.Unity.SkeletonGraphic.HandleOnDemandLoading end.*/

            /*Spine.Unity.SkeletonGraphic.EnsureCanvasRendererCount start.*/
            EnsureCanvasRendererCount: function (targetCount) {
                var currentCount = this.canvasRenderers.Count;
                for (var i = currentCount; i < targetCount; i = (i + 1) | 0) {
                    var go = new UnityEngine.GameObject.$ctor3(System.String.format("Renderer{0}", [Bridge.box(i, System.Int32)]), UnityEngine.RectTransform);
                    go.transform.SetParent(this.transform, false);
                    go.transform.localPosition = pc.Vec3.ZERO.clone();
                    var canvasRenderer = go.AddComponent(UnityEngine.CanvasRenderer);
                    this.canvasRenderers.add(canvasRenderer);
                    var submeshGraphic = go.AddComponent(Spine.Unity.SkeletonSubmeshGraphic);
                    submeshGraphic.maskable = this.maskable;
                    submeshGraphic.raycastTarget = false;
                    submeshGraphic.rectTransform.pivot = this.rectTransform.pivot.$clone();
                    submeshGraphic.rectTransform.anchorMin = pc.Vec2.ZERO.clone();
                    submeshGraphic.rectTransform.anchorMax = pc.Vec2.ONE.clone();
                    submeshGraphic.rectTransform.sizeDelta = pc.Vec2.ZERO.clone();
                    this.submeshGraphics.add(submeshGraphic);
                }
            },
            /*Spine.Unity.SkeletonGraphic.EnsureCanvasRendererCount end.*/

            /*Spine.Unity.SkeletonGraphic.PrepareRendererGameObjects start.*/
            PrepareRendererGameObjects: function (currentInstructions, isInRebuild) {
                var $t;
                if (isInRebuild === void 0) { isInRebuild = false; }

                var submeshCount = currentInstructions.submeshInstructions.Count;
                this.DisableUnusedCanvasRenderers(submeshCount, isInRebuild);

                var parent = this.separatorParts.Count === 0 ? this.transform : this.separatorParts.getItem(0);
                if (this.updateSeparatorPartLocation) {
                    for (var p = 0; p < this.separatorParts.Count; p = (p + 1) | 0) {
                        var separatorPart = this.separatorParts.getItem(p);
                        if (UnityEngine.Component.op_Equality(separatorPart, null)) {
                            continue;
                        }
                        separatorPart.position = this.transform.position.$clone();
                        separatorPart.rotation = this.transform.rotation.$clone();
                    }
                }
                if (this.updateSeparatorPartScale) {
                    var targetScale = this.transform.lossyScale.$clone();
                    for (var p1 = 0; p1 < this.separatorParts.Count; p1 = (p1 + 1) | 0) {
                        var separatorPart1 = this.separatorParts.getItem(p1);
                        if (UnityEngine.Component.op_Equality(separatorPart1, null)) {
                            continue;
                        }
                        var partParent = separatorPart1.parent;
                        var parentScale = UnityEngine.Component.op_Equality(partParent, null) ? new pc.Vec3( 1, 1, 1 ) : partParent.lossyScale.$clone();
                        separatorPart1.localScale = new pc.Vec3( parentScale.x === 0.0 ? 1.0 : targetScale.x / parentScale.x, parentScale.y === 0.0 ? 1.0 : targetScale.y / parentScale.y, parentScale.z === 0.0 ? 1.0 : targetScale.z / parentScale.z );
                    }
                }

                var separatorSlotGroupIndex = 0;
                var targetSiblingIndex = 0;
                for (var i = 0; i < submeshCount; i = (i + 1) | 0) {
                    var canvasRenderer = this.canvasRenderers.getItem(i);
                    if (UnityEngine.Component.op_Inequality(canvasRenderer, null)) {
                        if (i >= this.usedRenderersCount) {
                            canvasRenderer.gameObject.SetActive(true);
                        }

                        if (UnityEngine.Component.op_Inequality(canvasRenderer.transform.parent, parent.transform) && !isInRebuild) {
                            canvasRenderer.transform.SetParent(parent.transform, false);
                        }

                        canvasRenderer.transform.SetSiblingIndex(Bridge.identity(targetSiblingIndex, ((targetSiblingIndex = (targetSiblingIndex + 1) | 0))));
                    }

                    var submeshGraphic = this.submeshGraphics.getItem(i);
                    if (UnityEngine.MonoBehaviour.op_Inequality(submeshGraphic, null)) {
                        var dstTransform = submeshGraphic.rectTransform;
                        dstTransform.localPosition = pc.Vec3.ZERO.clone();
                        dstTransform.pivot = this.rectTransform.pivot.$clone();
                        dstTransform.anchorMin = pc.Vec2.ZERO.clone();
                        dstTransform.anchorMax = pc.Vec2.ONE.clone();
                        dstTransform.sizeDelta = pc.Vec2.ZERO.clone();
                    }

                    var submeshInstructionItem = ($t = currentInstructions.submeshInstructions.Items)[i].$clone();
                    if (submeshInstructionItem.forceSeparate) {
                        targetSiblingIndex = 0;
                        parent = this.separatorParts.getItem(((separatorSlotGroupIndex = (separatorSlotGroupIndex + 1) | 0)));
                    }
                }
                this.usedRenderersCount = submeshCount;
            },
            /*Spine.Unity.SkeletonGraphic.PrepareRendererGameObjects end.*/

            /*Spine.Unity.SkeletonGraphic.DisableUnusedCanvasRenderers start.*/
            DisableUnusedCanvasRenderers: function (usedCount, isInRebuild) {
                if (isInRebuild === void 0) { isInRebuild = false; }
                for (var i = usedCount; i < this.canvasRenderers.Count; i = (i + 1) | 0) {
                    this.canvasRenderers.getItem(i).Clear();
                    if (!isInRebuild) {
                        this.canvasRenderers.getItem(i).gameObject.SetActive(false);
                    }
                }
            },
            /*Spine.Unity.SkeletonGraphic.DisableUnusedCanvasRenderers end.*/

            /*Spine.Unity.SkeletonGraphic.EnsureMeshesCount start.*/
            EnsureMeshesCount: function (targetCount) {
                var oldCount = this.meshes.Count;
                this.meshes.EnsureCapacity(targetCount);
                for (var i = oldCount; i < targetCount; i = (i + 1) | 0) {
                    this.meshes.Add(Spine.Unity.SpineMesh.NewSkeletonMesh());
                }
            },
            /*Spine.Unity.SkeletonGraphic.EnsureMeshesCount end.*/

            /*Spine.Unity.SkeletonGraphic.EnsureUsedTexturesAndMaterialsCount start.*/
            EnsureUsedTexturesAndMaterialsCount: function (targetCount) {
                var oldCount = this.usedMaterials.Count;
                this.usedMaterials.EnsureCapacity(targetCount);
                this.usedTextures.EnsureCapacity(targetCount);
                for (var i = oldCount; i < targetCount; i = (i + 1) | 0) {
                    this.usedMaterials.Add(null);
                    this.usedTextures.Add(null);
                }
            },
            /*Spine.Unity.SkeletonGraphic.EnsureUsedTexturesAndMaterialsCount end.*/

            /*Spine.Unity.SkeletonGraphic.DestroyMeshes start.*/
            DestroyMeshes: function () {
                var $t;
                $t = Bridge.getEnumerator(this.meshes);
                try {
                    while ($t.moveNext()) {
                        var mesh = $t.Current;
                        UnityEngine.Object.Destroy(mesh);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                this.meshes.Clear();
            },
            /*Spine.Unity.SkeletonGraphic.DestroyMeshes end.*/

            /*Spine.Unity.SkeletonGraphic.EnsureSeparatorPartCount start.*/
            EnsureSeparatorPartCount: function () {
                var targetCount = (this.separatorSlots.Count + 1) | 0;
                if (targetCount === 1) {
                    return;
                }

                var currentCount = this.separatorParts.Count;
                for (var i = currentCount; i < targetCount; i = (i + 1) | 0) {
                    var go = new UnityEngine.GameObject.$ctor3(System.String.format("{0}[{1}]", Spine.Unity.SkeletonGraphic.SeparatorPartGameObjectName, Bridge.box(i, System.Int32)), UnityEngine.RectTransform);
                    go.transform.SetParent(this.transform, false);

                    var dstTransform = go.transform.GetComponent(UnityEngine.RectTransform);
                    dstTransform.localPosition = pc.Vec3.ZERO.clone();
                    dstTransform.pivot = this.rectTransform.pivot.$clone();
                    dstTransform.anchorMin = pc.Vec2.ZERO.clone();
                    dstTransform.anchorMax = pc.Vec2.ONE.clone();
                    dstTransform.sizeDelta = pc.Vec2.ZERO.clone();

                    this.separatorParts.add(go.transform);
                }
            },
            /*Spine.Unity.SkeletonGraphic.EnsureSeparatorPartCount end.*/

            /*Spine.Unity.SkeletonGraphic.UpdateSeparatorPartParents start.*/
            UpdateSeparatorPartParents: function () {
                var usedCount = (this.separatorSlots.Count + 1) | 0;
                if (usedCount === 1) {
                    usedCount = 0; // placed directly at the SkeletonGraphic parent
                    for (var i = 0; i < this.canvasRenderers.Count; i = (i + 1) | 0) {
                        var canvasRenderer = this.canvasRenderers.getItem(i);
                        if (System.String.contains(canvasRenderer.transform.parent.name,Spine.Unity.SkeletonGraphic.SeparatorPartGameObjectName)) {
                            canvasRenderer.transform.SetParent(this.transform, false);
                            canvasRenderer.transform.localPosition = pc.Vec3.ZERO.clone();
                        }
                    }
                }
                for (var i1 = 0; i1 < this.separatorParts.Count; i1 = (i1 + 1) | 0) {
                    var isUsed = i1 < usedCount;
                    this.separatorParts.getItem(i1).gameObject.SetActive(isUsed);
                }
            },
            /*Spine.Unity.SkeletonGraphic.UpdateSeparatorPartParents end.*/

            /*Spine.Unity.SkeletonGraphic.GetLayoutScale start.*/
            GetLayoutScale: function (mode) {
                var currentSize = this.GetCurrentRectSize();
                var referenceAspect = this.referenceSize.x / this.referenceSize.y;
                var frameAspect = currentSize.x / currentSize.y;
                if (mode === Spine.Unity.SkeletonGraphic.LayoutMode.FitInParent) {
                    mode = frameAspect > referenceAspect ? Spine.Unity.SkeletonGraphic.LayoutMode.HeightControlsWidth : Spine.Unity.SkeletonGraphic.LayoutMode.WidthControlsHeight;
                } else {
                    if (mode === Spine.Unity.SkeletonGraphic.LayoutMode.EnvelopeParent) {
                        mode = frameAspect > referenceAspect ? Spine.Unity.SkeletonGraphic.LayoutMode.WidthControlsHeight : Spine.Unity.SkeletonGraphic.LayoutMode.HeightControlsWidth;
                    }
                }

                if (mode === Spine.Unity.SkeletonGraphic.LayoutMode.WidthControlsHeight) {
                    return currentSize.x / this.referenceSize.x;
                } else if (mode === Spine.Unity.SkeletonGraphic.LayoutMode.HeightControlsWidth) {
                    return currentSize.y / this.referenceSize.y;
                }
                return 1.0;
            },
            /*Spine.Unity.SkeletonGraphic.GetLayoutScale end.*/

            /*Spine.Unity.SkeletonGraphic.GetCurrentRectSize start.*/
            GetCurrentRectSize: function () {
                return this.rectTransform.rect.size.$clone();
            },
            /*Spine.Unity.SkeletonGraphic.GetCurrentRectSize end.*/


        },
        overloads: {
            "Update(float)": "Update$1"
        }
    });
    /*Spine.Unity.SkeletonGraphic end.*/
    /**
     * @memberof Spine.Unity
     * @callback Spine.Unity.UpdateBonesDelegate
     * @param   {Spine.Unity.ISkeletonAnimation}    animated
     * @return  {void}
     */


    /*Spine.Unity.SkeletonAnimation start.*/
    Bridge.define("Spine.Unity.SkeletonAnimation", {
        inherits: [Spine.Unity.SkeletonRenderer,Spine.Unity.ISkeletonAnimation,Spine.Unity.IAnimationStateComponent],
        statics: {
            methods: {
                /*Spine.Unity.SkeletonAnimation.AddToGameObject:static start.*/
                /**
                 * Adds and prepares a SkeletonAnimation component to a GameObject at runtime.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonAnimation
                 * @memberof Spine.Unity.SkeletonAnimation
                 * @param   {UnityEngine.GameObject}           gameObject           
                 * @param   {Spine.Unity.SkeletonDataAsset}    skeletonDataAsset    
                 * @param   {boolean}                          quiet
                 * @return  {Spine.Unity.SkeletonAnimation}                         The newly instantiated SkeletonAnimation
                 */
                AddToGameObject: function (gameObject, skeletonDataAsset, quiet) {
                    if (quiet === void 0) { quiet = false; }
                    return Spine.Unity.SkeletonRenderer.AddSpineComponent(Spine.Unity.SkeletonAnimation, gameObject, skeletonDataAsset, quiet);
                },
                /*Spine.Unity.SkeletonAnimation.AddToGameObject:static end.*/

                /*Spine.Unity.SkeletonAnimation.NewSkeletonAnimationGameObject:static start.*/
                /**
                 * Instantiates a new UnityEngine.GameObject and adds a prepared SkeletonAnimation component to it.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonAnimation
                 * @memberof Spine.Unity.SkeletonAnimation
                 * @param   {Spine.Unity.SkeletonDataAsset}    skeletonDataAsset    
                 * @param   {boolean}                          quiet
                 * @return  {Spine.Unity.SkeletonAnimation}                         The newly instantiated SkeletonAnimation component.
                 */
                NewSkeletonAnimationGameObject: function (skeletonDataAsset, quiet) {
                    if (quiet === void 0) { quiet = false; }
                    return Spine.Unity.SkeletonRenderer.NewSpineGameObject(Spine.Unity.SkeletonAnimation, skeletonDataAsset, quiet);
                },
                /*Spine.Unity.SkeletonAnimation.NewSkeletonAnimationGameObject:static end.*/


            }
        },
        fields: {
            /**
             * This is the Spine.AnimationState object of this SkeletonAnimation. You can control animations through it.
             Note that this object, like .skeleton, is not guaranteed to exist in Awake. Do all accesses and caching to it in Start
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonAnimation
             * @type Spine.AnimationState
             */
            state: null,
            wasUpdatedAfterInit: false,
            updateTiming: 0,
            /**
             * If enabled, AnimationState uses unscaled game time
             (<pre><code>Time.unscaledDeltaTime</code></pre> instead of normal game time(<pre><code>Time.deltaTime</code></pre>),
             running animations independent of e.g. game pause (<pre><code>Time.timeScale</code></pre>).
             Instance SkeletonAnimation.timeScale will still be applied.
             *
             * @instance
             * @protected
             * @memberof Spine.Unity.SkeletonAnimation
             * @type boolean
             */
            unscaledTime: false,
            _animationName: null,
            /**
             * Whether or not {@link } should loop. This only applies to the initial animation specified in the inspector, or any subsequent Animations played through .AnimationName. Animations set through state.SetAnimation are unaffected.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonAnimation
             * @type boolean
             */
            loop: false,
            /**
             * The rate at which animations progress over time. 1 means 100%. 0.5 means 50%.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonAnimation
             * @default 1
             * @type number
             */
            timeScale: 0
        },
        events: {
            _OnAnimationRebuild: null,
            _BeforeApply: null,
            _UpdateLocal: null,
            _UpdateWorld: null,
            _UpdateComplete: null
        },
        props: {
            /**
             * This is the Spine.AnimationState object of this SkeletonAnimation. You can control animations through it.
             Note that this object, like .skeleton, is not guaranteed to exist in Awake. Do all accesses and caching to it in Start
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Unity.SkeletonAnimation
             * @function AnimationState
             * @type Spine.AnimationState
             */
            AnimationState: {
                get: function () {
                    this.Initialize(false);
                    return this.state;
                }
            },
            UpdateTiming: {
                get: function () {
                    return this.updateTiming;
                },
                set: function (value) {
                    this.updateTiming = value;
                }
            },
            UnscaledTime: {
                get: function () {
                    return this.unscaledTime;
                },
                set: function (value) {
                    this.unscaledTime = value;
                }
            },
            /**
             * Setting this property sets the animation of the skeleton. If invalid, it will store the animation name for the next time the skeleton is properly initialized.
             Getting this property gets the name of the currently playing animation. If invalid, it will return the last stored animation name set through this property.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonAnimation
             * @function AnimationName
             * @type string
             */
            AnimationName: {
                get: function () {
                    if (!this.valid) {
                        return this._animationName;
                    } else {
                        var entry = this.state.getCurrent(0);
                        return entry == null ? null : entry.animation.name;
                    }
                },
                set: function (value) {
                    this.Initialize(false);
                    if (Bridge.referenceEquals(this._animationName, value)) {
                        var entry = this.state.getCurrent(0);
                        if (entry != null && entry.loop === this.loop) {
                            return;
                        }
                    }
                    this._animationName = value;

                    if (System.String.isNullOrEmpty(value)) {
                        this.state.clearTrack(0);
                    } else {
                        var animationObject = this.skeletonDataAsset.GetSkeletonData(false).findAnimation(value);
                        if (animationObject != null) {
                            this.state.setAnimationWith( 0, animationObject, this.loop );
                        }
                    }
                }
            }
        },
        alias: [
            "AnimationState", "Spine$Unity$IAnimationStateComponent$AnimationState",
            "addOnAnimationRebuild", "Spine$Unity$ISkeletonAnimation$addOnAnimationRebuild",
            "removeOnAnimationRebuild", "Spine$Unity$ISkeletonAnimation$removeOnAnimationRebuild",
            "addUpdateLocal", "Spine$Unity$ISkeletonAnimation$addUpdateLocal",
            "removeUpdateLocal", "Spine$Unity$ISkeletonAnimation$removeUpdateLocal",
            "addUpdateWorld", "Spine$Unity$ISkeletonAnimation$addUpdateWorld",
            "removeUpdateWorld", "Spine$Unity$ISkeletonAnimation$removeUpdateWorld",
            "addUpdateComplete", "Spine$Unity$ISkeletonAnimation$addUpdateComplete",
            "removeUpdateComplete", "Spine$Unity$ISkeletonAnimation$removeUpdateComplete",
            "UpdateTiming", "Spine$Unity$ISkeletonAnimation$UpdateTiming",
            "UnscaledTime", "Spine$Unity$IAnimationStateComponent$UnscaledTime",
            "Skeleton", "Spine$Unity$ISkeletonAnimation$Skeleton"
        ],
        ctors: {
            init: function () {
                this.wasUpdatedAfterInit = true;
                this.updateTiming = Spine.Unity.UpdateTiming.InUpdate;
                this.timeScale = 1;
            }
        },
        methods: {
            /**
             * OnAnimationRebuild is raised after the SkeletonAnimation component is successfully initialized.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonAnimation
             * @event Spine.Unity.SkeletonAnimation#OnAnimationRebuild
             * @return  {Spine.Unity.ISkeletonAnimationDelegate}
             */
            addOnAnimationRebuild: function (value) {
                this.add_OnAnimationRebuild(value);
            },
            /**
             * OnAnimationRebuild is raised after the SkeletonAnimation component is successfully initialized.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonAnimation
             * @event Spine.Unity.SkeletonAnimation#OnAnimationRebuild
             * @return  {Spine.Unity.ISkeletonAnimationDelegate}
             */
            removeOnAnimationRebuild: function (value) {
                this.remove_OnAnimationRebuild(value);
            },
            /**
             * Occurs before the animations are applied.
             Use this callback when you want to change the skeleton state before animations are applied on top.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonAnimation
             * @event Spine.Unity.SkeletonAnimation#BeforeApply
             * @return  {Spine.Unity.UpdateBonesDelegate}
             */
            addBeforeApply: function (value) {
                this.add_BeforeApply(value);
            },
            /**
             * Occurs before the animations are applied.
             Use this callback when you want to change the skeleton state before animations are applied on top.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonAnimation
             * @event Spine.Unity.SkeletonAnimation#BeforeApply
             * @return  {Spine.Unity.UpdateBonesDelegate}
             */
            removeBeforeApply: function (value) {
                this.remove_BeforeApply(value);
            },
            /**
             * Occurs after the animations are applied and before world space values are resolved.
             Use this callback when you want to set bone local values.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonAnimation
             * @event Spine.Unity.SkeletonAnimation#UpdateLocal
             * @return  {Spine.Unity.UpdateBonesDelegate}
             */
            addUpdateLocal: function (value) {
                this.add_UpdateLocal(value);
            },
            /**
             * Occurs after the animations are applied and before world space values are resolved.
             Use this callback when you want to set bone local values.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonAnimation
             * @event Spine.Unity.SkeletonAnimation#UpdateLocal
             * @return  {Spine.Unity.UpdateBonesDelegate}
             */
            removeUpdateLocal: function (value) {
                this.remove_UpdateLocal(value);
            },
            /**
             * Occurs after the Skeleton's bone world space values are resolved (including all constraints).
             Using this callback will cause the world space values to be solved an extra time.
             Use this callback if want to use bone world space values, and also set bone local values.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonAnimation
             * @event Spine.Unity.SkeletonAnimation#UpdateWorld
             * @return  {Spine.Unity.UpdateBonesDelegate}
             */
            addUpdateWorld: function (value) {
                this.add_UpdateWorld(value);
            },
            /**
             * Occurs after the Skeleton's bone world space values are resolved (including all constraints).
             Using this callback will cause the world space values to be solved an extra time.
             Use this callback if want to use bone world space values, and also set bone local values.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonAnimation
             * @event Spine.Unity.SkeletonAnimation#UpdateWorld
             * @return  {Spine.Unity.UpdateBonesDelegate}
             */
            removeUpdateWorld: function (value) {
                this.remove_UpdateWorld(value);
            },
            /**
             * Occurs after the Skeleton's bone world space values are resolved (including all constraints).
             Use this callback if you want to use bone world space values, but don't intend to modify bone local values.
             This callback can also be used when setting world position and the bone matrix.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonAnimation
             * @event Spine.Unity.SkeletonAnimation#UpdateComplete
             * @return  {Spine.Unity.UpdateBonesDelegate}
             */
            addUpdateComplete: function (value) {
                this.add_UpdateComplete(value);
            },
            /**
             * Occurs after the Skeleton's bone world space values are resolved (including all constraints).
             Use this callback if you want to use bone world space values, but don't intend to modify bone local values.
             This callback can also be used when setting world position and the bone matrix.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonAnimation
             * @event Spine.Unity.SkeletonAnimation#UpdateComplete
             * @return  {Spine.Unity.UpdateBonesDelegate}
             */
            removeUpdateComplete: function (value) {
                this.remove_UpdateComplete(value);
            },
            /*Spine.Unity.SkeletonAnimation.ClearState start.*/
            /**
             * Clears the previously generated mesh, resets the skeleton's pose, and clears all previously active animations.
             *
             * @instance
             * @public
             * @override
             * @this Spine.Unity.SkeletonAnimation
             * @memberof Spine.Unity.SkeletonAnimation
             * @return  {void}
             */
            ClearState: function () {
                Spine.Unity.SkeletonRenderer.prototype.ClearState.call(this);
                if (this.state != null) {
                    this.state.clearTracks();
                }
            },
            /*Spine.Unity.SkeletonAnimation.ClearState end.*/

            /*Spine.Unity.SkeletonAnimation.Initialize start.*/
            /**
             * Initialize this component. Attempts to load the SkeletonData and creates the internal Spine objects and buffers.
             *
             * @instance
             * @public
             * @override
             * @this Spine.Unity.SkeletonAnimation
             * @memberof Spine.Unity.SkeletonAnimation
             * @param   {boolean}    overwrite    If set to <pre><code>true</code></pre>, force overwrite an already initialized object.
             * @param   {boolean}    quiet
             * @return  {void}
             */
            Initialize: function (overwrite, quiet) {
                if (quiet === void 0) { quiet = false; }
                if (this.valid && !overwrite) {
                    return;
                }
                this.state = null; // prevent applying leftover AnimationState
                Spine.Unity.SkeletonRenderer.prototype.Initialize.call(this, overwrite, quiet);

                if (!this.valid) {
                    return;
                }
                this.state = new Spine.AnimationState(this.skeletonDataAsset.GetAnimationStateData());
                this.wasUpdatedAfterInit = false;

                if (!System.String.isNullOrEmpty(this._animationName)) {
                    var animationObject = this.skeletonDataAsset.GetSkeletonData(false).findAnimation(this._animationName);
                    if (animationObject != null) {
                        this.state.setAnimationWith( 0, animationObject, this.loop );
                    }
                }

                if (!Bridge.staticEquals(this._OnAnimationRebuild, null)) {
                    this._OnAnimationRebuild(this);
                }
            },
            /*Spine.Unity.SkeletonAnimation.Initialize end.*/

            /*Spine.Unity.SkeletonAnimation.Update$1 start.*/
            Update$1: function () {
                if (this.updateTiming !== Spine.Unity.UpdateTiming.InUpdate) {
                    return;
                }
                this.Update(this.unscaledTime ? UnityEngine.Time.unscaledDeltaTime : UnityEngine.Time.deltaTime);
            },
            /*Spine.Unity.SkeletonAnimation.Update$1 end.*/

            /*Spine.Unity.SkeletonAnimation.Update start.*/
            /**
             * Progresses the AnimationState according to the given deltaTime, and applies it to the Skeleton. Use Time.deltaTime to update manually. Use deltaTime 0 to update without progressing the time.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonAnimation
             * @memberof Spine.Unity.SkeletonAnimation
             * @param   {number}    deltaTime
             * @return  {void}
             */
            Update: function (deltaTime) {
                if (!this.valid || this.state == null) {
                    return;
                }

                this.wasUpdatedAfterInit = true;
                if (this.updateMode < Spine.Unity.UpdateMode.OnlyAnimationStatus) {
                    return;
                }
                this.UpdateAnimationStatus(deltaTime);

                if (this.updateMode === Spine.Unity.UpdateMode.OnlyAnimationStatus) {
                    this.state.ApplyEventTimelinesOnly(this.skeleton, false);
                    return;
                }
                this.ApplyAnimation();
            },
            /*Spine.Unity.SkeletonAnimation.Update end.*/

            /*Spine.Unity.SkeletonAnimation.FixedUpdate start.*/
            FixedUpdate: function () {
                if (this.updateTiming !== Spine.Unity.UpdateTiming.InFixedUpdate) {
                    return;
                }
                this.Update(this.unscaledTime ? UnityEngine.Time.unscaledDeltaTime : UnityEngine.Time.deltaTime);
            },
            /*Spine.Unity.SkeletonAnimation.FixedUpdate end.*/

            /*Spine.Unity.SkeletonAnimation.UpdateAnimationStatus start.*/
            UpdateAnimationStatus: function (deltaTime) {
                deltaTime *= this.timeScale;
                this.state.update(deltaTime);
            },
            /*Spine.Unity.SkeletonAnimation.UpdateAnimationStatus end.*/

            /*Spine.Unity.SkeletonAnimation.ApplyAnimation start.*/
            ApplyAnimation: function () {
                if (!Bridge.staticEquals(this._BeforeApply, null)) {
                    this._BeforeApply(this);
                }

                if (this.updateMode !== Spine.Unity.UpdateMode.OnlyEventTimelines) {
                    this.state.apply(this.skeleton);
                } else {
                    this.state.ApplyEventTimelinesOnly(this.skeleton, true);
                }

                this.AfterAnimationApplied();
            },
            /*Spine.Unity.SkeletonAnimation.ApplyAnimation end.*/

            /*Spine.Unity.SkeletonAnimation.AfterAnimationApplied start.*/
            AfterAnimationApplied: function () {
                if (!Bridge.staticEquals(this._UpdateLocal, null)) {
                    this._UpdateLocal(this);
                }

                this.skeleton.updateWorldTransform();

                if (!Bridge.staticEquals(this._UpdateWorld, null)) {
                    this._UpdateWorld(this);
                    this.skeleton.updateWorldTransform();
                }

                if (!Bridge.staticEquals(this._UpdateComplete, null)) {
                    this._UpdateComplete(this);
                }
            },
            /*Spine.Unity.SkeletonAnimation.AfterAnimationApplied end.*/

            /*Spine.Unity.SkeletonAnimation.LateUpdate start.*/
            LateUpdate: function () {
                if (this.updateTiming === Spine.Unity.UpdateTiming.InLateUpdate && this.valid) {
                    this.Update(this.unscaledTime ? UnityEngine.Time.unscaledDeltaTime : UnityEngine.Time.deltaTime);
                }

                // instantiation can happen from Update() after this component, leading to a missing Update() call.
                if (!this.wasUpdatedAfterInit) {
                    this.Update(0);
                }

                Spine.Unity.SkeletonRenderer.prototype.LateUpdate.call(this);
            },
            /*Spine.Unity.SkeletonAnimation.LateUpdate end.*/

            /*Spine.Unity.SkeletonAnimation.OnBecameVisible start.*/
            OnBecameVisible: function () {
                var previousUpdateMode = this.updateMode;
                this.updateMode = Spine.Unity.UpdateMode.FullUpdate;

                // OnBecameVisible is called after LateUpdate()
                if (previousUpdateMode !== Spine.Unity.UpdateMode.FullUpdate && previousUpdateMode !== Spine.Unity.UpdateMode.EverythingExceptMesh) {
                    this.Update(0);
                }
                if (previousUpdateMode !== Spine.Unity.UpdateMode.FullUpdate) {
                    this.LateUpdate();
                }
            },
            /*Spine.Unity.SkeletonAnimation.OnBecameVisible end.*/


        },
        overloads: {
            "Update()": "Update$1"
        }
    });
    /*Spine.Unity.SkeletonAnimation end.*/

    /*Spine.Unity.SkeletonMecanim start.*/
    Bridge.define("Spine.Unity.SkeletonMecanim", {
        inherits: [Spine.Unity.SkeletonRenderer,Spine.Unity.ISkeletonAnimation],
        fields: {
            translator: null,
            wasUpdatedAfterInit: false,
            updateTiming: 0
        },
        events: {
            _OnAnimationRebuild: null,
            _BeforeApply: null,
            _UpdateLocal: null,
            _UpdateWorld: null,
            _UpdateComplete: null
        },
        props: {
            Translator: {
                get: function () {
                    return this.translator;
                }
            },
            UpdateTiming: {
                get: function () {
                    return this.updateTiming;
                },
                set: function (value) {
                    this.updateTiming = value;
                }
            }
        },
        alias: [
            "addOnAnimationRebuild", "Spine$Unity$ISkeletonAnimation$addOnAnimationRebuild",
            "removeOnAnimationRebuild", "Spine$Unity$ISkeletonAnimation$removeOnAnimationRebuild",
            "addUpdateLocal", "Spine$Unity$ISkeletonAnimation$addUpdateLocal",
            "removeUpdateLocal", "Spine$Unity$ISkeletonAnimation$removeUpdateLocal",
            "addUpdateWorld", "Spine$Unity$ISkeletonAnimation$addUpdateWorld",
            "removeUpdateWorld", "Spine$Unity$ISkeletonAnimation$removeUpdateWorld",
            "addUpdateComplete", "Spine$Unity$ISkeletonAnimation$addUpdateComplete",
            "removeUpdateComplete", "Spine$Unity$ISkeletonAnimation$removeUpdateComplete",
            "UpdateTiming", "Spine$Unity$ISkeletonAnimation$UpdateTiming",
            "Skeleton", "Spine$Unity$ISkeletonAnimation$Skeleton"
        ],
        ctors: {
            init: function () {
                this.wasUpdatedAfterInit = true;
                this.updateTiming = Spine.Unity.UpdateTiming.InUpdate;
            }
        },
        methods: {
            /**
             * OnAnimationRebuild is raised after the SkeletonAnimation component is successfully initialized.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonMecanim
             * @event Spine.Unity.SkeletonMecanim#OnAnimationRebuild
             * @return  {Spine.Unity.ISkeletonAnimationDelegate}
             */
            addOnAnimationRebuild: function (value) {
                this.add_OnAnimationRebuild(value);
            },
            /**
             * OnAnimationRebuild is raised after the SkeletonAnimation component is successfully initialized.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonMecanim
             * @event Spine.Unity.SkeletonMecanim#OnAnimationRebuild
             * @return  {Spine.Unity.ISkeletonAnimationDelegate}
             */
            removeOnAnimationRebuild: function (value) {
                this.remove_OnAnimationRebuild(value);
            },
            /**
             * Occurs before the animations are applied.
             Use this callback when you want to change the skeleton state before animations are applied on top.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonMecanim
             * @event Spine.Unity.SkeletonMecanim#BeforeApply
             * @return  {Spine.Unity.UpdateBonesDelegate}
             */
            addBeforeApply: function (value) {
                this.add_BeforeApply(value);
            },
            /**
             * Occurs before the animations are applied.
             Use this callback when you want to change the skeleton state before animations are applied on top.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonMecanim
             * @event Spine.Unity.SkeletonMecanim#BeforeApply
             * @return  {Spine.Unity.UpdateBonesDelegate}
             */
            removeBeforeApply: function (value) {
                this.remove_BeforeApply(value);
            },
            /**
             * Occurs after the animations are applied and before world space values are resolved.
             Use this callback when you want to set bone local values.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonMecanim
             * @event Spine.Unity.SkeletonMecanim#UpdateLocal
             * @return  {Spine.Unity.UpdateBonesDelegate}
             */
            addUpdateLocal: function (value) {
                this.add_UpdateLocal(value);
            },
            /**
             * Occurs after the animations are applied and before world space values are resolved.
             Use this callback when you want to set bone local values.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonMecanim
             * @event Spine.Unity.SkeletonMecanim#UpdateLocal
             * @return  {Spine.Unity.UpdateBonesDelegate}
             */
            removeUpdateLocal: function (value) {
                this.remove_UpdateLocal(value);
            },
            /**
             * Occurs after the Skeleton's bone world space values are resolved (including all constraints).
             Using this callback will cause the world space values to be solved an extra time.
             Use this callback if want to use bone world space values, and also set bone local values.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonMecanim
             * @event Spine.Unity.SkeletonMecanim#UpdateWorld
             * @return  {Spine.Unity.UpdateBonesDelegate}
             */
            addUpdateWorld: function (value) {
                this.add_UpdateWorld(value);
            },
            /**
             * Occurs after the Skeleton's bone world space values are resolved (including all constraints).
             Using this callback will cause the world space values to be solved an extra time.
             Use this callback if want to use bone world space values, and also set bone local values.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonMecanim
             * @event Spine.Unity.SkeletonMecanim#UpdateWorld
             * @return  {Spine.Unity.UpdateBonesDelegate}
             */
            removeUpdateWorld: function (value) {
                this.remove_UpdateWorld(value);
            },
            /**
             * Occurs after the Skeleton's bone world space values are resolved (including all constraints).
             Use this callback if you want to use bone world space values, but don't intend to modify bone local values.
             This callback can also be used when setting world position and the bone matrix.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonMecanim
             * @event Spine.Unity.SkeletonMecanim#UpdateComplete
             * @return  {Spine.Unity.UpdateBonesDelegate}
             */
            addUpdateComplete: function (value) {
                this.add_UpdateComplete(value);
            },
            /**
             * Occurs after the Skeleton's bone world space values are resolved (including all constraints).
             Use this callback if you want to use bone world space values, but don't intend to modify bone local values.
             This callback can also be used when setting world position and the bone matrix.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonMecanim
             * @event Spine.Unity.SkeletonMecanim#UpdateComplete
             * @return  {Spine.Unity.UpdateBonesDelegate}
             */
            removeUpdateComplete: function (value) {
                this.remove_UpdateComplete(value);
            },
            /*Spine.Unity.SkeletonMecanim.Initialize start.*/
            Initialize: function (overwrite, quiet) {
                if (quiet === void 0) { quiet = false; }
                if (this.valid && !overwrite) {
                    return;
                }
                Spine.Unity.SkeletonRenderer.prototype.Initialize.call(this, overwrite, quiet);

                if (!this.valid) {
                    return;
                }

                if (this.translator == null) {
                    this.translator = new Spine.Unity.SkeletonMecanim.MecanimTranslator();
                }
                this.translator.Initialize(this.GetComponent(UnityEngine.Animator), this.skeletonDataAsset);
                this.wasUpdatedAfterInit = false;

                if (!Bridge.staticEquals(this._OnAnimationRebuild, null)) {
                    this._OnAnimationRebuild(this);
                }
            },
            /*Spine.Unity.SkeletonMecanim.Initialize end.*/

            /*Spine.Unity.SkeletonMecanim.Update start.*/
            Update: function () {
                if (!this.valid || this.updateTiming !== Spine.Unity.UpdateTiming.InUpdate) {
                    return;
                }
                this.UpdateAnimation();
            },
            /*Spine.Unity.SkeletonMecanim.Update end.*/

            /*Spine.Unity.SkeletonMecanim.Update$1 start.*/
            /**
             * Manual animation update. Required when <pre><code>updateTiming</code></pre> is set to <pre><code>ManualUpdate</code></pre>.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonMecanim
             * @memberof Spine.Unity.SkeletonMecanim
             * @param   {number}    deltaTime    Ignored parameter.
             * @return  {void}
             */
            Update$1: function (deltaTime) {
                if (!this.valid) {
                    return;
                }
                this.UpdateAnimation();
            },
            /*Spine.Unity.SkeletonMecanim.Update$1 end.*/

            /*Spine.Unity.SkeletonMecanim.FixedUpdate start.*/
            FixedUpdate: function () {
                if (!this.valid || this.updateTiming !== Spine.Unity.UpdateTiming.InFixedUpdate) {
                    return;
                }
                this.UpdateAnimation();
            },
            /*Spine.Unity.SkeletonMecanim.FixedUpdate end.*/

            /*Spine.Unity.SkeletonMecanim.UpdateAnimation start.*/
            UpdateAnimation: function () {
                this.wasUpdatedAfterInit = true;

                // animation status is kept by Mecanim Animator component
                if (this.updateMode <= Spine.Unity.UpdateMode.OnlyAnimationStatus) {
                    return;
                }

                this.ApplyAnimation();
            },
            /*Spine.Unity.SkeletonMecanim.UpdateAnimation end.*/

            /*Spine.Unity.SkeletonMecanim.ApplyAnimation start.*/
            ApplyAnimation: function () {
                if (!Bridge.staticEquals(this._BeforeApply, null)) {
                    this._BeforeApply(this);
                }

                this.translator.Apply(this.skeleton);

                // UpdateWorldTransform and Bone Callbacks
                {
                    if (!Bridge.staticEquals(this._UpdateLocal, null)) {
                        this._UpdateLocal(this);
                    }

                    this.skeleton.updateWorldTransform();

                    if (!Bridge.staticEquals(this._UpdateWorld, null)) {
                        this._UpdateWorld(this);
                        this.skeleton.updateWorldTransform();
                    }

                    if (!Bridge.staticEquals(this._UpdateComplete, null)) {
                        this._UpdateComplete(this);
                    }
                }
            },
            /*Spine.Unity.SkeletonMecanim.ApplyAnimation end.*/

            /*Spine.Unity.SkeletonMecanim.LateUpdate start.*/
            LateUpdate: function () {
                if (this.updateTiming === Spine.Unity.UpdateTiming.InLateUpdate && this.valid && this.translator != null && UnityEngine.Component.op_Inequality(this.translator.Animator, null)) {
                    this.UpdateAnimation();
                }
                // instantiation can happen from Update() after this component, leading to a missing Update() call.
                if (!this.wasUpdatedAfterInit) {
                    this.Update();
                }
                Spine.Unity.SkeletonRenderer.prototype.LateUpdate.call(this);
            },
            /*Spine.Unity.SkeletonMecanim.LateUpdate end.*/

            /*Spine.Unity.SkeletonMecanim.OnBecameVisible start.*/
            OnBecameVisible: function () {
                var previousUpdateMode = this.updateMode;
                this.updateMode = Spine.Unity.UpdateMode.FullUpdate;

                // OnBecameVisible is called after LateUpdate()
                if (previousUpdateMode !== Spine.Unity.UpdateMode.FullUpdate && previousUpdateMode !== Spine.Unity.UpdateMode.EverythingExceptMesh) {
                    this.Update();
                }
                if (previousUpdateMode !== Spine.Unity.UpdateMode.FullUpdate) {
                    this.LateUpdate();
                }
            },
            /*Spine.Unity.SkeletonMecanim.OnBecameVisible end.*/


        },
        overloads: {
            "Update(float)": "Update$1"
        }
    });
    /*Spine.Unity.SkeletonMecanim end.*/

    if ( MODULE_reflection ) {
    var $m = Bridge.setMetadata,
        $n = ["System","UnityEngine","UnityEngine.UI","Spine","Spine.Unity","System.Collections.Generic","UnityEngine.U2D","UnityEngine.Rendering","Spine.Unity.AttachmentTools"];

    /*enemy start.*/
    $m("enemy", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"attack","t":8,"sn":"attack","rt":$n[0].Void},{"a":2,"n":"gm","t":4,"rt":gamemanager,"sn":"gm"}]}; }, $n);
    /*enemy end.*/

    /*gamemanager start.*/
    $m("gamemanager", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"Awake","t":8,"sn":"Awake","rt":$n[0].Void},{"a":1,"n":"Check","t":8,"sn":"Check","rt":$n[0].Void},{"a":2,"n":"EndProc","t":8,"sn":"EndProc","rt":$n[0].Void},{"a":2,"n":"enemyAttack","t":8,"sn":"enemyAttack","rt":$n[0].Void},{"a":2,"n":"onClickTest","t":8,"pi":[{"n":"t","pt":test,"ps":0}],"sn":"onClickTest","rt":$n[0].Void,"p":[test]},{"a":2,"n":"playerAttack","t":8,"sn":"playerAttack","rt":$n[0].Void},{"a":2,"n":"CanClick","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_CanClick","t":8,"rt":$n[0].Boolean,"fg":"CanClick","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"CanClick"},{"a":2,"n":"ani","t":4,"rt":$n[1].Animator,"sn":"ani"},{"a":2,"n":"attackSpeed","t":4,"rt":$n[0].Single,"sn":"attackSpeed","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"attackSpeedMul","t":4,"rt":$n[0].Single,"sn":"attackSpeedMul","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"curHp","t":4,"rt":$n[0].Single,"sn":"curHp","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"curPlayerPower","t":4,"rt":$n[0].Int64,"sn":"curPlayerPower"},{"a":1,"n":"curdmg","t":4,"rt":$n[0].Int64,"sn":"curdmg"},{"a":2,"n":"dmg","t":4,"rt":$n[2].Text,"sn":"dmg"},{"a":2,"n":"endCover","t":4,"rt":$n[1].GameObject,"sn":"endCover"},{"a":2,"n":"enemyPower","t":4,"rt":$n[0].Single,"sn":"enemyPower","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"hpMax","t":4,"rt":$n[0].Single,"sn":"hpMax","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"isCheck","t":4,"rt":$n[0].Boolean,"sn":"isCheck","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"playerHpbar","t":4,"rt":$n[2].Slider,"sn":"playerHpbar"},{"a":2,"n":"playerPower","t":4,"rt":$n[0].Int32,"sn":"playerPower","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"playerPowerMul","t":4,"rt":$n[0].Int32,"sn":"playerPowerMul","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"sprites","t":4,"rt":System.Array.type(UnityEngine.Sprite),"sn":"sprites"},{"a":2,"n":"t","t":4,"rt":System.Array.type(test),"sn":"t"},{"a":2,"n":"tests","t":4,"rt":System.Array.type(test),"sn":"tests"}]}; }, $n);
    /*gamemanager end.*/

    /*player start.*/
    $m("player", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"hit","t":8,"sn":"hit","rt":$n[0].Void},{"a":2,"n":"gm","t":4,"rt":gamemanager,"sn":"gm"}]}; }, $n);
    /*player end.*/

    /*screen start.*/
    $m("screen", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"Awake","t":8,"sn":"Awake","rt":$n[0].Void},{"a":2,"n":"canvas","t":4,"rt":$n[2].CanvasScaler,"sn":"canvas"}]}; }, $n);
    /*screen end.*/

    /*test start.*/
    $m("test", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"Awake","t":8,"sn":"Awake","rt":$n[0].Void},{"a":1,"n":"Update","t":8,"sn":"Update","rt":$n[0].Void},{"a":2,"n":"onClick","t":8,"sn":"onClick","rt":$n[0].Void},{"a":2,"n":"setClear","t":8,"sn":"setClear","rt":$n[0].Void},{"a":2,"n":"setDisable","t":8,"sn":"setDisable","rt":$n[0].Void},{"a":2,"n":"bg","t":4,"rt":$n[1].GameObject,"sn":"bg"},{"a":1,"n":"changeToScale","t":4,"rt":$n[1].Vector3,"sn":"changeToScale"},{"a":2,"n":"clearScale","t":4,"rt":$n[0].Single,"sn":"clearScale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"clickScale","t":4,"rt":$n[0].Single,"sn":"clickScale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"curScaleChangeTime","t":4,"rt":$n[0].Single,"sn":"curScaleChangeTime","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"gm","t":4,"rt":gamemanager,"sn":"gm"},{"a":2,"n":"img","t":4,"rt":$n[2].Image,"sn":"img"},{"a":1,"n":"isChangeScale","t":4,"rt":$n[0].Boolean,"sn":"isChangeScale","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"isClear","t":4,"rt":$n[0].Boolean,"sn":"isClear","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"prevScale","t":4,"rt":$n[1].Vector3,"sn":"prevScale"},{"a":2,"n":"scaleChangeTime","t":4,"rt":$n[0].Single,"sn":"scaleChangeTime","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"sprite","t":4,"rt":$n[1].Sprite,"sn":"sprite"},{"a":1,"n":"t","t":4,"rt":$n[1].Transform,"sn":"t"},{"a":2,"n":"x","t":4,"rt":$n[0].Single,"sn":"x","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*test end.*/

    /*IAmAnEmptyScriptJustToMakeCodelessProjectsCompileProperty start.*/
    $m("IAmAnEmptyScriptJustToMakeCodelessProjectsCompileProperty", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*IAmAnEmptyScriptJustToMakeCodelessProjectsCompileProperty end.*/

    /*Spine.BoneMatrix start.*/
    $m("Spine.BoneMatrix", function () { return {"att":1048841,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":".ctor","t":1,"p":[$n[3].Bone],"pi":[{"n":"bone","pt":$n[3].Bone,"ps":0}],"sn":"$ctor1"},{"a":2,"n":".ctor","t":1,"p":[spine.BoneData],"pi":[{"n":"boneData","pt":spine.BoneData,"ps":0}],"sn":"$ctor2"},{"a":2,"n":"CalculateSetupWorld","is":true,"t":8,"pi":[{"n":"boneData","pt":spine.BoneData,"ps":0}],"sn":"CalculateSetupWorld","rt":$n[3].BoneMatrix,"p":[spine.BoneData]},{"a":1,"n":"GetInheritedInternal","is":true,"t":8,"pi":[{"n":"boneData","pt":spine.BoneData,"ps":0},{"n":"parentMatrix","pt":$n[3].BoneMatrix,"ps":1}],"sn":"GetInheritedInternal","rt":$n[3].BoneMatrix,"p":[spine.BoneData,$n[3].BoneMatrix]},{"a":2,"n":"TransformMatrix","t":8,"pi":[{"n":"local","pt":$n[3].BoneMatrix,"ps":0}],"sn":"TransformMatrix","rt":$n[3].BoneMatrix,"p":[$n[3].BoneMatrix]},{"a":2,"n":"a","t":4,"rt":$n[0].Single,"sn":"a","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"b","t":4,"rt":$n[0].Single,"sn":"b","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"c","t":4,"rt":$n[0].Single,"sn":"c","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"d","t":4,"rt":$n[0].Single,"sn":"d","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"x","t":4,"rt":$n[0].Single,"sn":"x","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"y","t":4,"rt":$n[0].Single,"sn":"y","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*Spine.BoneMatrix end.*/

    /*Spine.SpineSkeletonExtensions start.*/
    $m("Spine.SpineSkeletonExtensions", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"InheritsRotation","is":true,"t":8,"pi":[{"n":"mode","pt":spine.TransformMode,"ps":0}],"sn":"InheritsRotation","rt":$n[0].Boolean,"p":[spine.TransformMode],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"InheritsScale","is":true,"t":8,"pi":[{"n":"mode","pt":spine.TransformMode,"ps":0}],"sn":"InheritsScale","rt":$n[0].Boolean,"p":[spine.TransformMode],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"IsWeighted","is":true,"t":8,"pi":[{"n":"va","pt":spine.VertexAttachment,"ps":0}],"sn":"IsWeighted","rt":$n[0].Boolean,"p":[spine.VertexAttachment],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.SpineSkeletonExtensions end.*/

    /*Spine.Unity.AnimationReferenceAsset start.*/
    $m("Spine.Unity.AnimationReferenceAsset", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Spine/Animation Reference Asset", order: 100
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Clear","t":8,"sn":"Clear","rt":$n[0].Void},{"a":2,"n":"Initialize","t":8,"sn":"Initialize","rt":$n[0].Void},{"a":2,"n":"op_Implicit","is":true,"t":8,"pi":[{"n":"asset","pt":$n[4].AnimationReferenceAsset,"ps":0}],"sn":"op_Implicit","rt":$n[3].Animation,"p":[$n[4].AnimationReferenceAsset]},{"a":2,"n":"Animation","t":16,"rt":$n[3].Animation,"g":{"a":2,"n":"get_Animation","t":8,"rt":$n[3].Animation,"fg":"Animation"},"fn":"Animation"},{"a":2,"n":"SkeletonDataAsset","t":16,"rt":$n[4].SkeletonDataAsset,"g":{"a":2,"n":"get_SkeletonDataAsset","t":8,"rt":$n[4].SkeletonDataAsset,"fg":"SkeletonDataAsset"},"fn":"SkeletonDataAsset"},{"a":1,"n":"QuietSkeletonData","is":true,"t":4,"rt":$n[0].Boolean,"sn":"QuietSkeletonData","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"animation","t":4,"rt":$n[3].Animation,"sn":"animation"},{"at":[new UnityEngine.SerializeFieldAttribute(),new Spine.Unity.SpineAnimation("", "", true, false)],"a":3,"n":"animationName","t":4,"rt":$n[0].String,"sn":"animationName"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"skeletonDataAsset","t":4,"rt":$n[4].SkeletonDataAsset,"sn":"skeletonDataAsset"}]}; }, $n);
    /*Spine.Unity.AnimationReferenceAsset end.*/

    /*Spine.Unity.AtlasAssetBase start.*/
    $m("Spine.Unity.AtlasAssetBase", function () { return {"nested":[$n[4].AtlasAssetBase.LoadingMode],"att":1048705,"a":2,"m":[{"a":3,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"v":true,"a":2,"n":"BeginCustomTextureLoading","t":8,"sn":"BeginCustomTextureLoading","rt":$n[0].Void},{"ab":true,"a":2,"n":"Clear","t":8,"sn":"Clear","rt":$n[0].Void},{"v":true,"a":2,"n":"EndCustomTextureLoading","t":8,"sn":"EndCustomTextureLoading","rt":$n[0].Void},{"ab":true,"a":2,"n":"GetAtlas","t":8,"pi":[{"n":"onlyMetaData","dv":false,"o":true,"pt":$n[0].Boolean,"ps":0}],"sn":"GetAtlas","rt":$n[3].Atlas,"p":[$n[0].Boolean]},{"v":true,"a":2,"n":"RequireTextureLoaded","t":8,"pi":[{"n":"placeholderTexture","pt":$n[1].Texture,"ps":0},{"n":"replacementTexture","ref":true,"pt":$n[1].Texture,"ps":1},{"n":"onTextureLoaded","pt":Function,"ps":2}],"sn":"RequireTextureLoaded","rt":$n[0].Void,"p":[$n[1].Texture,$n[1].Texture,Function]},{"v":true,"a":2,"n":"RequireTexturesLoaded","t":8,"pi":[{"n":"material","pt":$n[1].Material,"ps":0},{"n":"overrideMaterial","ref":true,"pt":$n[1].Material,"ps":1}],"sn":"RequireTexturesLoaded","rt":$n[0].Void,"p":[$n[1].Material,$n[1].Material]},{"ab":true,"a":2,"n":"IsLoaded","t":16,"rt":$n[0].Boolean,"g":{"ab":true,"a":2,"n":"get_IsLoaded","t":8,"rt":$n[0].Boolean,"fg":"IsLoaded","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"IsLoaded"},{"ab":true,"a":2,"n":"MaterialCount","t":16,"rt":$n[0].Int32,"g":{"ab":true,"a":2,"n":"get_MaterialCount","t":8,"rt":$n[0].Int32,"fg":"MaterialCount","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"MaterialCount"},{"ab":true,"a":2,"n":"Materials","t":16,"rt":$n[5].IEnumerable$1(UnityEngine.Material),"g":{"ab":true,"a":2,"n":"get_Materials","t":8,"rt":$n[5].IEnumerable$1(UnityEngine.Material),"fg":"Materials"},"fn":"Materials"},{"a":2,"n":"OnDemandTextureLoader","t":16,"rt":$n[4].OnDemandTextureLoader,"g":{"a":2,"n":"get_OnDemandTextureLoader","t":8,"rt":$n[4].OnDemandTextureLoader,"fg":"OnDemandTextureLoader"},"s":{"a":2,"n":"set_OnDemandTextureLoader","t":8,"p":[$n[4].OnDemandTextureLoader],"rt":$n[0].Void,"fs":"OnDemandTextureLoader"},"fn":"OnDemandTextureLoader"},{"ab":true,"a":2,"n":"PrimaryMaterial","t":16,"rt":$n[1].Material,"g":{"ab":true,"a":2,"n":"get_PrimaryMaterial","t":8,"rt":$n[1].Material,"fg":"PrimaryMaterial"},"fn":"PrimaryMaterial"},{"v":true,"a":2,"n":"TextureLoadingMode","t":16,"rt":$n[4].AtlasAssetBase.LoadingMode,"g":{"v":true,"a":2,"n":"get_TextureLoadingMode","t":8,"rt":$n[4].AtlasAssetBase.LoadingMode,"fg":"TextureLoadingMode","box":function ($v) { return Bridge.box($v, Spine.Unity.AtlasAssetBase.LoadingMode, System.Enum.toStringFn(Spine.Unity.AtlasAssetBase.LoadingMode));}},"s":{"v":true,"a":2,"n":"set_TextureLoadingMode","t":8,"p":[$n[4].AtlasAssetBase.LoadingMode],"rt":$n[0].Void,"fs":"TextureLoadingMode"},"fn":"TextureLoadingMode"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"onDemandTextureLoader","t":4,"rt":$n[4].OnDemandTextureLoader,"sn":"onDemandTextureLoader"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"textureLoadingMode","t":4,"rt":$n[4].AtlasAssetBase.LoadingMode,"sn":"textureLoadingMode","box":function ($v) { return Bridge.box($v, Spine.Unity.AtlasAssetBase.LoadingMode, System.Enum.toStringFn(Spine.Unity.AtlasAssetBase.LoadingMode));}},{"a":1,"backing":true,"n":"<IsLoaded>k__BackingField","t":4,"rt":$n[0].Boolean,"sn":"IsLoaded","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"backing":true,"n":"<MaterialCount>k__BackingField","t":4,"rt":$n[0].Int32,"sn":"MaterialCount","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"backing":true,"n":"<Materials>k__BackingField","t":4,"rt":$n[5].IEnumerable$1(UnityEngine.Material),"sn":"Materials"},{"a":1,"backing":true,"n":"<PrimaryMaterial>k__BackingField","t":4,"rt":$n[1].Material,"sn":"PrimaryMaterial"}]}; }, $n);
    /*Spine.Unity.AtlasAssetBase end.*/

    /*Spine.Unity.AtlasAssetBase+LoadingMode start.*/
    $m("Spine.Unity.AtlasAssetBase.LoadingMode", function () { return {"td":$n[4].AtlasAssetBase,"att":258,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Normal","is":true,"t":4,"rt":$n[4].AtlasAssetBase.LoadingMode,"sn":"Normal","box":function ($v) { return Bridge.box($v, Spine.Unity.AtlasAssetBase.LoadingMode, System.Enum.toStringFn(Spine.Unity.AtlasAssetBase.LoadingMode));}},{"a":2,"n":"OnDemand","is":true,"t":4,"rt":$n[4].AtlasAssetBase.LoadingMode,"sn":"OnDemand","box":function ($v) { return Bridge.box($v, Spine.Unity.AtlasAssetBase.LoadingMode, System.Enum.toStringFn(Spine.Unity.AtlasAssetBase.LoadingMode));}}]}; }, $n);
    /*Spine.Unity.AtlasAssetBase+LoadingMode end.*/

    /*Spine.Unity.BlendModeMaterials start.*/
    $m("Spine.Unity.BlendModeMaterials", function () { return {"nested":[$n[4].BlendModeMaterials.ReplacementMaterial],"att":1056769,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"ApplyMaterials","t":8,"pi":[{"n":"skeletonData","pt":$n[3].SkeletonData,"ps":0}],"sn":"ApplyMaterials","rt":$n[0].Void,"p":[$n[3].SkeletonData]},{"a":2,"n":"BlendModeForMaterial","t":8,"pi":[{"n":"material","pt":$n[1].Material,"ps":0}],"sn":"BlendModeForMaterial","rt":spine.BlendMode,"p":[$n[1].Material],"box":function ($v) { return Bridge.box($v, spine.BlendMode, System.Enum.toStringFn(spine.BlendMode));}},{"a":3,"n":"CloneAtlasRegionWithMaterial","t":8,"pi":[{"n":"originalRegion","pt":$n[3].AtlasRegion,"ps":0},{"n":"replacementMaterials","pt":$n[5].List$1(Spine.Unity.BlendModeMaterials.ReplacementMaterial),"ps":1}],"sn":"CloneAtlasRegionWithMaterial","rt":$n[3].AtlasRegion,"p":[$n[3].AtlasRegion,$n[5].List$1(Spine.Unity.BlendModeMaterials.ReplacementMaterial)]},{"a":2,"n":"RequiresBlendModeMaterials","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_RequiresBlendModeMaterials","t":8,"rt":$n[0].Boolean,"fg":"RequiresBlendModeMaterials","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_RequiresBlendModeMaterials","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"RequiresBlendModeMaterials"},"fn":"RequiresBlendModeMaterials"},{"a":2,"n":"additiveMaterials","t":4,"rt":$n[5].List$1(Spine.Unity.BlendModeMaterials.ReplacementMaterial),"sn":"additiveMaterials"},{"a":2,"n":"applyAdditiveMaterial","t":4,"rt":$n[0].Boolean,"sn":"applyAdditiveMaterial","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"multiplyMaterials","t":4,"rt":$n[5].List$1(Spine.Unity.BlendModeMaterials.ReplacementMaterial),"sn":"multiplyMaterials"},{"at":[new UnityEngine.SerializeFieldAttribute(),new UnityEngine.HideInInspector()],"a":3,"n":"requiresBlendModeMaterials","t":4,"rt":$n[0].Boolean,"sn":"requiresBlendModeMaterials","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"screenMaterials","t":4,"rt":$n[5].List$1(Spine.Unity.BlendModeMaterials.ReplacementMaterial),"sn":"screenMaterials"}]}; }, $n);
    /*Spine.Unity.BlendModeMaterials end.*/

    /*Spine.Unity.BlendModeMaterials+ReplacementMaterial start.*/
    $m("Spine.Unity.BlendModeMaterials.ReplacementMaterial", function () { return {"td":$n[4].BlendModeMaterials,"att":1056770,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"material","t":4,"rt":$n[1].Material,"sn":"material"},{"a":2,"n":"pageName","t":4,"rt":$n[0].String,"sn":"pageName"}]}; }, $n);
    /*Spine.Unity.BlendModeMaterials+ReplacementMaterial end.*/

    /*Spine.Unity.EventDataReferenceAsset start.*/
    $m("Spine.Unity.EventDataReferenceAsset", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Spine/EventData Reference Asset", order: 100
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Initialize","t":8,"sn":"Initialize","rt":$n[0].Void},{"a":2,"n":"op_Implicit","is":true,"t":8,"pi":[{"n":"asset","pt":$n[4].EventDataReferenceAsset,"ps":0}],"sn":"op_Implicit","rt":spine.EventData,"p":[$n[4].EventDataReferenceAsset]},{"a":2,"n":"EventData","t":16,"rt":spine.EventData,"g":{"a":2,"n":"get_EventData","t":8,"rt":spine.EventData,"fg":"EventData"},"fn":"EventData"},{"a":1,"n":"QuietSkeletonData","is":true,"t":4,"rt":$n[0].Boolean,"sn":"QuietSkeletonData","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"eventData","t":4,"rt":spine.EventData,"sn":"eventData"},{"at":[new UnityEngine.SerializeFieldAttribute(),new Spine.Unity.SpineEvent("", "skeletonDataAsset", true, false, false)],"a":3,"n":"eventName","t":4,"rt":$n[0].String,"sn":"eventName"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"skeletonDataAsset","t":4,"rt":$n[4].SkeletonDataAsset,"sn":"skeletonDataAsset"}]}; }, $n);
    /*Spine.Unity.EventDataReferenceAsset end.*/

    /*Spine.Unity.OnDemandTextureLoader start.*/
    $m("Spine.Unity.OnDemandTextureLoader", function () { return {"nested":[Function],"att":1048705,"a":2,"m":[{"a":3,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"ab":true,"a":2,"n":"AssignPlaceholderTextures","t":8,"pi":[{"n":"modifiedMaterials","out":true,"pt":$n[5].IEnumerable$1(UnityEngine.Material),"ps":0}],"sn":"AssignPlaceholderTextures","rt":$n[0].Boolean,"p":[$n[5].IEnumerable$1(UnityEngine.Material)],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"ab":true,"a":2,"n":"AssignTargetTextures","t":8,"pi":[{"n":"modifiedMaterials","out":true,"pt":$n[5].IEnumerable$1(UnityEngine.Material),"ps":0}],"sn":"AssignTargetTextures","rt":$n[0].Boolean,"p":[$n[5].IEnumerable$1(UnityEngine.Material)],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"ab":true,"a":2,"n":"BeginCustomTextureLoading","t":8,"sn":"BeginCustomTextureLoading","rt":$n[0].Void},{"ab":true,"a":2,"n":"Clear","t":8,"pi":[{"n":"clearAtlasAsset","dv":false,"o":true,"pt":$n[0].Boolean,"ps":0}],"sn":"Clear","rt":$n[0].Void,"p":[$n[0].Boolean]},{"ab":true,"a":2,"n":"EndCustomTextureLoading","t":8,"sn":"EndCustomTextureLoading","rt":$n[0].Void},{"ab":true,"a":2,"n":"GetPlaceholderTextureName","t":8,"pi":[{"n":"originalTextureName","pt":$n[0].String,"ps":0}],"sn":"GetPlaceholderTextureName","rt":$n[0].String,"p":[$n[0].String]},{"v":true,"a":2,"n":"HasNullMainTexturesAssigned","t":8,"pi":[{"n":"nullTextureMaterials","out":true,"pt":$n[5].List$1(UnityEngine.Material),"ps":0}],"sn":"HasNullMainTexturesAssigned","rt":$n[0].Boolean,"p":[$n[5].List$1(UnityEngine.Material)],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"ab":true,"a":2,"n":"HasPlaceholderAssigned","t":8,"pi":[{"n":"material","pt":$n[1].Material,"ps":0}],"sn":"HasPlaceholderAssigned","rt":$n[0].Boolean,"p":[$n[1].Material],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"ab":true,"a":2,"n":"HasPlaceholderTexturesAssigned","t":8,"pi":[{"n":"placeholderMaterials","out":true,"pt":$n[5].List$1(UnityEngine.Material),"ps":0}],"sn":"HasPlaceholderTexturesAssigned","rt":$n[0].Boolean,"p":[$n[5].List$1(UnityEngine.Material)],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":3,"n":"OnTextureLoaded","t":8,"pi":[{"n":"material","pt":$n[1].Material,"ps":0},{"n":"textureIndex","pt":$n[0].Int32,"ps":1}],"sn":"OnTextureLoaded","rt":$n[0].Void,"p":[$n[1].Material,$n[0].Int32]},{"a":3,"n":"OnTextureRequested","t":8,"pi":[{"n":"material","pt":$n[1].Material,"ps":0},{"n":"textureIndex","pt":$n[0].Int32,"ps":1}],"sn":"OnTextureRequested","rt":$n[0].Void,"p":[$n[1].Material,$n[0].Int32]},{"a":3,"n":"OnTextureUnloaded","t":8,"pi":[{"n":"material","pt":$n[1].Material,"ps":0},{"n":"textureIndex","pt":$n[0].Int32,"ps":1}],"sn":"OnTextureUnloaded","rt":$n[0].Void,"p":[$n[1].Material,$n[0].Int32]},{"ab":true,"a":2,"n":"RequestLoadMaterialTextures","t":8,"pi":[{"n":"material","pt":$n[1].Material,"ps":0},{"n":"overrideMaterial","ref":true,"pt":$n[1].Material,"ps":1}],"sn":"RequestLoadMaterialTextures","rt":$n[0].Void,"p":[$n[1].Material,$n[1].Material]},{"ab":true,"a":2,"n":"RequestLoadTexture","t":8,"pi":[{"n":"placeholderTexture","pt":$n[1].Texture,"ps":0},{"n":"replacementTexture","ref":true,"pt":$n[1].Texture,"ps":1},{"n":"onTextureLoaded","dv":null,"o":true,"pt":Function,"ps":2}],"sn":"RequestLoadTexture","rt":$n[0].Void,"p":[$n[1].Texture,$n[1].Texture,Function]},{"a":2,"n":"atlasAsset","t":4,"rt":$n[4].AtlasAssetBase,"sn":"atlasAsset"},{"a":2,"n":"TextureLoaded","t":2,"ad":{"a":2,"n":"add_TextureLoaded","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addTextureLoaded","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_TextureLoaded","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeTextureLoaded","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"TextureRequested","t":2,"ad":{"a":2,"n":"add_TextureRequested","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addTextureRequested","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_TextureRequested","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeTextureRequested","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"TextureUnloaded","t":2,"ad":{"a":2,"n":"add_TextureUnloaded","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addTextureUnloaded","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_TextureUnloaded","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeTextureUnloaded","rt":$n[0].Void,"p":[Function]}},{"a":3,"n":"onTextureLoaded","t":2,"ad":{"a":3,"n":"add_onTextureLoaded","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addonTextureLoaded","rt":$n[0].Void,"p":[Function]},"r":{"a":3,"n":"remove_onTextureLoaded","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeonTextureLoaded","rt":$n[0].Void,"p":[Function]}},{"a":3,"n":"onTextureRequested","t":2,"ad":{"a":3,"n":"add_onTextureRequested","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addonTextureRequested","rt":$n[0].Void,"p":[Function]},"r":{"a":3,"n":"remove_onTextureRequested","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeonTextureRequested","rt":$n[0].Void,"p":[Function]}},{"a":3,"n":"onTextureUnloaded","t":2,"ad":{"a":3,"n":"add_onTextureUnloaded","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addonTextureUnloaded","rt":$n[0].Void,"p":[Function]},"r":{"a":3,"n":"remove_onTextureUnloaded","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeonTextureUnloaded","rt":$n[0].Void,"p":[Function]}}]}; }, $n);
    /*Spine.Unity.OnDemandTextureLoader end.*/

    /*Spine.Unity.RegionlessAttachmentLoader start.*/
    $m("Spine.Unity.RegionlessAttachmentLoader", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"NewBoundingBoxAttachment","t":8,"pi":[{"n":"skin","pt":$n[3].Skin,"ps":0},{"n":"name","pt":$n[0].String,"ps":1}],"sn":"NewBoundingBoxAttachment","rt":spine.BoundingBoxAttachment,"p":[$n[3].Skin,$n[0].String]},{"a":2,"n":"NewClippingAttachment","t":8,"pi":[{"n":"skin","pt":$n[3].Skin,"ps":0},{"n":"name","pt":$n[0].String,"ps":1}],"sn":"NewClippingAttachment","rt":spine.ClippingAttachment,"p":[$n[3].Skin,$n[0].String]},{"a":2,"n":"NewMeshAttachment","t":8,"pi":[{"n":"skin","pt":$n[3].Skin,"ps":0},{"n":"name","pt":$n[0].String,"ps":1},{"n":"path","pt":$n[0].String,"ps":2},{"n":"sequence","pt":spine.Sequence,"ps":3}],"sn":"NewMeshAttachment","rt":$n[3].MeshAttachment,"p":[$n[3].Skin,$n[0].String,$n[0].String,spine.Sequence]},{"a":2,"n":"NewPathAttachment","t":8,"pi":[{"n":"skin","pt":$n[3].Skin,"ps":0},{"n":"name","pt":$n[0].String,"ps":1}],"sn":"NewPathAttachment","rt":spine.PathAttachment,"p":[$n[3].Skin,$n[0].String]},{"a":2,"n":"NewPointAttachment","t":8,"pi":[{"n":"skin","pt":$n[3].Skin,"ps":0},{"n":"name","pt":$n[0].String,"ps":1}],"sn":"NewPointAttachment","rt":$n[3].PointAttachment,"p":[$n[3].Skin,$n[0].String]},{"a":2,"n":"NewRegionAttachment","t":8,"pi":[{"n":"skin","pt":$n[3].Skin,"ps":0},{"n":"name","pt":$n[0].String,"ps":1},{"n":"path","pt":$n[0].String,"ps":2},{"n":"sequence","pt":spine.Sequence,"ps":3}],"sn":"NewRegionAttachment","rt":$n[3].RegionAttachment,"p":[$n[3].Skin,$n[0].String,$n[0].String,spine.Sequence]},{"a":1,"n":"EmptyRegion","is":true,"t":16,"rt":$n[3].AtlasRegion,"g":{"a":1,"n":"get_EmptyRegion","t":8,"rt":$n[3].AtlasRegion,"fg":"EmptyRegion","is":true},"fn":"EmptyRegion"},{"a":1,"n":"emptyRegion","is":true,"t":4,"rt":$n[3].AtlasRegion,"sn":"emptyRegion"}]}; }, $n);
    /*Spine.Unity.RegionlessAttachmentLoader end.*/

    /*Spine.Unity.SkeletonDataAsset start.*/
    $m("Spine.Unity.SkeletonDataAsset", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        fileName: "New SkeletonDataAsset", menuName: "Spine/SkeletonData Asset"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Clear","t":8,"sn":"Clear","rt":$n[0].Void},{"a":2,"n":"CreateRuntimeInstance","is":true,"t":8,"pi":[{"n":"skeletonDataFile","pt":$n[1].TextAsset,"ps":0},{"n":"atlasAsset","pt":$n[4].AtlasAssetBase,"ps":1},{"n":"initialize","pt":$n[0].Boolean,"ps":2},{"n":"scale","dv":0.01,"o":true,"pt":$n[0].Single,"ps":3}],"sn":"CreateRuntimeInstance","rt":$n[4].SkeletonDataAsset,"p":[$n[1].TextAsset,$n[4].AtlasAssetBase,$n[0].Boolean,$n[0].Single]},{"a":2,"n":"CreateRuntimeInstance","is":true,"t":8,"pi":[{"n":"skeletonDataFile","pt":$n[1].TextAsset,"ps":0},{"n":"atlasAssets","pt":System.Array.type(Spine.Unity.AtlasAssetBase),"ps":1},{"n":"initialize","pt":$n[0].Boolean,"ps":2},{"n":"scale","dv":0.01,"o":true,"pt":$n[0].Single,"ps":3}],"sn":"CreateRuntimeInstance$1","rt":$n[4].SkeletonDataAsset,"p":[$n[1].TextAsset,System.Array.type(Spine.Unity.AtlasAssetBase),$n[0].Boolean,$n[0].Single]},{"a":2,"n":"FillStateData","t":8,"pi":[{"n":"quiet","dv":false,"o":true,"pt":$n[0].Boolean,"ps":0}],"sn":"FillStateData","rt":$n[0].Void,"p":[$n[0].Boolean]},{"a":2,"n":"GetAnimationStateData","t":8,"sn":"GetAnimationStateData","rt":spine.AnimationStateData},{"a":4,"n":"GetAtlasArray","t":8,"sn":"GetAtlasArray","rt":System.Array.type(Spine.Atlas)},{"a":2,"n":"GetSkeletonData","t":8,"pi":[{"n":"quiet","pt":$n[0].Boolean,"ps":0}],"sn":"GetSkeletonData","rt":$n[3].SkeletonData,"p":[$n[0].Boolean]},{"a":4,"n":"InitializeWithData","t":8,"pi":[{"n":"sd","pt":$n[3].SkeletonData,"ps":0}],"sn":"InitializeWithData","rt":$n[0].Void,"p":[$n[3].SkeletonData]},{"a":4,"n":"ReadSkeletonData","is":true,"t":8,"pi":[{"n":"bytes","pt":$n[0].Array.type(System.Byte),"ps":0},{"n":"attachmentLoader","pt":$n[3].AttachmentLoader,"ps":1},{"n":"scale","pt":$n[0].Single,"ps":2}],"sn":"ReadSkeletonData","rt":$n[3].SkeletonData,"p":[$n[0].Array.type(System.Byte),$n[3].AttachmentLoader,$n[0].Single]},{"a":4,"n":"ReadSkeletonData","is":true,"t":8,"pi":[{"n":"text","pt":$n[0].String,"ps":0},{"n":"attachmentLoader","pt":$n[3].AttachmentLoader,"ps":1},{"n":"scale","pt":$n[0].Single,"ps":2}],"sn":"ReadSkeletonData$1","rt":$n[3].SkeletonData,"p":[$n[0].String,$n[3].AttachmentLoader,$n[0].Single]},{"a":1,"n":"Reset","t":8,"sn":"Reset","rt":$n[0].Void},{"a":2,"n":"IsLoaded","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_IsLoaded","t":8,"rt":$n[0].Boolean,"fg":"IsLoaded","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"IsLoaded"},{"a":2,"n":"atlasAssets","t":4,"rt":System.Array.type(Spine.Unity.AtlasAssetBase),"sn":"atlasAssets"},{"a":2,"n":"blendModeMaterials","t":4,"rt":$n[4].BlendModeMaterials,"sn":"blendModeMaterials"},{"a":2,"n":"controller","t":4,"rt":$n[1].RuntimeAnimatorController,"sn":"controller"},{"a":2,"n":"defaultMix","t":4,"rt":$n[0].Single,"sn":"defaultMix","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"duration","t":4,"rt":$n[0].Array.type(System.Single),"sn":"duration"},{"at":[new Spine.Unity.SpineAnimation("", "", false, false)],"a":2,"n":"fromAnimation","t":4,"rt":$n[0].Array.type(System.String),"sn":"fromAnimation"},{"a":2,"n":"isUpgradingBlendModeMaterials","t":4,"rt":$n[0].Boolean,"sn":"isUpgradingBlendModeMaterials","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"scale","t":4,"rt":$n[0].Single,"sn":"scale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"skeletonData","t":4,"rt":$n[3].SkeletonData,"sn":"skeletonData"},{"at":[new UnityEngine.TooltipAttribute("Use SkeletonDataModifierAssets to apply changes to the SkeletonData after being loaded, such as apply blend mode Materials to Attachments under slots with special blend modes.")],"a":2,"n":"skeletonDataModifiers","t":4,"rt":$n[5].List$1(Spine.Unity.SkeletonDataModifierAsset),"sn":"skeletonDataModifiers"},{"a":2,"n":"skeletonJSON","t":4,"rt":$n[1].TextAsset,"sn":"skeletonJSON"},{"a":1,"n":"stateData","t":4,"rt":spine.AnimationStateData,"sn":"stateData"},{"at":[new Spine.Unity.SpineAnimation("", "", false, false)],"a":2,"n":"toAnimation","t":4,"rt":$n[0].Array.type(System.String),"sn":"toAnimation"}]}; }, $n);
    /*Spine.Unity.SkeletonDataAsset end.*/

    /*Spine.Unity.SkeletonDataCompatibility start.*/
    $m("Spine.Unity.SkeletonDataCompatibility", function () { return {"nested":[$n[4].SkeletonDataCompatibility.SourceType,$n[4].SkeletonDataCompatibility.VersionInfo,$n[4].SkeletonDataCompatibility.CompatibilityProblemInfo],"att":1048961,"a":2,"s":true}; }, $n);
    /*Spine.Unity.SkeletonDataCompatibility end.*/

    /*Spine.Unity.SkeletonDataCompatibility+SourceType start.*/
    $m("Spine.Unity.SkeletonDataCompatibility.SourceType", function () { return {"td":$n[4].SkeletonDataCompatibility,"att":258,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Binary","is":true,"t":4,"rt":$n[4].SkeletonDataCompatibility.SourceType,"sn":"Binary","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonDataCompatibility.SourceType, System.Enum.toStringFn(Spine.Unity.SkeletonDataCompatibility.SourceType));}},{"a":2,"n":"Json","is":true,"t":4,"rt":$n[4].SkeletonDataCompatibility.SourceType,"sn":"Json","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonDataCompatibility.SourceType, System.Enum.toStringFn(Spine.Unity.SkeletonDataCompatibility.SourceType));}}]}; }, $n);
    /*Spine.Unity.SkeletonDataCompatibility+SourceType end.*/

    /*Spine.Unity.SkeletonDataCompatibility+VersionInfo start.*/
    $m("Spine.Unity.SkeletonDataCompatibility.VersionInfo", function () { return {"td":$n[4].SkeletonDataCompatibility,"att":1056770,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"rawVersion","t":4,"rt":$n[0].String,"sn":"rawVersion"},{"a":2,"n":"sourceType","t":4,"rt":$n[4].SkeletonDataCompatibility.SourceType,"sn":"sourceType","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonDataCompatibility.SourceType, System.Enum.toStringFn(Spine.Unity.SkeletonDataCompatibility.SourceType));}},{"a":2,"n":"version","t":4,"rt":$n[0].Array.type(System.Int32),"sn":"version"}]}; }, $n);
    /*Spine.Unity.SkeletonDataCompatibility+VersionInfo end.*/

    /*Spine.Unity.SkeletonDataCompatibility+CompatibilityProblemInfo start.*/
    $m("Spine.Unity.SkeletonDataCompatibility.CompatibilityProblemInfo", function () { return {"td":$n[4].SkeletonDataCompatibility,"att":1056770,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"DescriptionString","t":8,"sn":"DescriptionString","rt":$n[0].String},{"a":2,"n":"actualVersion","t":4,"rt":$n[4].SkeletonDataCompatibility.VersionInfo,"sn":"actualVersion"},{"a":2,"n":"compatibleVersions","t":4,"rt":$n[0].Array.type(System.Array.type(System.Int32)),"sn":"compatibleVersions"},{"a":2,"n":"explicitProblemDescription","t":4,"rt":$n[0].String,"sn":"explicitProblemDescription"}]}; }, $n);
    /*Spine.Unity.SkeletonDataCompatibility+CompatibilityProblemInfo end.*/

    /*Spine.Unity.SkeletonDataModifierAsset start.*/
    $m("Spine.Unity.SkeletonDataModifierAsset", function () { return {"att":1048705,"a":2,"m":[{"a":3,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"ab":true,"a":2,"n":"Apply","t":8,"pi":[{"n":"skeletonData","pt":$n[3].SkeletonData,"ps":0}],"sn":"Apply","rt":$n[0].Void,"p":[$n[3].SkeletonData]}]}; }, $n);
    /*Spine.Unity.SkeletonDataModifierAsset end.*/

    /*Spine.Unity.SpineAtlasAsset start.*/
    $m("Spine.Unity.SpineAtlasAsset", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        fileName: "New Spine Atlas Asset", menuName: "Spine/Spine Atlas Asset"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"ov":true,"a":2,"n":"Clear","t":8,"sn":"Clear","rt":$n[0].Void},{"a":2,"n":"CreateRuntimeInstance","is":true,"t":8,"pi":[{"n":"atlasText","pt":$n[1].TextAsset,"ps":0},{"n":"materials","pt":System.Array.type(UnityEngine.Material),"ps":1},{"n":"initialize","pt":$n[0].Boolean,"ps":2},{"n":"newCustomTextureLoader","dv":null,"o":true,"pt":Function,"ps":3}],"sn":"CreateRuntimeInstance","rt":$n[4].SpineAtlasAsset,"p":[$n[1].TextAsset,System.Array.type(UnityEngine.Material),$n[0].Boolean,Function]},{"a":2,"n":"CreateRuntimeInstance","is":true,"t":8,"pi":[{"n":"atlasText","pt":$n[1].TextAsset,"ps":0},{"n":"textures","pt":System.Array.type(UnityEngine.Texture2D),"ps":1},{"n":"materialPropertySource","pt":$n[1].Material,"ps":2},{"n":"initialize","pt":$n[0].Boolean,"ps":3},{"n":"newCustomTextureLoader","dv":null,"o":true,"pt":Function,"ps":4}],"sn":"CreateRuntimeInstance$1","rt":$n[4].SpineAtlasAsset,"p":[$n[1].TextAsset,System.Array.type(UnityEngine.Texture2D),$n[1].Material,$n[0].Boolean,Function]},{"a":2,"n":"CreateRuntimeInstance","is":true,"t":8,"pi":[{"n":"atlasText","pt":$n[1].TextAsset,"ps":0},{"n":"textures","pt":System.Array.type(UnityEngine.Texture2D),"ps":1},{"n":"shader","pt":$n[1].Shader,"ps":2},{"n":"initialize","pt":$n[0].Boolean,"ps":3},{"n":"newCustomTextureLoader","dv":null,"o":true,"pt":Function,"ps":4}],"sn":"CreateRuntimeInstance$2","rt":$n[4].SpineAtlasAsset,"p":[$n[1].TextAsset,System.Array.type(UnityEngine.Texture2D),$n[1].Shader,$n[0].Boolean,Function]},{"a":2,"n":"GenerateMesh","t":8,"pi":[{"n":"name","pt":$n[0].String,"ps":0},{"n":"mesh","pt":$n[1].Mesh,"ps":1},{"n":"material","out":true,"pt":$n[1].Material,"ps":2},{"n":"scale","dv":0.01,"o":true,"pt":$n[0].Single,"ps":3}],"sn":"GenerateMesh","rt":$n[1].Mesh,"p":[$n[0].String,$n[1].Mesh,$n[1].Material,$n[0].Single]},{"ov":true,"a":2,"n":"GetAtlas","t":8,"pi":[{"n":"onlyMetaData","dv":false,"o":true,"pt":$n[0].Boolean,"ps":0}],"sn":"GetAtlas","rt":$n[3].Atlas,"p":[$n[0].Boolean]},{"a":1,"n":"Reset","t":8,"sn":"Reset","rt":$n[0].Void},{"ov":true,"a":2,"n":"IsLoaded","t":16,"rt":$n[0].Boolean,"g":{"ov":true,"a":2,"n":"get_IsLoaded","t":8,"rt":$n[0].Boolean,"fg":"IsLoaded","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"IsLoaded"},{"ov":true,"a":2,"n":"MaterialCount","t":16,"rt":$n[0].Int32,"g":{"ov":true,"a":2,"n":"get_MaterialCount","t":8,"rt":$n[0].Int32,"fg":"MaterialCount","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"MaterialCount"},{"ov":true,"a":2,"n":"Materials","t":16,"rt":$n[5].IEnumerable$1(UnityEngine.Material),"g":{"ov":true,"a":2,"n":"get_Materials","t":8,"rt":$n[5].IEnumerable$1(UnityEngine.Material),"fg":"Materials"},"fn":"Materials"},{"ov":true,"a":2,"n":"PrimaryMaterial","t":16,"rt":$n[1].Material,"g":{"ov":true,"a":2,"n":"get_PrimaryMaterial","t":8,"rt":$n[1].Material,"fg":"PrimaryMaterial"},"fn":"PrimaryMaterial"},{"a":3,"n":"atlas","t":4,"rt":$n[3].Atlas,"sn":"atlas"},{"a":2,"n":"atlasFile","t":4,"rt":$n[1].TextAsset,"sn":"atlasFile"},{"a":2,"n":"customTextureLoader","t":4,"rt":$n[3].TextureLoader,"sn":"customTextureLoader"},{"a":2,"n":"materials","t":4,"rt":System.Array.type(UnityEngine.Material),"sn":"materials"}]}; }, $n);
    /*Spine.Unity.SpineAtlasAsset end.*/

    /*Spine.Unity.NoOpTextureLoader start.*/
    $m("Spine.Unity.NoOpTextureLoader", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Load","t":8,"pi":[{"n":"page","pt":$n[3].AtlasPage,"ps":0},{"n":"path","pt":$n[0].String,"ps":1}],"sn":"Load","rt":$n[0].Void,"p":[$n[3].AtlasPage,$n[0].String]},{"a":2,"n":"Unload","t":8,"pi":[{"n":"texture","pt":$n[0].Object,"ps":0}],"sn":"Unload","rt":$n[0].Void,"p":[$n[0].Object]}]}; }, $n);
    /*Spine.Unity.NoOpTextureLoader end.*/

    /*Spine.Unity.MaterialsTextureLoader start.*/
    $m("Spine.Unity.MaterialsTextureLoader", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[4].SpineAtlasAsset],"pi":[{"n":"atlasAsset","pt":$n[4].SpineAtlasAsset,"ps":0}],"sn":"ctor"},{"a":2,"n":"Load","t":8,"pi":[{"n":"page","pt":$n[3].AtlasPage,"ps":0},{"n":"path","pt":$n[0].String,"ps":1}],"sn":"Load","rt":$n[0].Void,"p":[$n[3].AtlasPage,$n[0].String]},{"a":2,"n":"Unload","t":8,"pi":[{"n":"texture","pt":$n[0].Object,"ps":0}],"sn":"Unload","rt":$n[0].Void,"p":[$n[0].Object]},{"a":1,"n":"atlasAsset","t":4,"rt":$n[4].SpineAtlasAsset,"sn":"atlasAsset"}]}; }, $n);
    /*Spine.Unity.MaterialsTextureLoader end.*/

    /*Spine.Unity.SpineSpriteAtlasAsset start.*/
    $m("Spine.Unity.SpineSpriteAtlasAsset", function () { return {"nested":[$n[4].SpineSpriteAtlasAsset.SavedRegionInfo],"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        fileName: "New Spine SpriteAtlas Asset", menuName: "Spine/Spine SpriteAtlas Asset"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"AccessPackedSprites","is":true,"t":8,"pi":[{"n":"spriteAtlas","pt":$n[6].SpriteAtlas,"ps":0}],"sn":"AccessPackedSprites","rt":System.Array.type(UnityEngine.Sprite),"p":[$n[6].SpriteAtlas]},{"a":2,"n":"AccessPackedTexture","is":true,"t":8,"pi":[{"n":"sprites","pt":System.Array.type(UnityEngine.Sprite),"ps":0}],"sn":"AccessPackedTexture","rt":$n[1].Texture2D,"p":[System.Array.type(UnityEngine.Sprite)]},{"a":3,"n":"AssignRegionsFromSavedRegions","t":8,"pi":[{"n":"sprites","pt":System.Array.type(UnityEngine.Sprite),"ps":0},{"n":"usedAtlas","pt":$n[3].Atlas,"ps":1}],"sn":"AssignRegionsFromSavedRegions","rt":$n[0].Void,"p":[System.Array.type(UnityEngine.Sprite),$n[3].Atlas]},{"ov":true,"a":2,"n":"Clear","t":8,"sn":"Clear","rt":$n[0].Void},{"a":2,"n":"CreateRuntimeInstance","is":true,"t":8,"pi":[{"n":"spriteAtlasFile","pt":$n[6].SpriteAtlas,"ps":0},{"n":"materials","pt":System.Array.type(UnityEngine.Material),"ps":1},{"n":"initialize","pt":$n[0].Boolean,"ps":2}],"sn":"CreateRuntimeInstance","rt":$n[4].SpineSpriteAtlasAsset,"p":[$n[6].SpriteAtlas,System.Array.type(UnityEngine.Material),$n[0].Boolean]},{"ov":true,"a":2,"n":"GetAtlas","t":8,"pi":[{"n":"onlyMetaData","dv":false,"o":true,"pt":$n[0].Boolean,"ps":0}],"sn":"GetAtlas","rt":$n[3].Atlas,"p":[$n[0].Boolean]},{"a":1,"n":"LoadAtlas","t":8,"pi":[{"n":"spriteAtlas","pt":$n[6].SpriteAtlas,"ps":0}],"sn":"LoadAtlas","rt":$n[3].Atlas,"p":[$n[6].SpriteAtlas]},{"a":1,"n":"Reset","t":8,"sn":"Reset","rt":$n[0].Void},{"ov":true,"a":2,"n":"IsLoaded","t":16,"rt":$n[0].Boolean,"g":{"ov":true,"a":2,"n":"get_IsLoaded","t":8,"rt":$n[0].Boolean,"fg":"IsLoaded","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"IsLoaded"},{"ov":true,"a":2,"n":"MaterialCount","t":16,"rt":$n[0].Int32,"g":{"ov":true,"a":2,"n":"get_MaterialCount","t":8,"rt":$n[0].Int32,"fg":"MaterialCount","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"MaterialCount"},{"ov":true,"a":2,"n":"Materials","t":16,"rt":$n[5].IEnumerable$1(UnityEngine.Material),"g":{"ov":true,"a":2,"n":"get_Materials","t":8,"rt":$n[5].IEnumerable$1(UnityEngine.Material),"fg":"Materials"},"fn":"Materials"},{"ov":true,"a":2,"n":"PrimaryMaterial","t":16,"rt":$n[1].Material,"g":{"ov":true,"a":2,"n":"get_PrimaryMaterial","t":8,"rt":$n[1].Material,"fg":"PrimaryMaterial"},"fn":"PrimaryMaterial"},{"a":3,"n":"atlas","t":4,"rt":$n[3].Atlas,"sn":"atlas"},{"a":2,"n":"materials","t":4,"rt":System.Array.type(UnityEngine.Material),"sn":"materials"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"savedRegions","t":4,"rt":System.Array.type(Spine.Unity.SpineSpriteAtlasAsset.SavedRegionInfo),"sn":"savedRegions"},{"a":2,"n":"spriteAtlasFile","t":4,"rt":$n[6].SpriteAtlas,"sn":"spriteAtlasFile"},{"a":2,"n":"updateRegionsInPlayMode","t":4,"rt":$n[0].Boolean,"sn":"updateRegionsInPlayMode","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.SpineSpriteAtlasAsset end.*/

    /*Spine.Unity.SpineSpriteAtlasAsset+SavedRegionInfo start.*/
    $m("Spine.Unity.SpineSpriteAtlasAsset.SavedRegionInfo", function () { return {"td":$n[4].SpineSpriteAtlasAsset,"att":1056772,"a":3,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"height","t":4,"rt":$n[0].Single,"sn":"height","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"packingRotation","t":4,"rt":$n[1].SpritePackingRotation,"sn":"packingRotation","box":function ($v) { return Bridge.box($v, UnityEngine.SpritePackingRotation, System.Enum.toStringFn(UnityEngine.SpritePackingRotation));}},{"a":2,"n":"width","t":4,"rt":$n[0].Single,"sn":"width","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"x","t":4,"rt":$n[0].Single,"sn":"x","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"y","t":4,"rt":$n[0].Single,"sn":"y","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*Spine.Unity.SpineSpriteAtlasAsset+SavedRegionInfo end.*/

    /*Spine.Unity.BoneFollower start.*/
    $m("Spine.Unity.BoneFollower", function () { return {"nested":[$n[4].BoneFollower.AxisOrientation],"att":1048577,"a":2,"at":[new UnityEngine.ExecuteAlwaysAttribute(),new UnityEngine.AddComponentMenu.ctor("Spine/BoneFollower"),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#BoneFollower")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Awake","t":8,"sn":"Awake","rt":$n[0].Void},{"a":2,"n":"HandleRebuildRenderer","t":8,"pi":[{"n":"skeletonRenderer","pt":$n[4].SkeletonRenderer,"ps":0}],"sn":"HandleRebuildRenderer","rt":$n[0].Void,"p":[$n[4].SkeletonRenderer]},{"a":2,"n":"Initialize","t":8,"sn":"Initialize","rt":$n[0].Void},{"a":2,"n":"LateUpdate","t":8,"sn":"LateUpdate","rt":$n[0].Void},{"a":1,"n":"OnDestroy","t":8,"sn":"OnDestroy","rt":$n[0].Void},{"a":2,"n":"SetBone","t":8,"pi":[{"n":"name","pt":$n[0].String,"ps":0}],"sn":"SetBone","rt":$n[0].Boolean,"p":[$n[0].String],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"SkeletonRenderer","t":16,"rt":$n[4].SkeletonRenderer,"g":{"a":2,"n":"get_SkeletonRenderer","t":8,"rt":$n[4].SkeletonRenderer,"fg":"SkeletonRenderer"},"s":{"a":2,"n":"set_SkeletonRenderer","t":8,"p":[$n[4].SkeletonRenderer],"rt":$n[0].Void,"fs":"SkeletonRenderer"},"fn":"SkeletonRenderer"},{"a":2,"n":"bone","t":4,"rt":$n[3].Bone,"sn":"bone"},{"at":[new Spine.Unity.SpineBone("", "skeletonRenderer", true, false)],"a":2,"n":"boneName","t":4,"rt":$n[0].String,"sn":"boneName"},{"a":2,"n":"followBoneRotation","t":4,"rt":$n[0].Boolean,"sn":"followBoneRotation","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.TooltipAttribute("Follows the target bone's local scale."),new UnityEngine.Serialization.FormerlySerializedAsAttribute("followScale")],"a":2,"n":"followLocalScale","t":4,"rt":$n[0].Boolean,"sn":"followLocalScale","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.TooltipAttribute("Includes the parent bone's lossy world scale. BoneFollower cannot inherit rotated/skewed scale because of UnityEngine.Transform property limitations.")],"a":2,"n":"followParentWorldScale","t":4,"rt":$n[0].Boolean,"sn":"followParentWorldScale","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.TooltipAttribute("Follows the skeleton's flip state by controlling this Transform's local scale.")],"a":2,"n":"followSkeletonFlip","t":4,"rt":$n[0].Boolean,"sn":"followSkeletonFlip","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"followXYPosition","t":4,"rt":$n[0].Boolean,"sn":"followXYPosition","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"followZPosition","t":4,"rt":$n[0].Boolean,"sn":"followZPosition","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.Serialization.FormerlySerializedAsAttribute("resetOnAwake")],"a":2,"n":"initializeOnAwake","t":4,"rt":$n[0].Boolean,"sn":"initializeOnAwake","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.TooltipAttribute("Applies when 'Follow Skeleton Flip' is disabled but 'Follow Bone Rotation' is enabled. When flipping the skeleton by scaling its Transform, this follower's rotation is adjusted instead of its scale to follow the bone orientation. When one of the axes is flipped,  only one axis can be followed, either the X or the Y axis, which is selected here.")],"a":2,"n":"maintainedAxisOrientation","t":4,"rt":$n[4].BoneFollower.AxisOrientation,"sn":"maintainedAxisOrientation","box":function ($v) { return Bridge.box($v, Spine.Unity.BoneFollower.AxisOrientation, System.Enum.toStringFn(Spine.Unity.BoneFollower.AxisOrientation));}},{"a":2,"n":"skeletonRenderer","t":4,"rt":$n[4].SkeletonRenderer,"sn":"skeletonRenderer"},{"a":1,"n":"skeletonTransform","t":4,"rt":$n[1].Transform,"sn":"skeletonTransform"},{"a":1,"n":"skeletonTransformIsParent","t":4,"rt":$n[0].Boolean,"sn":"skeletonTransformIsParent","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"valid","t":4,"rt":$n[0].Boolean,"sn":"valid","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.BoneFollower end.*/

    /*Spine.Unity.BoneFollower+AxisOrientation start.*/
    $m("Spine.Unity.BoneFollower.AxisOrientation", function () { return {"td":$n[4].BoneFollower,"att":258,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"XAxis","is":true,"t":4,"rt":$n[4].BoneFollower.AxisOrientation,"sn":"XAxis","box":function ($v) { return Bridge.box($v, Spine.Unity.BoneFollower.AxisOrientation, System.Enum.toStringFn(Spine.Unity.BoneFollower.AxisOrientation));}},{"a":2,"n":"YAxis","is":true,"t":4,"rt":$n[4].BoneFollower.AxisOrientation,"sn":"YAxis","box":function ($v) { return Bridge.box($v, Spine.Unity.BoneFollower.AxisOrientation, System.Enum.toStringFn(Spine.Unity.BoneFollower.AxisOrientation));}}]}; }, $n);
    /*Spine.Unity.BoneFollower+AxisOrientation end.*/

    /*Spine.Unity.BoneFollowerGraphic start.*/
    $m("Spine.Unity.BoneFollowerGraphic", function () { return {"att":1048577,"a":2,"at":[new UnityEngine.ExecuteAlwaysAttribute(),new UnityEngine.RequireComponent.ctor(UnityEngine.RectTransform),new UnityEngine.DisallowMultipleComponent(),new UnityEngine.AddComponentMenu.ctor("Spine/UI/BoneFollowerGraphic"),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#BoneFollowerGraphic")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Awake","t":8,"sn":"Awake","rt":$n[0].Void},{"a":2,"n":"Initialize","t":8,"sn":"Initialize","rt":$n[0].Void},{"a":2,"n":"LateUpdate","t":8,"sn":"LateUpdate","rt":$n[0].Void},{"a":2,"n":"SetBone","t":8,"pi":[{"n":"name","pt":$n[0].String,"ps":0}],"sn":"SetBone","rt":$n[0].Boolean,"p":[$n[0].String],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"SkeletonGraphic","t":16,"rt":$n[4].SkeletonGraphic,"g":{"a":2,"n":"get_SkeletonGraphic","t":8,"rt":$n[4].SkeletonGraphic,"fg":"SkeletonGraphic"},"s":{"a":2,"n":"set_SkeletonGraphic","t":8,"p":[$n[4].SkeletonGraphic],"rt":$n[0].Void,"fs":"SkeletonGraphic"},"fn":"SkeletonGraphic"},{"a":2,"n":"bone","t":4,"rt":$n[3].Bone,"sn":"bone"},{"at":[new Spine.Unity.SpineBone("", "skeletonGraphic", true, false)],"a":2,"n":"boneName","t":4,"rt":$n[0].String,"sn":"boneName"},{"a":2,"n":"followBoneRotation","t":4,"rt":$n[0].Boolean,"sn":"followBoneRotation","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.TooltipAttribute("Follows the target bone's local scale.")],"a":2,"n":"followLocalScale","t":4,"rt":$n[0].Boolean,"sn":"followLocalScale","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.TooltipAttribute("Includes the parent bone's lossy world scale. BoneFollower cannot inherit rotated/skewed scale because of UnityEngine.Transform property limitations.")],"a":2,"n":"followParentWorldScale","t":4,"rt":$n[0].Boolean,"sn":"followParentWorldScale","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.TooltipAttribute("Follows the skeleton's flip state by controlling this Transform's local scale.")],"a":2,"n":"followSkeletonFlip","t":4,"rt":$n[0].Boolean,"sn":"followSkeletonFlip","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"followXYPosition","t":4,"rt":$n[0].Boolean,"sn":"followXYPosition","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"followZPosition","t":4,"rt":$n[0].Boolean,"sn":"followZPosition","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"initializeOnAwake","t":4,"rt":$n[0].Boolean,"sn":"initializeOnAwake","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.TooltipAttribute("Applies when 'Follow Skeleton Flip' is disabled but 'Follow Bone Rotation' is enabled. When flipping the skeleton by scaling its Transform, this follower's rotation is adjusted instead of its scale to follow the bone orientation. When one of the axes is flipped,  only one axis can be followed, either the X or the Y axis, which is selected here.")],"a":2,"n":"maintainedAxisOrientation","t":4,"rt":$n[4].BoneFollower.AxisOrientation,"sn":"maintainedAxisOrientation","box":function ($v) { return Bridge.box($v, Spine.Unity.BoneFollower.AxisOrientation, System.Enum.toStringFn(Spine.Unity.BoneFollower.AxisOrientation));}},{"a":2,"n":"skeletonGraphic","t":4,"rt":$n[4].SkeletonGraphic,"sn":"skeletonGraphic"},{"a":1,"n":"skeletonTransform","t":4,"rt":$n[1].Transform,"sn":"skeletonTransform"},{"a":1,"n":"skeletonTransformIsParent","t":4,"rt":$n[0].Boolean,"sn":"skeletonTransformIsParent","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"valid","t":4,"rt":$n[0].Boolean,"sn":"valid","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.BoneFollowerGraphic end.*/

    /*Spine.Unity.BoundingBoxFollower start.*/
    $m("Spine.Unity.BoundingBoxFollower", function () { return {"att":1048577,"a":2,"at":[new UnityEngine.ExecuteAlwaysAttribute(),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#BoundingBoxFollower")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"AddCollidersForSkin","t":8,"pi":[{"n":"skin","pt":$n[3].Skin,"ps":0},{"n":"slotIndex","pt":$n[0].Int32,"ps":1},{"n":"previousColliders","pt":System.Array.type(UnityEngine.PolygonCollider2D),"ps":2},{"n":"collidersCount","ref":true,"pt":$n[0].Int32,"ps":3}],"sn":"AddCollidersForSkin","rt":$n[0].Void,"p":[$n[3].Skin,$n[0].Int32,System.Array.type(UnityEngine.PolygonCollider2D),$n[0].Int32]},{"a":2,"n":"ClearState","t":8,"sn":"ClearState","rt":$n[0].Void},{"a":1,"n":"DisposeExcessCollidersAfter","t":8,"pi":[{"n":"requiredCount","pt":$n[0].Int32,"ps":0}],"sn":"DisposeExcessCollidersAfter","rt":$n[0].Void,"p":[$n[0].Int32]},{"a":1,"n":"HandleRebuild","t":8,"pi":[{"n":"sr","pt":$n[4].SkeletonRenderer,"ps":0}],"sn":"HandleRebuild","rt":$n[0].Void,"p":[$n[4].SkeletonRenderer]},{"a":2,"n":"Initialize","t":8,"pi":[{"n":"overwrite","dv":false,"o":true,"pt":$n[0].Boolean,"ps":0}],"sn":"Initialize","rt":$n[0].Void,"p":[$n[0].Boolean]},{"a":1,"n":"LateUpdate","t":8,"sn":"LateUpdate","rt":$n[0].Void},{"a":1,"n":"MatchAttachment","t":8,"pi":[{"n":"attachment","pt":spine.Attachment,"ps":0}],"sn":"MatchAttachment","rt":$n[0].Void,"p":[spine.Attachment]},{"a":1,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"a":1,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[0].Void},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":2,"n":"CurrentAttachment","t":16,"rt":spine.BoundingBoxAttachment,"g":{"a":2,"n":"get_CurrentAttachment","t":8,"rt":spine.BoundingBoxAttachment,"fg":"CurrentAttachment"},"fn":"CurrentAttachment"},{"a":2,"n":"CurrentAttachmentName","t":16,"rt":$n[0].String,"g":{"a":2,"n":"get_CurrentAttachmentName","t":8,"rt":$n[0].String,"fg":"CurrentAttachmentName"},"fn":"CurrentAttachmentName"},{"a":2,"n":"CurrentCollider","t":16,"rt":$n[1].PolygonCollider2D,"g":{"a":2,"n":"get_CurrentCollider","t":8,"rt":$n[1].PolygonCollider2D,"fg":"CurrentCollider"},"fn":"CurrentCollider"},{"a":2,"n":"IsTrigger","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_IsTrigger","t":8,"rt":$n[0].Boolean,"fg":"IsTrigger","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"IsTrigger"},{"a":2,"n":"Slot","t":16,"rt":$n[3].Slot,"g":{"a":2,"n":"get_Slot","t":8,"rt":$n[3].Slot,"fg":"Slot"},"fn":"Slot"},{"a":4,"n":"DebugMessages","is":true,"t":4,"rt":$n[0].Boolean,"sn":"DebugMessages","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"clearStateOnDisable","t":4,"rt":$n[0].Boolean,"sn":"clearStateOnDisable","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"colliderTable","t":4,"rt":$n[5].Dictionary$2(spine.BoundingBoxAttachment,UnityEngine.PolygonCollider2D),"sn":"colliderTable","ro":true},{"a":1,"n":"currentAttachment","t":4,"rt":spine.BoundingBoxAttachment,"sn":"currentAttachment"},{"a":1,"n":"currentAttachmentName","t":4,"rt":$n[0].String,"sn":"currentAttachmentName"},{"a":1,"n":"currentCollider","t":4,"rt":$n[1].PolygonCollider2D,"sn":"currentCollider"},{"a":2,"n":"isTrigger","t":4,"rt":$n[0].Boolean,"sn":"isTrigger","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"nameTable","t":4,"rt":$n[5].Dictionary$2(spine.BoundingBoxAttachment,System.String),"sn":"nameTable","ro":true},{"a":2,"n":"skeletonRenderer","t":4,"rt":$n[4].SkeletonRenderer,"sn":"skeletonRenderer"},{"a":1,"n":"slot","t":4,"rt":$n[3].Slot,"sn":"slot"},{"at":[new Spine.Unity.SpineSlot("", "skeletonRenderer", true, true, false)],"a":2,"n":"slotName","t":4,"rt":$n[0].String,"sn":"slotName"},{"a":2,"n":"usedByComposite","t":4,"rt":$n[0].Boolean,"sn":"usedByComposite","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"usedByEffector","t":4,"rt":$n[0].Boolean,"sn":"usedByEffector","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.BoundingBoxFollower end.*/

    /*Spine.Unity.BoundingBoxFollowerGraphic start.*/
    $m("Spine.Unity.BoundingBoxFollowerGraphic", function () { return {"att":1048577,"a":2,"at":[new UnityEngine.ExecuteAlwaysAttribute(),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#BoundingBoxFollowerGraphic")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"AddCollidersForSkin","t":8,"pi":[{"n":"skin","pt":$n[3].Skin,"ps":0},{"n":"slotIndex","pt":$n[0].Int32,"ps":1},{"n":"previousColliders","pt":System.Array.type(UnityEngine.PolygonCollider2D),"ps":2},{"n":"scale","pt":$n[0].Single,"ps":3},{"n":"collidersCount","ref":true,"pt":$n[0].Int32,"ps":4}],"sn":"AddCollidersForSkin","rt":$n[0].Void,"p":[$n[3].Skin,$n[0].Int32,System.Array.type(UnityEngine.PolygonCollider2D),$n[0].Single,$n[0].Int32]},{"a":2,"n":"ClearState","t":8,"sn":"ClearState","rt":$n[0].Void},{"a":1,"n":"DisposeExcessCollidersAfter","t":8,"pi":[{"n":"requiredCount","pt":$n[0].Int32,"ps":0}],"sn":"DisposeExcessCollidersAfter","rt":$n[0].Void,"p":[$n[0].Int32]},{"a":1,"n":"HandleRebuild","t":8,"pi":[{"n":"sr","pt":$n[4].SkeletonGraphic,"ps":0}],"sn":"HandleRebuild","rt":$n[0].Void,"p":[$n[4].SkeletonGraphic]},{"a":2,"n":"Initialize","t":8,"pi":[{"n":"overwrite","dv":false,"o":true,"pt":$n[0].Boolean,"ps":0}],"sn":"Initialize","rt":$n[0].Void,"p":[$n[0].Boolean]},{"a":1,"n":"LateUpdate","t":8,"sn":"LateUpdate","rt":$n[0].Void},{"a":1,"n":"MatchAttachment","t":8,"pi":[{"n":"attachment","pt":spine.Attachment,"ps":0}],"sn":"MatchAttachment","rt":$n[0].Void,"p":[spine.Attachment]},{"a":1,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"a":1,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[0].Void},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":2,"n":"CurrentAttachment","t":16,"rt":spine.BoundingBoxAttachment,"g":{"a":2,"n":"get_CurrentAttachment","t":8,"rt":spine.BoundingBoxAttachment,"fg":"CurrentAttachment"},"fn":"CurrentAttachment"},{"a":2,"n":"CurrentAttachmentName","t":16,"rt":$n[0].String,"g":{"a":2,"n":"get_CurrentAttachmentName","t":8,"rt":$n[0].String,"fg":"CurrentAttachmentName"},"fn":"CurrentAttachmentName"},{"a":2,"n":"CurrentCollider","t":16,"rt":$n[1].PolygonCollider2D,"g":{"a":2,"n":"get_CurrentCollider","t":8,"rt":$n[1].PolygonCollider2D,"fg":"CurrentCollider"},"fn":"CurrentCollider"},{"a":2,"n":"IsTrigger","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_IsTrigger","t":8,"rt":$n[0].Boolean,"fg":"IsTrigger","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"IsTrigger"},{"a":2,"n":"Slot","t":16,"rt":$n[3].Slot,"g":{"a":2,"n":"get_Slot","t":8,"rt":$n[3].Slot,"fg":"Slot"},"fn":"Slot"},{"a":4,"n":"DebugMessages","is":true,"t":4,"rt":$n[0].Boolean,"sn":"DebugMessages","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"clearStateOnDisable","t":4,"rt":$n[0].Boolean,"sn":"clearStateOnDisable","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"colliderTable","t":4,"rt":$n[5].Dictionary$2(spine.BoundingBoxAttachment,UnityEngine.PolygonCollider2D),"sn":"colliderTable","ro":true},{"a":1,"n":"currentAttachment","t":4,"rt":spine.BoundingBoxAttachment,"sn":"currentAttachment"},{"a":1,"n":"currentAttachmentName","t":4,"rt":$n[0].String,"sn":"currentAttachmentName"},{"a":1,"n":"currentCollider","t":4,"rt":$n[1].PolygonCollider2D,"sn":"currentCollider"},{"a":2,"n":"isTrigger","t":4,"rt":$n[0].Boolean,"sn":"isTrigger","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"nameTable","t":4,"rt":$n[5].Dictionary$2(spine.BoundingBoxAttachment,System.String),"sn":"nameTable","ro":true},{"a":2,"n":"skeletonGraphic","t":4,"rt":$n[4].SkeletonGraphic,"sn":"skeletonGraphic"},{"a":1,"n":"slot","t":4,"rt":$n[3].Slot,"sn":"slot"},{"at":[new Spine.Unity.SpineSlot("", "skeletonGraphic", true, true, false)],"a":2,"n":"slotName","t":4,"rt":$n[0].String,"sn":"slotName"},{"a":2,"n":"usedByComposite","t":4,"rt":$n[0].Boolean,"sn":"usedByComposite","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"usedByEffector","t":4,"rt":$n[0].Boolean,"sn":"usedByEffector","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.BoundingBoxFollowerGraphic end.*/

    /*Spine.Unity.PointFollower start.*/
    $m("Spine.Unity.PointFollower", function () { return {"att":1048577,"a":2,"at":[new UnityEngine.ExecuteAlwaysAttribute(),new UnityEngine.AddComponentMenu.ctor("Spine/Point Follower"),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#PointFollower")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"HandleRebuildRenderer","t":8,"pi":[{"n":"skeletonRenderer","pt":$n[4].SkeletonRenderer,"ps":0}],"sn":"HandleRebuildRenderer","rt":$n[0].Void,"p":[$n[4].SkeletonRenderer]},{"a":2,"n":"Initialize","t":8,"sn":"Initialize","rt":$n[0].Void},{"a":2,"n":"LateUpdate","t":8,"sn":"LateUpdate","rt":$n[0].Void},{"a":1,"n":"OnDestroy","t":8,"sn":"OnDestroy","rt":$n[0].Void},{"a":1,"n":"UpdateReferences","t":8,"sn":"UpdateReferences","rt":$n[0].Void},{"a":2,"n":"IsValid","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_IsValid","t":8,"rt":$n[0].Boolean,"fg":"IsValid","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"IsValid"},{"a":2,"n":"SkeletonComponent","t":16,"rt":$n[4].ISkeletonComponent,"g":{"a":2,"n":"get_SkeletonComponent","t":8,"rt":$n[4].ISkeletonComponent,"fg":"SkeletonComponent"},"fn":"SkeletonComponent"},{"a":2,"n":"SkeletonRenderer","t":16,"rt":$n[4].SkeletonRenderer,"g":{"a":2,"n":"get_SkeletonRenderer","t":8,"rt":$n[4].SkeletonRenderer,"fg":"SkeletonRenderer"},"fn":"SkeletonRenderer"},{"a":1,"n":"bone","t":4,"rt":$n[3].Bone,"sn":"bone"},{"a":2,"n":"followRotation","t":4,"rt":$n[0].Boolean,"sn":"followRotation","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"followSkeletonFlip","t":4,"rt":$n[0].Boolean,"sn":"followSkeletonFlip","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"followSkeletonZPosition","t":4,"rt":$n[0].Boolean,"sn":"followSkeletonZPosition","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"point","t":4,"rt":$n[3].PointAttachment,"sn":"point"},{"at":[new Spine.Unity.SpineAttachment(true, false, false, "slotName", "skeletonRenderer", "", true, true)],"a":2,"n":"pointAttachmentName","t":4,"rt":$n[0].String,"sn":"pointAttachmentName"},{"a":2,"n":"skeletonRenderer","t":4,"rt":$n[4].SkeletonRenderer,"sn":"skeletonRenderer"},{"a":1,"n":"skeletonTransform","t":4,"rt":$n[1].Transform,"sn":"skeletonTransform"},{"a":1,"n":"skeletonTransformIsParent","t":4,"rt":$n[0].Boolean,"sn":"skeletonTransformIsParent","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new Spine.Unity.SpineSlot("", "skeletonRenderer", false, true, false)],"a":2,"n":"slotName","t":4,"rt":$n[0].String,"sn":"slotName"},{"a":1,"n":"valid","t":4,"rt":$n[0].Boolean,"sn":"valid","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.PointFollower end.*/

    /*Spine.Unity.SkeletonSubmeshGraphic start.*/
    $m("Spine.Unity.SkeletonSubmeshGraphic", function () { return {"att":1048577,"a":2,"at":[new UnityEngine.RequireComponent.ctor(UnityEngine.CanvasRenderer)],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"ov":true,"a":3,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"ov":true,"a":3,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[0].Void},{"ov":true,"a":3,"n":"OnPopulateMesh","t":8,"pi":[{"n":"vh","pt":$n[2].VertexHelper,"ps":0}],"sn":"OnPopulateMesh","rt":$n[0].Void,"p":[$n[2].VertexHelper]},{"ov":true,"a":2,"n":"SetMaterialDirty","t":8,"sn":"SetMaterialDirty","rt":$n[0].Void},{"ov":true,"a":2,"n":"SetVerticesDirty","t":8,"sn":"SetVerticesDirty","rt":$n[0].Void}]}; }, $n);
    /*Spine.Unity.SkeletonSubmeshGraphic end.*/

    /*Spine.Unity.SkeletonMecanimRootMotion start.*/
    $m("Spine.Unity.SkeletonMecanimRootMotion", function () { return {"att":1048577,"a":2,"at":[new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#SkeletonMecanimRootMotion")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"ov":true,"a":3,"n":"CalculateAnimationsMovementDelta","t":8,"sn":"CalculateAnimationsMovementDelta","rt":$n[1].Vector2},{"ov":true,"a":3,"n":"CalculateAnimationsRotationDelta","t":8,"sn":"CalculateAnimationsRotationDelta","rt":$n[0].Single,"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"ov":true,"a":2,"n":"GetRemainingRootMotion","t":8,"pi":[{"n":"layerIndex","pt":$n[0].Int32,"ps":0}],"sn":"GetRemainingRootMotion","rt":$n[1].Vector2,"p":[$n[0].Int32]},{"ov":true,"a":2,"n":"GetRootMotionInfo","t":8,"pi":[{"n":"layerIndex","pt":$n[0].Int32,"ps":0}],"sn":"GetRootMotionInfo","rt":$n[4].SkeletonRootMotionBase.RootMotionInfo,"p":[$n[0].Int32]},{"a":1,"n":"OnClipApplied","t":8,"pi":[{"n":"animation","pt":$n[3].Animation,"ps":0},{"n":"layerIndex","pt":$n[0].Int32,"ps":1},{"n":"weight","pt":$n[0].Single,"ps":2},{"n":"time","pt":$n[0].Single,"ps":3},{"n":"lastTime","pt":$n[0].Single,"ps":4},{"n":"playsBackward","pt":$n[0].Boolean,"ps":5}],"sn":"OnClipApplied","rt":$n[0].Void,"p":[$n[3].Animation,$n[0].Int32,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Boolean]},{"ov":true,"a":3,"n":"Reset","t":8,"sn":"Reset","rt":$n[0].Void},{"ov":true,"a":3,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":2,"n":"SkeletonMecanim","t":16,"rt":$n[4].SkeletonMecanim,"g":{"a":2,"n":"get_SkeletonMecanim","t":8,"rt":$n[4].SkeletonMecanim,"fg":"SkeletonMecanim"},"fn":"SkeletonMecanim"},{"a":1,"n":"DefaultMecanimLayerFlags","is":true,"t":4,"rt":$n[0].Int32,"sn":"DefaultMecanimLayerFlags","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"mecanimLayerFlags","t":4,"rt":$n[0].Int32,"sn":"mecanimLayerFlags","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":3,"n":"movementDelta","t":4,"rt":$n[1].Vector2,"sn":"movementDelta"},{"a":3,"n":"rotationDelta","t":4,"rt":$n[0].Single,"sn":"rotationDelta","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"skeletonMecanim","t":4,"rt":$n[4].SkeletonMecanim,"sn":"skeletonMecanim"}]}; }, $n);
    /*Spine.Unity.SkeletonMecanimRootMotion end.*/

    /*Spine.Unity.SkeletonRootMotion start.*/
    $m("Spine.Unity.SkeletonRootMotion", function () { return {"att":1048577,"a":2,"at":[new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#SkeletonRootMotion")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"ApplyMixAlphaToDelta","t":8,"pi":[{"n":"currentDelta","ref":true,"pt":$n[0].Single,"ps":0},{"n":"next","pt":$n[3].TrackEntry,"ps":1},{"n":"track","pt":$n[3].TrackEntry,"ps":2}],"sn":"ApplyMixAlphaToDelta","rt":$n[0].Void,"p":[$n[0].Single,$n[3].TrackEntry,$n[3].TrackEntry]},{"a":1,"n":"ApplyMixAlphaToDelta","t":8,"pi":[{"n":"currentDelta","ref":true,"pt":$n[1].Vector2,"ps":0},{"n":"next","pt":$n[3].TrackEntry,"ps":1},{"n":"track","pt":$n[3].TrackEntry,"ps":2}],"sn":"ApplyMixAlphaToDelta$1","rt":$n[0].Void,"p":[$n[1].Vector2,$n[3].TrackEntry,$n[3].TrackEntry]},{"ov":true,"a":3,"n":"CalculateAnimationsMovementDelta","t":8,"sn":"CalculateAnimationsMovementDelta","rt":$n[1].Vector2},{"ov":true,"a":3,"n":"CalculateAnimationsRotationDelta","t":8,"sn":"CalculateAnimationsRotationDelta","rt":$n[0].Single,"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"GetMixAlpha","t":8,"pi":[{"n":"cumulatedMixAlpha","ref":true,"pt":$n[0].Single,"ps":0},{"n":"next","pt":$n[3].TrackEntry,"ps":1},{"n":"track","pt":$n[3].TrackEntry,"ps":2}],"sn":"GetMixAlpha","rt":$n[0].Void,"p":[$n[0].Single,$n[3].TrackEntry,$n[3].TrackEntry]},{"ov":true,"a":2,"n":"GetRemainingRootMotion","t":8,"pi":[{"n":"trackIndex","pt":$n[0].Int32,"ps":0}],"sn":"GetRemainingRootMotion","rt":$n[1].Vector2,"p":[$n[0].Int32]},{"ov":true,"a":2,"n":"GetRootMotionInfo","t":8,"pi":[{"n":"trackIndex","pt":$n[0].Int32,"ps":0}],"sn":"GetRootMotionInfo","rt":$n[4].SkeletonRootMotionBase.RootMotionInfo,"p":[$n[0].Int32]},{"ov":true,"a":3,"n":"Reset","t":8,"sn":"Reset","rt":$n[0].Void},{"ov":true,"a":3,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"ov":true,"a":3,"n":"AdditionalScale","t":16,"rt":$n[0].Single,"g":{"ov":true,"a":3,"n":"get_AdditionalScale","t":8,"rt":$n[0].Single,"fg":"AdditionalScale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"fn":"AdditionalScale"},{"a":1,"n":"DefaultAnimationTrackFlags","is":true,"t":4,"rt":$n[0].Int32,"sn":"DefaultAnimationTrackFlags","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"animationState","t":4,"rt":$n[3].AnimationState,"sn":"animationState"},{"a":2,"n":"animationTrackFlags","t":4,"rt":$n[0].Int32,"sn":"animationTrackFlags","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"skeletonGraphic","t":4,"rt":$n[4].SkeletonGraphic,"sn":"skeletonGraphic"}]}; }, $n);
    /*Spine.Unity.SkeletonRootMotion end.*/

    /*Spine.Unity.SkeletonRootMotionBase start.*/
    $m("Spine.Unity.SkeletonRootMotionBase", function () { return {"nested":[Function,$n[4].SkeletonRootMotionBase.RootMotionInfo],"att":1048705,"a":2,"at":[new UnityEngine.DefaultExecutionOrder(1)],"m":[{"a":3,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"AdjustRootMotionToDistance","t":8,"pi":[{"n":"distanceToTarget","pt":$n[1].Vector2,"ps":0},{"n":"trackIndex","dv":0,"o":true,"pt":$n[0].Int32,"ps":1},{"n":"adjustX","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2},{"n":"adjustY","dv":true,"o":true,"pt":$n[0].Boolean,"ps":3},{"n":"minX","dv":0.0,"o":true,"pt":$n[0].Single,"ps":4},{"n":"maxX","dv":3.40282347E+38,"o":true,"pt":$n[0].Single,"ps":5},{"n":"minY","dv":0.0,"o":true,"pt":$n[0].Single,"ps":6},{"n":"maxY","dv":3.40282347E+38,"o":true,"pt":$n[0].Single,"ps":7},{"n":"allowXTranslation","dv":false,"o":true,"pt":$n[0].Boolean,"ps":8},{"n":"allowYTranslation","dv":false,"o":true,"pt":$n[0].Boolean,"ps":9}],"sn":"AdjustRootMotionToDistance","rt":$n[0].Void,"p":[$n[1].Vector2,$n[0].Int32,$n[0].Boolean,$n[0].Boolean,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Boolean,$n[0].Boolean]},{"a":1,"n":"ApplyConstraintToPos","t":8,"pi":[{"n":"animation","pt":$n[3].Animation,"ps":0},{"n":"constraint","pt":$n[3].TransformConstraint,"ps":1},{"n":"constraintIndex","pt":$n[0].Int32,"ps":2},{"n":"time","pt":$n[0].Single,"ps":3},{"n":"useLastConstraintPos","pt":$n[0].Boolean,"ps":4},{"n":"pos","ref":true,"pt":$n[1].Vector2,"ps":5}],"sn":"ApplyConstraintToPos","rt":$n[0].Void,"p":[$n[3].Animation,$n[3].TransformConstraint,$n[0].Int32,$n[0].Single,$n[0].Boolean,$n[1].Vector2]},{"a":1,"n":"ApplyConstraintToRotation","t":8,"pi":[{"n":"animation","pt":$n[3].Animation,"ps":0},{"n":"constraint","pt":$n[3].TransformConstraint,"ps":1},{"n":"constraintIndex","pt":$n[0].Int32,"ps":2},{"n":"time","pt":$n[0].Single,"ps":3},{"n":"useLastConstraintRotation","pt":$n[0].Boolean,"ps":4},{"n":"rotation","ref":true,"pt":$n[0].Single,"ps":5}],"sn":"ApplyConstraintToRotation","rt":$n[0].Void,"p":[$n[3].Animation,$n[3].TransformConstraint,$n[0].Int32,$n[0].Single,$n[0].Boolean,$n[0].Single]},{"a":1,"n":"ApplyRootMotion","t":8,"pi":[{"n":"skeletonTranslationDelta","pt":$n[1].Vector2,"ps":0},{"n":"skeletonRotationDelta","pt":$n[0].Single,"ps":1},{"n":"parentBoneScale","pt":$n[1].Vector2,"ps":2},{"n":"skeletonAnimationUsesFixedUpdate","pt":$n[0].Boolean,"ps":3}],"sn":"ApplyRootMotion","rt":$n[0].Void,"p":[$n[1].Vector2,$n[0].Single,$n[1].Vector2,$n[0].Boolean]},{"a":1,"n":"ApplyTransformConstraints","t":8,"sn":"ApplyTransformConstraints","rt":$n[0].Void},{"ab":true,"a":3,"n":"CalculateAnimationsMovementDelta","t":8,"sn":"CalculateAnimationsMovementDelta","rt":$n[1].Vector2},{"v":true,"a":3,"n":"CalculateAnimationsRotationDelta","t":8,"sn":"CalculateAnimationsRotationDelta","rt":$n[0].Single,"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"ClearEffectiveBoneOffsets","t":8,"pi":[{"n":"parentBoneScale","pt":$n[1].Vector2,"ps":0}],"sn":"ClearEffectiveBoneOffsets","rt":$n[0].Void,"p":[$n[1].Vector2]},{"a":1,"n":"ClearRigidbodyTempMovement","t":8,"sn":"ClearRigidbodyTempMovement","rt":$n[0].Void},{"a":3,"n":"FindRigidbodyComponent","t":8,"sn":"FindRigidbodyComponent","rt":$n[0].Void},{"a":1,"n":"FindTransformConstraintsAffectingBone","t":8,"sn":"FindTransformConstraintsAffectingBone","rt":$n[0].Void},{"v":true,"a":3,"n":"FixedUpdate","t":8,"sn":"FixedUpdate","rt":$n[0].Void},{"a":1,"n":"GatherTopLevelBones","t":8,"sn":"GatherTopLevelBones","rt":$n[0].Void},{"a":2,"n":"GetAnimationRootMotion","t":8,"pi":[{"n":"animation","pt":$n[3].Animation,"ps":0}],"sn":"GetAnimationRootMotion","rt":$n[1].Vector2,"p":[$n[3].Animation]},{"a":2,"n":"GetAnimationRootMotion","t":8,"pi":[{"n":"startTime","pt":$n[0].Single,"ps":0},{"n":"endTime","pt":$n[0].Single,"ps":1},{"n":"animation","pt":$n[3].Animation,"ps":2}],"sn":"GetAnimationRootMotion$1","rt":$n[1].Vector2,"p":[$n[0].Single,$n[0].Single,$n[3].Animation]},{"a":2,"n":"GetAnimationRootMotionInfo","t":8,"pi":[{"n":"animation","pt":$n[3].Animation,"ps":0},{"n":"currentTime","pt":$n[0].Single,"ps":1}],"sn":"GetAnimationRootMotionInfo","rt":$n[4].SkeletonRootMotionBase.RootMotionInfo,"p":[$n[3].Animation,$n[0].Single]},{"a":2,"n":"GetAnimationRootMotionRotation","t":8,"pi":[{"n":"animation","pt":$n[3].Animation,"ps":0}],"sn":"GetAnimationRootMotionRotation","rt":$n[0].Single,"p":[$n[3].Animation],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"GetAnimationRootMotionRotation","t":8,"pi":[{"n":"startTime","pt":$n[0].Single,"ps":0},{"n":"endTime","pt":$n[0].Single,"ps":1},{"n":"animation","pt":$n[3].Animation,"ps":2}],"sn":"GetAnimationRootMotionRotation$1","rt":$n[0].Single,"p":[$n[0].Single,$n[0].Single,$n[3].Animation],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"GetConstraintLastPosIndex","t":8,"pi":[{"n":"constraintIndex","pt":$n[0].Int32,"ps":0}],"sn":"GetConstraintLastPosIndex","rt":$n[0].Int32,"p":[$n[0].Int32],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"ab":true,"a":2,"n":"GetRemainingRootMotion","t":8,"pi":[{"n":"trackIndex","dv":0,"o":true,"pt":$n[0].Int32,"ps":0}],"sn":"GetRemainingRootMotion","rt":$n[1].Vector2,"p":[$n[0].Int32]},{"ab":true,"a":2,"n":"GetRootMotionInfo","t":8,"pi":[{"n":"trackIndex","dv":0,"o":true,"pt":$n[0].Int32,"ps":0}],"sn":"GetRootMotionInfo","rt":$n[4].SkeletonRootMotionBase.RootMotionInfo,"p":[$n[0].Int32]},{"a":1,"n":"GetScaleAffectingRootMotion","t":8,"sn":"GetScaleAffectingRootMotion","rt":$n[1].Vector2},{"a":1,"n":"GetScaleAffectingRootMotion","t":8,"pi":[{"n":"parentBoneScale","out":true,"pt":$n[1].Vector2,"ps":0}],"sn":"GetScaleAffectingRootMotion$1","rt":$n[1].Vector2,"p":[$n[1].Vector2]},{"a":1,"n":"GetSkeletonSpaceMovementDelta","t":8,"pi":[{"n":"boneLocalDelta","pt":$n[1].Vector2,"ps":0},{"n":"parentBoneScale","out":true,"pt":$n[1].Vector2,"ps":1},{"n":"totalScale","out":true,"pt":$n[1].Vector2,"ps":2}],"sn":"GetSkeletonSpaceMovementDelta","rt":$n[1].Vector2,"p":[$n[1].Vector2,$n[1].Vector2,$n[1].Vector2]},{"a":1,"n":"GetSkeletonSpaceRotationDelta","t":8,"pi":[{"n":"boneLocalDelta","pt":$n[0].Single,"ps":0},{"n":"totalScaleAffectingRootMotion","pt":$n[1].Vector2,"ps":1}],"sn":"GetSkeletonSpaceRotationDelta","rt":$n[0].Single,"p":[$n[0].Single,$n[1].Vector2],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"GetTimelineMovementDelta","t":8,"pi":[{"n":"startTime","pt":$n[0].Single,"ps":0},{"n":"endTime","pt":$n[0].Single,"ps":1},{"n":"xTimeline","pt":spine.TranslateXTimeline,"ps":2},{"n":"yTimeline","pt":spine.TranslateYTimeline,"ps":3},{"n":"animation","pt":$n[3].Animation,"ps":4}],"sn":"GetTimelineMovementDelta","rt":$n[1].Vector2,"p":[$n[0].Single,$n[0].Single,spine.TranslateXTimeline,spine.TranslateYTimeline,$n[3].Animation]},{"a":1,"n":"HandleUpdateLocal","t":8,"pi":[{"n":"animatedSkeletonComponent","pt":$n[4].ISkeletonAnimation,"ps":0}],"sn":"HandleUpdateLocal","rt":$n[0].Void,"p":[$n[4].ISkeletonAnimation]},{"v":true,"a":3,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"v":true,"a":3,"n":"PhysicsUpdate","t":8,"pi":[{"n":"skeletonAnimationUsesFixedUpdate","pt":$n[0].Boolean,"ps":0}],"sn":"PhysicsUpdate","rt":$n[0].Void,"p":[$n[0].Boolean]},{"v":true,"a":3,"n":"Reset","t":8,"sn":"Reset","rt":$n[0].Void},{"a":1,"n":"SetEffectiveBoneOffsetsTo","t":8,"pi":[{"n":"displacementSkeletonSpace","pt":$n[1].Vector2,"ps":0},{"n":"rotationSkeletonSpace","pt":$n[0].Single,"ps":1},{"n":"parentBoneScale","pt":$n[1].Vector2,"ps":2}],"sn":"SetEffectiveBoneOffsetsTo","rt":$n[0].Void,"p":[$n[1].Vector2,$n[0].Single,$n[1].Vector2]},{"a":2,"n":"SetRootMotionBone","t":8,"pi":[{"n":"name","pt":$n[0].String,"ps":0}],"sn":"SetRootMotionBone","rt":$n[0].Void,"p":[$n[0].String]},{"v":true,"a":3,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":1,"n":"UpdateLastConstraintPos","t":8,"pi":[{"n":"transformConstraintsItems","pt":System.Array.type(Spine.TransformConstraint),"ps":0}],"sn":"UpdateLastConstraintPos","rt":$n[0].Void,"p":[System.Array.type(Spine.TransformConstraint)]},{"a":1,"n":"UpdateLastConstraintRotation","t":8,"pi":[{"n":"transformConstraintsItems","pt":System.Array.type(Spine.TransformConstraint),"ps":0}],"sn":"UpdateLastConstraintRotation","rt":$n[0].Void,"p":[System.Array.type(Spine.TransformConstraint)]},{"a":2,"n":"AdditionalRigidbody2DMovement","t":16,"rt":$n[1].Vector2,"g":{"a":2,"n":"get_AdditionalRigidbody2DMovement","t":8,"rt":$n[1].Vector2,"fg":"AdditionalRigidbody2DMovement"},"s":{"a":2,"n":"set_AdditionalRigidbody2DMovement","t":8,"p":[$n[1].Vector2],"rt":$n[0].Void,"fs":"AdditionalRigidbody2DMovement"},"fn":"AdditionalRigidbody2DMovement"},{"v":true,"a":3,"n":"AdditionalScale","t":16,"rt":$n[0].Single,"g":{"v":true,"a":3,"n":"get_AdditionalScale","t":8,"rt":$n[0].Single,"fg":"AdditionalScale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"fn":"AdditionalScale"},{"a":2,"n":"PreviousRigidbodyRootMotion2D","t":16,"rt":$n[1].Vector2,"g":{"a":2,"n":"get_PreviousRigidbodyRootMotion2D","t":8,"rt":$n[1].Vector2,"fg":"PreviousRigidbodyRootMotion2D"},"fn":"PreviousRigidbodyRootMotion2D"},{"a":2,"n":"PreviousRigidbodyRootMotion3D","t":16,"rt":$n[1].Vector3,"g":{"a":2,"n":"get_PreviousRigidbodyRootMotion3D","t":8,"rt":$n[1].Vector3,"fg":"PreviousRigidbodyRootMotion3D"},"fn":"PreviousRigidbodyRootMotion3D"},{"a":2,"n":"RootMotionBone","t":16,"rt":$n[3].Bone,"g":{"a":2,"n":"get_RootMotionBone","t":8,"rt":$n[3].Bone,"fg":"RootMotionBone"},"fn":"RootMotionBone"},{"a":3,"n":"SkeletonAnimationUsesFixedUpdate","t":16,"rt":$n[0].Boolean,"g":{"a":3,"n":"get_SkeletonAnimationUsesFixedUpdate","t":8,"rt":$n[0].Boolean,"fg":"SkeletonAnimationUsesFixedUpdate","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"SkeletonAnimationUsesFixedUpdate"},{"a":2,"n":"TargetSkeletonAnimationComponent","t":16,"rt":$n[4].ISkeletonAnimation,"g":{"a":2,"n":"get_TargetSkeletonAnimationComponent","t":8,"rt":$n[4].ISkeletonAnimation,"fg":"TargetSkeletonAnimationComponent"},"fn":"TargetSkeletonAnimationComponent"},{"a":2,"n":"TargetSkeletonComponent","t":16,"rt":$n[4].ISkeletonComponent,"g":{"a":2,"n":"get_TargetSkeletonComponent","t":8,"rt":$n[4].ISkeletonComponent,"fg":"TargetSkeletonComponent"},"fn":"TargetSkeletonComponent"},{"a":2,"n":"UsesRigidbody","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_UsesRigidbody","t":8,"rt":$n[0].Boolean,"fg":"UsesRigidbody","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"UsesRigidbody"},{"a":3,"n":"accumulatedUntilFixedUpdate","t":4,"rt":$n[0].Boolean,"sn":"accumulatedUntilFixedUpdate","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":3,"n":"additionalRigidbody2DMovement","t":4,"rt":$n[1].Vector2,"sn":"additionalRigidbody2DMovement"},{"a":2,"n":"applyRigidbody2DGravity","t":4,"rt":$n[0].Boolean,"sn":"applyRigidbody2DGravity","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"disableOnOverride","t":4,"rt":$n[0].Boolean,"sn":"disableOnOverride","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":3,"n":"initialOffset","t":4,"rt":$n[1].Vector2,"sn":"initialOffset"},{"a":3,"n":"initialOffsetRotation","t":4,"rt":$n[0].Single,"sn":"initialOffsetRotation","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":3,"n":"previousRigidbodyRootMotion","t":4,"rt":$n[1].Vector3,"sn":"previousRigidbodyRootMotion"},{"a":2,"n":"rigidBody","t":4,"rt":$n[1].Rigidbody,"sn":"rigidBody"},{"at":[new UnityEngine.HeaderAttribute("Optional")],"a":2,"n":"rigidBody2D","t":4,"rt":$n[1].Rigidbody2D,"sn":"rigidBody2D"},{"a":3,"n":"rigidbody2DRotation","t":4,"rt":$n[0].Single,"sn":"rigidbody2DRotation","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":3,"n":"rigidbodyDisplacement","t":4,"rt":$n[1].Vector3,"sn":"rigidbodyDisplacement"},{"a":3,"n":"rigidbodyLocalRotation","t":4,"rt":$n[1].Quaternion,"sn":"rigidbodyLocalRotation"},{"a":3,"n":"rootMotionBone","t":4,"rt":$n[3].Bone,"sn":"rootMotionBone"},{"a":3,"n":"rootMotionBoneIndex","t":4,"rt":$n[0].Int32,"sn":"rootMotionBoneIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},{"at":[new Spine.Unity.SpineBone("", "", true, false),new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"rootMotionBoneName","t":4,"rt":$n[0].String,"sn":"rootMotionBoneName"},{"a":2,"n":"rootMotionScaleRotation","t":4,"rt":$n[0].Single,"sn":"rootMotionScaleRotation","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"rootMotionScaleX","t":4,"rt":$n[0].Single,"sn":"rootMotionScaleX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"rootMotionScaleY","t":4,"rt":$n[0].Single,"sn":"rootMotionScaleY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"rootMotionTranslateXPerY","t":4,"rt":$n[0].Single,"sn":"rootMotionTranslateXPerY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"rootMotionTranslateYPerX","t":4,"rt":$n[0].Single,"sn":"rootMotionTranslateYPerX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":3,"n":"skeletonComponent","t":4,"rt":$n[4].ISkeletonComponent,"sn":"skeletonComponent"},{"a":3,"n":"tempSkeletonDisplacement","t":4,"rt":$n[1].Vector2,"sn":"tempSkeletonDisplacement"},{"a":3,"n":"tempSkeletonRotation","t":4,"rt":$n[0].Single,"sn":"tempSkeletonRotation","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":3,"n":"topLevelBones","t":4,"rt":$n[5].List$1(Spine.Bone),"sn":"topLevelBones"},{"a":3,"n":"transformConstraintIndices","t":4,"rt":$n[5].List$1(System.Int32),"sn":"transformConstraintIndices"},{"a":3,"n":"transformConstraintLastPos","t":4,"rt":$n[5].List$1(UnityEngine.Vector2),"sn":"transformConstraintLastPos"},{"a":3,"n":"transformConstraintLastRotation","t":4,"rt":$n[5].List$1(System.Single),"sn":"transformConstraintLastRotation"},{"a":2,"n":"transformPositionX","t":4,"rt":$n[0].Boolean,"sn":"transformPositionX","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"transformPositionY","t":4,"rt":$n[0].Boolean,"sn":"transformPositionY","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"transformRotation","t":4,"rt":$n[0].Boolean,"sn":"transformRotation","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"PhysicsUpdateRootMotionOverride","t":2,"ad":{"a":2,"n":"add_PhysicsUpdateRootMotionOverride","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addPhysicsUpdateRootMotionOverride","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_PhysicsUpdateRootMotionOverride","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removePhysicsUpdateRootMotionOverride","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"ProcessRootMotionOverride","t":2,"ad":{"a":2,"n":"add_ProcessRootMotionOverride","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addProcessRootMotionOverride","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_ProcessRootMotionOverride","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeProcessRootMotionOverride","rt":$n[0].Void,"p":[Function]}}]}; }, $n);
    /*Spine.Unity.SkeletonRootMotionBase end.*/

    /*Spine.Unity.SkeletonRootMotionBase+RootMotionInfo start.*/
    $m("Spine.Unity.SkeletonRootMotionBase.RootMotionInfo", function () { return {"td":$n[4].SkeletonRootMotionBase,"att":1048842,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"current","t":4,"rt":$n[1].Vector2,"sn":"current"},{"a":2,"n":"end","t":4,"rt":$n[1].Vector2,"sn":"end"},{"a":2,"n":"mid","t":4,"rt":$n[1].Vector2,"sn":"mid"},{"a":2,"n":"start","t":4,"rt":$n[1].Vector2,"sn":"start"},{"a":2,"n":"timeIsPastMid","t":4,"rt":$n[0].Boolean,"sn":"timeIsPastMid","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.SkeletonRootMotionBase+RootMotionInfo end.*/

    /*Spine.Unity.SkeletonAnimation start.*/
    $m("Spine.Unity.SkeletonAnimation", function () { return {"att":1048577,"a":2,"at":[new UnityEngine.ExecuteAlwaysAttribute(),new UnityEngine.AddComponentMenu.ctor("Spine/SkeletonAnimation"),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#SkeletonAnimation-Component")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"AddToGameObject","is":true,"t":8,"pi":[{"n":"gameObject","pt":$n[1].GameObject,"ps":0},{"n":"skeletonDataAsset","pt":$n[4].SkeletonDataAsset,"ps":1},{"n":"quiet","dv":false,"o":true,"pt":$n[0].Boolean,"ps":2}],"sn":"AddToGameObject","rt":$n[4].SkeletonAnimation,"p":[$n[1].GameObject,$n[4].SkeletonDataAsset,$n[0].Boolean]},{"a":2,"n":"AfterAnimationApplied","t":8,"sn":"AfterAnimationApplied","rt":$n[0].Void},{"a":3,"n":"ApplyAnimation","t":8,"sn":"ApplyAnimation","rt":$n[0].Void},{"ov":true,"a":2,"n":"ClearState","t":8,"sn":"ClearState","rt":$n[0].Void},{"v":true,"a":3,"n":"FixedUpdate","t":8,"sn":"FixedUpdate","rt":$n[0].Void},{"ov":true,"a":2,"n":"Initialize","t":8,"pi":[{"n":"overwrite","pt":$n[0].Boolean,"ps":0},{"n":"quiet","dv":false,"o":true,"pt":$n[0].Boolean,"ps":1}],"sn":"Initialize","rt":$n[0].Void,"p":[$n[0].Boolean,$n[0].Boolean]},{"ov":true,"a":2,"n":"LateUpdate","t":8,"sn":"LateUpdate","rt":$n[0].Void},{"a":2,"n":"NewSkeletonAnimationGameObject","is":true,"t":8,"pi":[{"n":"skeletonDataAsset","pt":$n[4].SkeletonDataAsset,"ps":0},{"n":"quiet","dv":false,"o":true,"pt":$n[0].Boolean,"ps":1}],"sn":"NewSkeletonAnimationGameObject","rt":$n[4].SkeletonAnimation,"p":[$n[4].SkeletonDataAsset,$n[0].Boolean]},{"ov":true,"a":2,"n":"OnBecameVisible","t":8,"sn":"OnBecameVisible","rt":$n[0].Void},{"v":true,"a":3,"n":"Update","t":8,"sn":"Update$1","rt":$n[0].Void},{"a":2,"n":"Update","t":8,"pi":[{"n":"deltaTime","pt":$n[0].Single,"ps":0}],"sn":"Update","rt":$n[0].Void,"p":[$n[0].Single]},{"a":3,"n":"UpdateAnimationStatus","t":8,"pi":[{"n":"deltaTime","pt":$n[0].Single,"ps":0}],"sn":"UpdateAnimationStatus","rt":$n[0].Void,"p":[$n[0].Single]},{"a":2,"n":"AnimationName","t":16,"rt":$n[0].String,"g":{"a":2,"n":"get_AnimationName","t":8,"rt":$n[0].String,"fg":"AnimationName"},"s":{"a":2,"n":"set_AnimationName","t":8,"p":[$n[0].String],"rt":$n[0].Void,"fs":"AnimationName"},"fn":"AnimationName"},{"a":2,"n":"AnimationState","t":16,"rt":$n[3].AnimationState,"g":{"a":2,"n":"get_AnimationState","t":8,"rt":$n[3].AnimationState,"fg":"AnimationState"},"fn":"AnimationState"},{"a":2,"n":"UnscaledTime","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_UnscaledTime","t":8,"rt":$n[0].Boolean,"fg":"UnscaledTime","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_UnscaledTime","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"UnscaledTime"},"fn":"UnscaledTime"},{"a":2,"n":"UpdateTiming","t":16,"rt":$n[4].UpdateTiming,"g":{"a":2,"n":"get_UpdateTiming","t":8,"rt":$n[4].UpdateTiming,"fg":"UpdateTiming","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateTiming, System.Enum.toStringFn(Spine.Unity.UpdateTiming));}},"s":{"a":2,"n":"set_UpdateTiming","t":8,"p":[$n[4].UpdateTiming],"rt":$n[0].Void,"fs":"UpdateTiming"},"fn":"UpdateTiming"},{"at":[new UnityEngine.SerializeFieldAttribute(),new Spine.Unity.SpineAnimation("", "", true, false)],"a":1,"n":"_animationName","t":4,"rt":$n[0].String,"sn":"_animationName"},{"a":2,"n":"loop","t":4,"rt":$n[0].Boolean,"sn":"loop","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"state","t":4,"rt":$n[3].AnimationState,"sn":"state"},{"a":2,"n":"timeScale","t":4,"rt":$n[0].Single,"sn":"timeScale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"unscaledTime","t":4,"rt":$n[0].Boolean,"sn":"unscaledTime","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"updateTiming","t":4,"rt":$n[4].UpdateTiming,"sn":"updateTiming","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateTiming, System.Enum.toStringFn(Spine.Unity.UpdateTiming));}},{"a":1,"n":"wasUpdatedAfterInit","t":4,"rt":$n[0].Boolean,"sn":"wasUpdatedAfterInit","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"BeforeApply","t":2,"ad":{"a":2,"n":"add_BeforeApply","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addBeforeApply","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_BeforeApply","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeBeforeApply","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"OnAnimationRebuild","t":2,"ad":{"a":2,"n":"add_OnAnimationRebuild","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnAnimationRebuild","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_OnAnimationRebuild","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnAnimationRebuild","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"UpdateComplete","t":2,"ad":{"a":2,"n":"add_UpdateComplete","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addUpdateComplete","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_UpdateComplete","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeUpdateComplete","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"UpdateLocal","t":2,"ad":{"a":2,"n":"add_UpdateLocal","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addUpdateLocal","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_UpdateLocal","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeUpdateLocal","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"UpdateWorld","t":2,"ad":{"a":2,"n":"add_UpdateWorld","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addUpdateWorld","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_UpdateWorld","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeUpdateWorld","rt":$n[0].Void,"p":[Function]}},{"a":3,"n":"_BeforeApply","t":2,"ad":{"a":3,"n":"add__BeforeApply","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"add_BeforeApply","rt":$n[0].Void,"p":[Function]},"r":{"a":3,"n":"remove__BeforeApply","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"remove_BeforeApply","rt":$n[0].Void,"p":[Function]}},{"a":3,"n":"_OnAnimationRebuild","t":2,"ad":{"a":3,"n":"add__OnAnimationRebuild","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"add_OnAnimationRebuild","rt":$n[0].Void,"p":[Function]},"r":{"a":3,"n":"remove__OnAnimationRebuild","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"remove_OnAnimationRebuild","rt":$n[0].Void,"p":[Function]}},{"a":3,"n":"_UpdateComplete","t":2,"ad":{"a":3,"n":"add__UpdateComplete","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"add_UpdateComplete","rt":$n[0].Void,"p":[Function]},"r":{"a":3,"n":"remove__UpdateComplete","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"remove_UpdateComplete","rt":$n[0].Void,"p":[Function]}},{"a":3,"n":"_UpdateLocal","t":2,"ad":{"a":3,"n":"add__UpdateLocal","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"add_UpdateLocal","rt":$n[0].Void,"p":[Function]},"r":{"a":3,"n":"remove__UpdateLocal","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"remove_UpdateLocal","rt":$n[0].Void,"p":[Function]}},{"a":3,"n":"_UpdateWorld","t":2,"ad":{"a":3,"n":"add__UpdateWorld","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"add_UpdateWorld","rt":$n[0].Void,"p":[Function]},"r":{"a":3,"n":"remove__UpdateWorld","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"remove_UpdateWorld","rt":$n[0].Void,"p":[Function]}}]}; }, $n);
    /*Spine.Unity.SkeletonAnimation end.*/

    /*Spine.Unity.SkeletonGraphic start.*/
    $m("Spine.Unity.SkeletonGraphic", function () { return {"nested":[$n[4].SkeletonGraphic.LayoutMode,Function,Function,Function,Function],"att":1048577,"a":2,"at":[new UnityEngine.ExecuteAlwaysAttribute(),new UnityEngine.RequireComponent.$ctor1(UnityEngine.CanvasRenderer, UnityEngine.RectTransform),new UnityEngine.DisallowMultipleComponent(),new UnityEngine.AddComponentMenu.ctor("Spine/SkeletonGraphic (Unity UI Canvas)"),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#SkeletonGraphic-Component")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"AddSkeletonGraphicComponent","is":true,"t":8,"pi":[{"n":"gameObject","pt":$n[1].GameObject,"ps":0},{"n":"skeletonDataAsset","pt":$n[4].SkeletonDataAsset,"ps":1},{"n":"material","pt":$n[1].Material,"ps":2}],"sn":"AddSkeletonGraphicComponent","rt":$n[4].SkeletonGraphic,"p":[$n[1].GameObject,$n[4].SkeletonDataAsset,$n[1].Material]},{"a":2,"n":"AfterAnimationApplied","t":8,"sn":"AfterAnimationApplied","rt":$n[0].Void},{"a":3,"n":"ApplyAnimation","t":8,"sn":"ApplyAnimation","rt":$n[0].Void},{"ov":true,"a":3,"n":"Awake","t":8,"sn":"Awake","rt":$n[0].Void},{"a":2,"n":"Clear","t":8,"sn":"Clear","rt":$n[0].Void},{"a":3,"n":"DestroyMeshes","t":8,"sn":"DestroyMeshes","rt":$n[0].Void},{"a":3,"n":"DisableUnusedCanvasRenderers","t":8,"pi":[{"n":"usedCount","pt":$n[0].Int32,"ps":0},{"n":"isInRebuild","dv":false,"o":true,"pt":$n[0].Boolean,"ps":1}],"sn":"DisableUnusedCanvasRenderers","rt":$n[0].Void,"p":[$n[0].Int32,$n[0].Boolean]},{"a":3,"n":"DisposeMeshBuffers","t":8,"sn":"DisposeMeshBuffers","rt":$n[0].Void},{"a":3,"n":"EnsureCanvasRendererCount","t":8,"pi":[{"n":"targetCount","pt":$n[0].Int32,"ps":0}],"sn":"EnsureCanvasRendererCount","rt":$n[0].Void,"p":[$n[0].Int32]},{"a":3,"n":"EnsureMeshesCount","t":8,"pi":[{"n":"targetCount","pt":$n[0].Int32,"ps":0}],"sn":"EnsureMeshesCount","rt":$n[0].Void,"p":[$n[0].Int32]},{"a":3,"n":"EnsureSeparatorPartCount","t":8,"sn":"EnsureSeparatorPartCount","rt":$n[0].Void},{"a":3,"n":"EnsureUsedTexturesAndMaterialsCount","t":8,"pi":[{"n":"targetCount","pt":$n[0].Int32,"ps":0}],"sn":"EnsureUsedTexturesAndMaterialsCount","rt":$n[0].Void,"p":[$n[0].Int32]},{"v":true,"a":3,"n":"FixedUpdate","t":8,"sn":"FixedUpdate","rt":$n[0].Void},{"a":1,"n":"GetCurrentRectSize","t":8,"sn":"GetCurrentRectSize","rt":$n[1].Vector2},{"a":2,"n":"GetLastMesh","t":8,"sn":"GetLastMesh","rt":$n[1].Mesh},{"a":3,"n":"GetLayoutScale","t":8,"pi":[{"n":"mode","pt":$n[4].SkeletonGraphic.LayoutMode,"ps":0}],"sn":"GetLayoutScale","rt":$n[0].Single,"p":[$n[4].SkeletonGraphic.LayoutMode],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"HandleOnDemandLoading","t":8,"sn":"HandleOnDemandLoading","rt":$n[0].Void},{"a":2,"n":"HasMultipleSubmeshInstructions","t":8,"sn":"HasMultipleSubmeshInstructions","rt":$n[0].Boolean,"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":3,"n":"InitMeshBuffers","t":8,"sn":"InitMeshBuffers","rt":$n[0].Void},{"a":2,"n":"Initialize","t":8,"pi":[{"n":"overwrite","pt":$n[0].Boolean,"ps":0}],"sn":"Initialize","rt":$n[0].Void,"p":[$n[0].Boolean]},{"a":2,"n":"LateUpdate","t":8,"sn":"LateUpdate","rt":$n[0].Void},{"a":3,"n":"MatchRectTransformMultipleRenderers","t":8,"sn":"MatchRectTransformMultipleRenderers","rt":$n[0].Boolean,"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":3,"n":"MatchRectTransformSingleRenderer","t":8,"sn":"MatchRectTransformSingleRenderer","rt":$n[0].Boolean,"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"MatchRectTransformWithBounds","t":8,"sn":"MatchRectTransformWithBounds","rt":$n[0].Boolean,"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"NewSkeletonGraphicGameObject","is":true,"t":8,"pi":[{"n":"skeletonDataAsset","pt":$n[4].SkeletonDataAsset,"ps":0},{"n":"parent","pt":$n[1].Transform,"ps":1},{"n":"material","pt":$n[1].Material,"ps":2}],"sn":"NewSkeletonGraphicGameObject","rt":$n[4].SkeletonGraphic,"p":[$n[4].SkeletonDataAsset,$n[1].Transform,$n[1].Material]},{"a":2,"n":"OnBecameInvisible","t":8,"sn":"OnBecameInvisible","rt":$n[0].Void},{"a":2,"n":"OnBecameVisible","t":8,"sn":"OnBecameVisible","rt":$n[0].Void},{"a":3,"n":"OnCullStateChanged","t":8,"pi":[{"n":"culled","pt":$n[0].Boolean,"ps":0}],"sn":"OnCullStateChanged","rt":$n[0].Void,"p":[$n[0].Boolean]},{"ov":true,"a":3,"n":"OnDestroy","t":8,"sn":"OnDestroy","rt":$n[0].Void},{"ov":true,"a":3,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"a":2,"n":"PrepareInstructionsAndRenderers","t":8,"pi":[{"n":"isInRebuild","dv":false,"o":true,"pt":$n[0].Boolean,"ps":0}],"sn":"PrepareInstructionsAndRenderers","rt":$n[0].Void,"p":[$n[0].Boolean]},{"a":3,"n":"PrepareRendererGameObjects","t":8,"pi":[{"n":"currentInstructions","pt":$n[4].SkeletonRendererInstruction,"ps":0},{"n":"isInRebuild","dv":false,"o":true,"pt":$n[0].Boolean,"ps":1}],"sn":"PrepareRendererGameObjects","rt":$n[0].Void,"p":[$n[4].SkeletonRendererInstruction,$n[0].Boolean]},{"a":2,"n":"ReapplySeparatorSlotNames","t":8,"sn":"ReapplySeparatorSlotNames","rt":$n[0].Void},{"ov":true,"a":2,"n":"Rebuild","t":8,"pi":[{"n":"update","pt":$n[2].CanvasUpdate,"ps":0}],"sn":"Rebuild","rt":$n[0].Void,"p":[$n[2].CanvasUpdate]},{"a":1,"n":"SetRectTransformBounds","t":8,"pi":[{"n":"combinedBounds","pt":$n[1].Bounds,"ps":0}],"sn":"SetRectTransformBounds","rt":$n[0].Void,"p":[$n[1].Bounds]},{"a":2,"n":"SetRectTransformSize","is":true,"t":8,"pi":[{"n":"targetRectTransform","pt":$n[1].RectTransform,"ps":0},{"n":"size","pt":$n[1].Vector2,"ps":1}],"sn":"SetRectTransformSize","rt":$n[0].Void,"p":[$n[1].RectTransform,$n[1].Vector2]},{"a":2,"n":"SetRectTransformSize","is":true,"t":8,"pi":[{"n":"target","pt":$n[2].Graphic,"ps":0},{"n":"size","pt":$n[1].Vector2,"ps":1}],"sn":"SetRectTransformSize$1","rt":$n[0].Void,"p":[$n[2].Graphic,$n[1].Vector2]},{"a":3,"n":"SyncSubmeshGraphicsWithCanvasRenderers","t":8,"sn":"SyncSubmeshGraphicsWithCanvasRenderers","rt":$n[0].Void},{"a":2,"n":"TrimRenderers","t":8,"sn":"TrimRenderers","rt":$n[0].Void},{"v":true,"a":2,"n":"Update","t":8,"sn":"Update","rt":$n[0].Void},{"v":true,"a":2,"n":"Update","t":8,"pi":[{"n":"deltaTime","pt":$n[0].Single,"ps":0}],"sn":"Update$1","rt":$n[0].Void,"p":[$n[0].Single]},{"a":3,"n":"UpdateAnimationStatus","t":8,"pi":[{"n":"deltaTime","pt":$n[0].Single,"ps":0}],"sn":"UpdateAnimationStatus","rt":$n[0].Void,"p":[$n[0].Single]},{"a":3,"n":"UpdateMaterialsMultipleCanvasRenderers","t":8,"pi":[{"n":"currentInstructions","pt":$n[4].SkeletonRendererInstruction,"ps":0}],"sn":"UpdateMaterialsMultipleCanvasRenderers","rt":$n[0].Void,"p":[$n[4].SkeletonRendererInstruction]},{"a":2,"n":"UpdateMesh","t":8,"sn":"UpdateMesh","rt":$n[0].Void},{"a":3,"n":"UpdateMeshMultipleCanvasRenderers","t":8,"pi":[{"n":"currentInstructions","pt":$n[4].SkeletonRendererInstruction,"ps":0}],"sn":"UpdateMeshMultipleCanvasRenderers","rt":$n[0].Void,"p":[$n[4].SkeletonRendererInstruction]},{"a":3,"n":"UpdateMeshSingleCanvasRenderer","t":8,"pi":[{"n":"currentInstructions","pt":$n[4].SkeletonRendererInstruction,"ps":0}],"sn":"UpdateMeshSingleCanvasRenderer","rt":$n[0].Void,"p":[$n[4].SkeletonRendererInstruction]},{"a":2,"n":"UpdateMeshToInstructions","t":8,"sn":"UpdateMeshToInstructions","rt":$n[0].Void},{"a":3,"n":"UpdateSeparatorPartParents","t":8,"sn":"UpdateSeparatorPartParents","rt":$n[0].Void},{"a":2,"n":"AnimationState","t":16,"rt":$n[3].AnimationState,"g":{"a":2,"n":"get_AnimationState","t":8,"rt":$n[3].AnimationState,"fg":"AnimationState"},"fn":"AnimationState"},{"a":2,"n":"CustomMaterialOverride","t":16,"rt":$n[5].Dictionary$2(UnityEngine.Texture,UnityEngine.Material),"g":{"a":2,"n":"get_CustomMaterialOverride","t":8,"rt":$n[5].Dictionary$2(UnityEngine.Texture,UnityEngine.Material),"fg":"CustomMaterialOverride"},"fn":"CustomMaterialOverride"},{"a":2,"n":"CustomTextureOverride","t":16,"rt":$n[5].Dictionary$2(UnityEngine.Texture,UnityEngine.Texture),"g":{"a":2,"n":"get_CustomTextureOverride","t":8,"rt":$n[5].Dictionary$2(UnityEngine.Texture,UnityEngine.Texture),"fg":"CustomTextureOverride"},"fn":"CustomTextureOverride"},{"a":2,"n":"IsValid","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_IsValid","t":8,"rt":$n[0].Boolean,"fg":"IsValid","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"IsValid"},{"a":2,"n":"MaterialsMultipleCanvasRenderers","t":16,"rt":$n[3].ExposedList$1(UnityEngine.Material),"g":{"a":2,"n":"get_MaterialsMultipleCanvasRenderers","t":8,"rt":$n[3].ExposedList$1(UnityEngine.Material),"fg":"MaterialsMultipleCanvasRenderers"},"fn":"MaterialsMultipleCanvasRenderers"},{"a":2,"n":"MeshGenerator","t":16,"rt":$n[4].MeshGenerator,"g":{"a":2,"n":"get_MeshGenerator","t":8,"rt":$n[4].MeshGenerator,"fg":"MeshGenerator"},"fn":"MeshGenerator"},{"a":2,"n":"MeshScale","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_MeshScale","t":8,"rt":$n[0].Single,"fg":"MeshScale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"fn":"MeshScale"},{"a":2,"n":"MeshesMultipleCanvasRenderers","t":16,"rt":$n[3].ExposedList$1(UnityEngine.Mesh),"g":{"a":2,"n":"get_MeshesMultipleCanvasRenderers","t":8,"rt":$n[3].ExposedList$1(UnityEngine.Mesh),"fg":"MeshesMultipleCanvasRenderers"},"fn":"MeshesMultipleCanvasRenderers"},{"a":2,"n":"OverrideTexture","t":16,"rt":$n[1].Texture,"g":{"a":2,"n":"get_OverrideTexture","t":8,"rt":$n[1].Texture,"fg":"OverrideTexture"},"s":{"a":2,"n":"set_OverrideTexture","t":8,"p":[$n[1].Texture],"rt":$n[0].Void,"fs":"OverrideTexture"},"fn":"OverrideTexture"},{"a":2,"n":"SeparatorParts","t":16,"rt":$n[5].List$1(UnityEngine.Transform),"g":{"a":2,"n":"get_SeparatorParts","t":8,"rt":$n[5].List$1(UnityEngine.Transform),"fg":"SeparatorParts"},"fn":"SeparatorParts"},{"a":2,"n":"Skeleton","t":16,"rt":$n[3].Skeleton,"g":{"a":2,"n":"get_Skeleton","t":8,"rt":$n[3].Skeleton,"fg":"Skeleton"},"s":{"a":2,"n":"set_Skeleton","t":8,"p":[$n[3].Skeleton],"rt":$n[0].Void,"fs":"Skeleton"},"fn":"Skeleton"},{"a":2,"n":"SkeletonData","t":16,"rt":$n[3].SkeletonData,"g":{"a":2,"n":"get_SkeletonData","t":8,"rt":$n[3].SkeletonData,"fg":"SkeletonData"},"fn":"SkeletonData"},{"a":2,"n":"SkeletonDataAsset","t":16,"rt":$n[4].SkeletonDataAsset,"g":{"a":2,"n":"get_SkeletonDataAsset","t":8,"rt":$n[4].SkeletonDataAsset,"fg":"SkeletonDataAsset"},"fn":"SkeletonDataAsset"},{"a":2,"n":"TexturesMultipleCanvasRenderers","t":16,"rt":$n[3].ExposedList$1(UnityEngine.Texture),"g":{"a":2,"n":"get_TexturesMultipleCanvasRenderers","t":8,"rt":$n[3].ExposedList$1(UnityEngine.Texture),"fg":"TexturesMultipleCanvasRenderers"},"fn":"TexturesMultipleCanvasRenderers"},{"a":2,"n":"UnscaledTime","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_UnscaledTime","t":8,"rt":$n[0].Boolean,"fg":"UnscaledTime","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_UnscaledTime","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"UnscaledTime"},"fn":"UnscaledTime"},{"a":2,"n":"UpdateMode","t":16,"rt":$n[4].UpdateMode,"g":{"a":2,"n":"get_UpdateMode","t":8,"rt":$n[4].UpdateMode,"fg":"UpdateMode","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateMode, System.Enum.toStringFn(Spine.Unity.UpdateMode));}},"s":{"a":2,"n":"set_UpdateMode","t":8,"p":[$n[4].UpdateMode],"rt":$n[0].Void,"fs":"UpdateMode"},"fn":"UpdateMode"},{"a":2,"n":"UpdateTiming","t":16,"rt":$n[4].UpdateTiming,"g":{"a":2,"n":"get_UpdateTiming","t":8,"rt":$n[4].UpdateTiming,"fg":"UpdateTiming","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateTiming, System.Enum.toStringFn(Spine.Unity.UpdateTiming));}},"s":{"a":2,"n":"set_UpdateTiming","t":8,"p":[$n[4].UpdateTiming],"rt":$n[0].Void,"fs":"UpdateTiming"},"fn":"UpdateTiming"},{"ov":true,"a":2,"n":"mainTexture","t":16,"rt":$n[1].Texture,"g":{"ov":true,"a":2,"n":"get_mainTexture","t":8,"rt":$n[1].Texture,"fg":"mainTexture"},"fn":"mainTexture"},{"a":3,"n":"EditReferenceRect","is":true,"t":4,"rt":$n[0].Boolean,"sn":"EditReferenceRect","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"SeparatorPartGameObjectName","is":true,"t":4,"rt":$n[0].String,"sn":"SeparatorPartGameObjectName"},{"a":2,"n":"additiveMaterial","t":4,"rt":$n[1].Material,"sn":"additiveMaterial"},{"a":2,"n":"allowMultipleCanvasRenderers","t":4,"rt":$n[0].Boolean,"sn":"allowMultipleCanvasRenderers","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"baseTexture","t":4,"rt":$n[1].Texture,"sn":"baseTexture"},{"a":2,"n":"canvasRenderers","t":4,"rt":$n[5].List$1(UnityEngine.CanvasRenderer),"sn":"canvasRenderers"},{"a":1,"n":"currentInstructions","t":4,"rt":$n[4].SkeletonRendererInstruction,"sn":"currentInstructions"},{"a":1,"n":"customMaterialOverride","t":4,"rt":$n[5].Dictionary$2(UnityEngine.Texture,UnityEngine.Material),"sn":"customMaterialOverride","ro":true},{"a":1,"n":"customTextureOverride","t":4,"rt":$n[5].Dictionary$2(UnityEngine.Texture,UnityEngine.Texture),"sn":"customTextureOverride","ro":true},{"a":2,"n":"disableMeshAssignmentOnOverride","t":4,"rt":$n[0].Boolean,"sn":"disableMeshAssignmentOnOverride","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"enableSeparatorSlots","t":4,"rt":$n[0].Boolean,"sn":"enableSeparatorSlots","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"freeze","t":4,"rt":$n[0].Boolean,"sn":"freeze","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"initialFlipX","t":4,"rt":$n[0].Boolean,"sn":"initialFlipX","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"initialFlipY","t":4,"rt":$n[0].Boolean,"sn":"initialFlipY","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new Spine.Unity.SpineSkin("", "skeletonDataAsset", true, false, true)],"a":2,"n":"initialSkinName","t":4,"rt":$n[0].String,"sn":"initialSkinName"},{"a":2,"n":"layoutScaleMode","t":4,"rt":$n[4].SkeletonGraphic.LayoutMode,"sn":"layoutScaleMode","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonGraphic.LayoutMode, System.Enum.toStringFn(Spine.Unity.SkeletonGraphic.LayoutMode));}},{"a":1,"n":"meshBuffers","t":4,"rt":$n[4].DoubleBuffered$1(Spine.Unity.MeshRendererBuffers.SmartMesh),"sn":"meshBuffers"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"meshGenerator","t":4,"rt":$n[4].MeshGenerator,"sn":"meshGenerator"},{"a":3,"n":"meshScale","t":4,"rt":$n[0].Single,"sn":"meshScale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"meshes","t":4,"rt":$n[3].ExposedList$1(UnityEngine.Mesh),"sn":"meshes","ro":true},{"a":2,"n":"multiplyMaterial","t":4,"rt":$n[1].Material,"sn":"multiplyMaterial"},{"a":1,"n":"overrideTexture","t":4,"rt":$n[1].Texture,"sn":"overrideTexture"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"referenceScale","t":4,"rt":$n[0].Single,"sn":"referenceScale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"referenceSize","t":4,"rt":$n[1].Vector2,"sn":"referenceSize"},{"a":2,"n":"screenMaterial","t":4,"rt":$n[1].Material,"sn":"screenMaterial"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"separatorParts","t":4,"rt":$n[5].List$1(UnityEngine.Transform),"sn":"separatorParts"},{"at":[new UnityEngine.SerializeFieldAttribute(),new Spine.Unity.SpineSlot("", "", false, true, false)],"a":3,"n":"separatorSlotNames","t":4,"rt":$n[0].Array.type(System.String),"sn":"separatorSlotNames"},{"a":2,"n":"separatorSlots","t":4,"rt":$n[5].List$1(Spine.Slot),"sn":"separatorSlots","ro":true},{"a":3,"n":"skeleton","t":4,"rt":$n[3].Skeleton,"sn":"skeleton"},{"a":2,"n":"skeletonDataAsset","t":4,"rt":$n[4].SkeletonDataAsset,"sn":"skeletonDataAsset"},{"at":[new Spine.Unity.SpineAnimation("", "skeletonDataAsset", true, false)],"a":2,"n":"startingAnimation","t":4,"rt":$n[0].String,"sn":"startingAnimation"},{"a":2,"n":"startingLoop","t":4,"rt":$n[0].Boolean,"sn":"startingLoop","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":3,"n":"state","t":4,"rt":$n[3].AnimationState,"sn":"state"},{"a":3,"n":"submeshGraphics","t":4,"rt":$n[5].List$1(Spine.Unity.SkeletonSubmeshGraphic),"sn":"submeshGraphics"},{"a":2,"n":"timeScale","t":4,"rt":$n[0].Single,"sn":"timeScale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"unscaledTime","t":4,"rt":$n[0].Boolean,"sn":"unscaledTime","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":3,"n":"updateMode","t":4,"rt":$n[4].UpdateMode,"sn":"updateMode","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateMode, System.Enum.toStringFn(Spine.Unity.UpdateMode));}},{"a":2,"n":"updateSeparatorPartLocation","t":4,"rt":$n[0].Boolean,"sn":"updateSeparatorPartLocation","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"updateSeparatorPartScale","t":4,"rt":$n[0].Boolean,"sn":"updateSeparatorPartScale","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"updateTiming","t":4,"rt":$n[4].UpdateTiming,"sn":"updateTiming","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateTiming, System.Enum.toStringFn(Spine.Unity.UpdateTiming));}},{"a":2,"n":"updateWhenInvisible","t":4,"rt":$n[4].UpdateMode,"sn":"updateWhenInvisible","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateMode, System.Enum.toStringFn(Spine.Unity.UpdateMode));}},{"a":1,"n":"usedMaterials","t":4,"rt":$n[3].ExposedList$1(UnityEngine.Material),"sn":"usedMaterials","ro":true},{"a":3,"n":"usedRenderersCount","t":4,"rt":$n[0].Int32,"sn":"usedRenderersCount","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"usedTextures","t":4,"rt":$n[3].ExposedList$1(UnityEngine.Texture),"sn":"usedTextures","ro":true},{"a":1,"n":"wasUpdatedAfterInit","t":4,"rt":$n[0].Boolean,"sn":"wasUpdatedAfterInit","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"AssignMeshOverrideMultipleRenderers","t":2,"ad":{"a":2,"n":"add_AssignMeshOverrideMultipleRenderers","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addAssignMeshOverrideMultipleRenderers","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_AssignMeshOverrideMultipleRenderers","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeAssignMeshOverrideMultipleRenderers","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"AssignMeshOverrideSingleRenderer","t":2,"ad":{"a":2,"n":"add_AssignMeshOverrideSingleRenderer","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addAssignMeshOverrideSingleRenderer","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_AssignMeshOverrideSingleRenderer","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeAssignMeshOverrideSingleRenderer","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"BeforeApply","t":2,"ad":{"a":2,"n":"add_BeforeApply","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addBeforeApply","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_BeforeApply","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeBeforeApply","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"OnAnimationRebuild","t":2,"ad":{"a":2,"n":"add_OnAnimationRebuild","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnAnimationRebuild","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_OnAnimationRebuild","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnAnimationRebuild","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"OnInstructionsPrepared","t":2,"ad":{"a":2,"n":"add_OnInstructionsPrepared","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnInstructionsPrepared","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_OnInstructionsPrepared","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnInstructionsPrepared","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"OnMeshAndMaterialsUpdated","t":2,"ad":{"a":2,"n":"add_OnMeshAndMaterialsUpdated","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnMeshAndMaterialsUpdated","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_OnMeshAndMaterialsUpdated","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnMeshAndMaterialsUpdated","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"OnPostProcessVertices","t":2,"ad":{"a":2,"n":"add_OnPostProcessVertices","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnPostProcessVertices","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_OnPostProcessVertices","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnPostProcessVertices","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"OnRebuild","t":2,"ad":{"a":2,"n":"add_OnRebuild","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnRebuild","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_OnRebuild","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnRebuild","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"UpdateComplete","t":2,"ad":{"a":2,"n":"add_UpdateComplete","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addUpdateComplete","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_UpdateComplete","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeUpdateComplete","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"UpdateLocal","t":2,"ad":{"a":2,"n":"add_UpdateLocal","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addUpdateLocal","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_UpdateLocal","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeUpdateLocal","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"UpdateWorld","t":2,"ad":{"a":2,"n":"add_UpdateWorld","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addUpdateWorld","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_UpdateWorld","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeUpdateWorld","rt":$n[0].Void,"p":[Function]}},{"a":1,"n":"assignMeshOverrideMultiple","t":2,"ad":{"a":1,"n":"add_assignMeshOverrideMultiple","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addassignMeshOverrideMultiple","rt":$n[0].Void,"p":[Function]},"r":{"a":1,"n":"remove_assignMeshOverrideMultiple","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeassignMeshOverrideMultiple","rt":$n[0].Void,"p":[Function]}},{"a":1,"n":"assignMeshOverrideSingle","t":2,"ad":{"a":1,"n":"add_assignMeshOverrideSingle","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addassignMeshOverrideSingle","rt":$n[0].Void,"p":[Function]},"r":{"a":1,"n":"remove_assignMeshOverrideSingle","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeassignMeshOverrideSingle","rt":$n[0].Void,"p":[Function]}}]}; }, $n);
    /*Spine.Unity.SkeletonGraphic end.*/

    /*Spine.Unity.SkeletonGraphic+LayoutMode start.*/
    $m("Spine.Unity.SkeletonGraphic.LayoutMode", function () { return {"td":$n[4].SkeletonGraphic,"att":258,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"EnvelopeParent","is":true,"t":4,"rt":$n[4].SkeletonGraphic.LayoutMode,"sn":"EnvelopeParent","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonGraphic.LayoutMode, System.Enum.toStringFn(Spine.Unity.SkeletonGraphic.LayoutMode));}},{"a":2,"n":"FitInParent","is":true,"t":4,"rt":$n[4].SkeletonGraphic.LayoutMode,"sn":"FitInParent","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonGraphic.LayoutMode, System.Enum.toStringFn(Spine.Unity.SkeletonGraphic.LayoutMode));}},{"a":2,"n":"HeightControlsWidth","is":true,"t":4,"rt":$n[4].SkeletonGraphic.LayoutMode,"sn":"HeightControlsWidth","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonGraphic.LayoutMode, System.Enum.toStringFn(Spine.Unity.SkeletonGraphic.LayoutMode));}},{"a":2,"n":"None","is":true,"t":4,"rt":$n[4].SkeletonGraphic.LayoutMode,"sn":"None","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonGraphic.LayoutMode, System.Enum.toStringFn(Spine.Unity.SkeletonGraphic.LayoutMode));}},{"a":2,"n":"WidthControlsHeight","is":true,"t":4,"rt":$n[4].SkeletonGraphic.LayoutMode,"sn":"WidthControlsHeight","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonGraphic.LayoutMode, System.Enum.toStringFn(Spine.Unity.SkeletonGraphic.LayoutMode));}}]}; }, $n);
    /*Spine.Unity.SkeletonGraphic+LayoutMode end.*/

    /*Spine.Unity.SkeletonMecanim start.*/
    $m("Spine.Unity.SkeletonMecanim", function () { return {"nested":[$n[4].SkeletonMecanim.MecanimTranslator],"att":1048577,"a":2,"at":[new UnityEngine.RequireComponent.ctor(UnityEngine.Animator),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#SkeletonMecanim-Component")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":3,"n":"ApplyAnimation","t":8,"sn":"ApplyAnimation","rt":$n[0].Void},{"v":true,"a":2,"n":"FixedUpdate","t":8,"sn":"FixedUpdate","rt":$n[0].Void},{"ov":true,"a":2,"n":"Initialize","t":8,"pi":[{"n":"overwrite","pt":$n[0].Boolean,"ps":0},{"n":"quiet","dv":false,"o":true,"pt":$n[0].Boolean,"ps":1}],"sn":"Initialize","rt":$n[0].Void,"p":[$n[0].Boolean,$n[0].Boolean]},{"ov":true,"a":2,"n":"LateUpdate","t":8,"sn":"LateUpdate","rt":$n[0].Void},{"ov":true,"a":2,"n":"OnBecameVisible","t":8,"sn":"OnBecameVisible","rt":$n[0].Void},{"v":true,"a":2,"n":"Update","t":8,"sn":"Update","rt":$n[0].Void},{"v":true,"a":2,"n":"Update","t":8,"pi":[{"n":"deltaTime","pt":$n[0].Single,"ps":0}],"sn":"Update$1","rt":$n[0].Void,"p":[$n[0].Single]},{"a":3,"n":"UpdateAnimation","t":8,"sn":"UpdateAnimation","rt":$n[0].Void},{"a":2,"n":"Translator","t":16,"rt":$n[4].SkeletonMecanim.MecanimTranslator,"g":{"a":2,"n":"get_Translator","t":8,"rt":$n[4].SkeletonMecanim.MecanimTranslator,"fg":"Translator"},"fn":"Translator"},{"a":2,"n":"UpdateTiming","t":16,"rt":$n[4].UpdateTiming,"g":{"a":2,"n":"get_UpdateTiming","t":8,"rt":$n[4].UpdateTiming,"fg":"UpdateTiming","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateTiming, System.Enum.toStringFn(Spine.Unity.UpdateTiming));}},"s":{"a":2,"n":"set_UpdateTiming","t":8,"p":[$n[4].UpdateTiming],"rt":$n[0].Void,"fs":"UpdateTiming"},"fn":"UpdateTiming"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"translator","t":4,"rt":$n[4].SkeletonMecanim.MecanimTranslator,"sn":"translator"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"updateTiming","t":4,"rt":$n[4].UpdateTiming,"sn":"updateTiming","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateTiming, System.Enum.toStringFn(Spine.Unity.UpdateTiming));}},{"a":1,"n":"wasUpdatedAfterInit","t":4,"rt":$n[0].Boolean,"sn":"wasUpdatedAfterInit","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"BeforeApply","t":2,"ad":{"a":2,"n":"add_BeforeApply","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addBeforeApply","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_BeforeApply","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeBeforeApply","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"OnAnimationRebuild","t":2,"ad":{"a":2,"n":"add_OnAnimationRebuild","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnAnimationRebuild","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_OnAnimationRebuild","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnAnimationRebuild","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"UpdateComplete","t":2,"ad":{"a":2,"n":"add_UpdateComplete","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addUpdateComplete","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_UpdateComplete","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeUpdateComplete","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"UpdateLocal","t":2,"ad":{"a":2,"n":"add_UpdateLocal","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addUpdateLocal","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_UpdateLocal","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeUpdateLocal","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"UpdateWorld","t":2,"ad":{"a":2,"n":"add_UpdateWorld","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addUpdateWorld","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_UpdateWorld","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeUpdateWorld","rt":$n[0].Void,"p":[Function]}},{"a":3,"n":"_BeforeApply","t":2,"ad":{"a":3,"n":"add__BeforeApply","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"add_BeforeApply","rt":$n[0].Void,"p":[Function]},"r":{"a":3,"n":"remove__BeforeApply","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"remove_BeforeApply","rt":$n[0].Void,"p":[Function]}},{"a":3,"n":"_OnAnimationRebuild","t":2,"ad":{"a":3,"n":"add__OnAnimationRebuild","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"add_OnAnimationRebuild","rt":$n[0].Void,"p":[Function]},"r":{"a":3,"n":"remove__OnAnimationRebuild","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"remove_OnAnimationRebuild","rt":$n[0].Void,"p":[Function]}},{"a":3,"n":"_UpdateComplete","t":2,"ad":{"a":3,"n":"add__UpdateComplete","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"add_UpdateComplete","rt":$n[0].Void,"p":[Function]},"r":{"a":3,"n":"remove__UpdateComplete","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"remove_UpdateComplete","rt":$n[0].Void,"p":[Function]}},{"a":3,"n":"_UpdateLocal","t":2,"ad":{"a":3,"n":"add__UpdateLocal","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"add_UpdateLocal","rt":$n[0].Void,"p":[Function]},"r":{"a":3,"n":"remove__UpdateLocal","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"remove_UpdateLocal","rt":$n[0].Void,"p":[Function]}},{"a":3,"n":"_UpdateWorld","t":2,"ad":{"a":3,"n":"add__UpdateWorld","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"add_UpdateWorld","rt":$n[0].Void,"p":[Function]},"r":{"a":3,"n":"remove__UpdateWorld","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"remove_UpdateWorld","rt":$n[0].Void,"p":[Function]}}]}; }, $n);
    /*Spine.Unity.SkeletonMecanim end.*/

    /*Spine.Unity.SkeletonMecanim+MecanimTranslator start.*/
    $m("Spine.Unity.SkeletonMecanim.MecanimTranslator", function () { return {"td":$n[4].SkeletonMecanim,"nested":[Function,$n[4].SkeletonMecanim.MecanimTranslator.MixMode,$n[4].SkeletonMecanim.MecanimTranslator.ClipInfos,$n[4].SkeletonMecanim.MecanimTranslator.AnimationClipEqualityComparer,$n[4].SkeletonMecanim.MecanimTranslator.IntEqualityComparer],"att":1056770,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"AnimationTime","is":true,"t":8,"pi":[{"n":"normalizedTime","pt":$n[0].Single,"ps":0},{"n":"clipLength","pt":$n[0].Single,"ps":1},{"n":"loop","pt":$n[0].Boolean,"ps":2},{"n":"reversed","pt":$n[0].Boolean,"ps":3}],"sn":"AnimationTime","rt":$n[0].Single,"p":[$n[0].Single,$n[0].Single,$n[0].Boolean,$n[0].Boolean],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"Apply","t":8,"pi":[{"n":"skeleton","pt":$n[3].Skeleton,"ps":0}],"sn":"Apply","rt":$n[0].Void,"p":[$n[3].Skeleton]},{"a":1,"n":"ApplyAnimation","t":8,"pi":[{"n":"skeleton","pt":$n[3].Skeleton,"ps":0},{"n":"info","pt":$n[1].AnimatorClipInfo,"ps":1},{"n":"stateInfo","pt":$n[1].AnimatorStateInfo,"ps":2},{"n":"layerIndex","pt":$n[0].Int32,"ps":3},{"n":"layerWeight","pt":$n[0].Single,"ps":4},{"n":"layerBlendMode","pt":spine.MixBlend,"ps":5},{"n":"useClipWeight1","dv":false,"o":true,"pt":$n[0].Boolean,"ps":6}],"sn":"ApplyAnimation","rt":$n[0].Boolean,"p":[$n[3].Skeleton,$n[1].AnimatorClipInfo,$n[1].AnimatorStateInfo,$n[0].Int32,$n[0].Single,spine.MixBlend,$n[0].Boolean],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"ApplyInterruptionAnimation","t":8,"pi":[{"n":"skeleton","pt":$n[3].Skeleton,"ps":0},{"n":"interpolateWeightTo1","pt":$n[0].Boolean,"ps":1},{"n":"info","pt":$n[1].AnimatorClipInfo,"ps":2},{"n":"stateInfo","pt":$n[1].AnimatorStateInfo,"ps":3},{"n":"layerIndex","pt":$n[0].Int32,"ps":4},{"n":"layerWeight","pt":$n[0].Single,"ps":5},{"n":"layerBlendMode","pt":spine.MixBlend,"ps":6},{"n":"interruptingClipTimeAddition","pt":$n[0].Single,"ps":7},{"n":"useClipWeight1","dv":false,"o":true,"pt":$n[0].Boolean,"ps":8}],"sn":"ApplyInterruptionAnimation","rt":$n[0].Boolean,"p":[$n[3].Skeleton,$n[0].Boolean,$n[1].AnimatorClipInfo,$n[1].AnimatorStateInfo,$n[0].Int32,$n[0].Single,spine.MixBlend,$n[0].Single,$n[0].Boolean],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"ClearClipInfosForLayers","t":8,"sn":"ClearClipInfosForLayers","rt":$n[0].Void},{"a":2,"n":"GetActiveAnimationAndTime","t":8,"pi":[{"n":"layer","pt":$n[0].Int32,"ps":0}],"sn":"GetActiveAnimationAndTime","rt":$n[5].KeyValuePair$2(Spine.Animation,System.Single),"p":[$n[0].Int32]},{"a":1,"n":"GetAnimation","t":8,"pi":[{"n":"clip","pt":$n[1].AnimationClip,"ps":0}],"sn":"GetAnimation","rt":$n[3].Animation,"p":[$n[1].AnimationClip]},{"a":1,"n":"GetAnimatorClipInfos","t":8,"pi":[{"n":"layer","pt":$n[0].Int32,"ps":0},{"n":"isInterruptionActive","out":true,"pt":$n[0].Boolean,"ps":1},{"n":"clipInfoCount","out":true,"pt":$n[0].Int32,"ps":2},{"n":"nextClipInfoCount","out":true,"pt":$n[0].Int32,"ps":3},{"n":"interruptingClipInfoCount","out":true,"pt":$n[0].Int32,"ps":4},{"n":"clipInfo","out":true,"pt":$n[5].IList$1(UnityEngine.AnimatorClipInfo),"ps":5},{"n":"nextClipInfo","out":true,"pt":$n[5].IList$1(UnityEngine.AnimatorClipInfo),"ps":6},{"n":"interruptingClipInfo","out":true,"pt":$n[5].IList$1(UnityEngine.AnimatorClipInfo),"ps":7},{"n":"shallInterpolateWeightTo1","out":true,"pt":$n[0].Boolean,"ps":8}],"sn":"GetAnimatorClipInfos","rt":$n[0].Void,"p":[$n[0].Int32,$n[0].Boolean,$n[0].Int32,$n[0].Int32,$n[0].Int32,$n[5].IList$1(UnityEngine.AnimatorClipInfo),$n[5].IList$1(UnityEngine.AnimatorClipInfo),$n[5].IList$1(UnityEngine.AnimatorClipInfo),$n[0].Boolean]},{"a":1,"n":"GetAnimatorStateInfos","t":8,"pi":[{"n":"layer","pt":$n[0].Int32,"ps":0},{"n":"isInterruptionActive","out":true,"pt":$n[0].Boolean,"ps":1},{"n":"stateInfo","out":true,"pt":$n[1].AnimatorStateInfo,"ps":2},{"n":"nextStateInfo","out":true,"pt":$n[1].AnimatorStateInfo,"ps":3},{"n":"interruptingStateInfo","out":true,"pt":$n[1].AnimatorStateInfo,"ps":4},{"n":"interruptingClipTimeAddition","out":true,"pt":$n[0].Single,"ps":5}],"sn":"GetAnimatorStateInfos","rt":$n[0].Void,"p":[$n[0].Int32,$n[0].Boolean,$n[1].AnimatorStateInfo,$n[1].AnimatorStateInfo,$n[1].AnimatorStateInfo,$n[0].Single]},{"a":1,"n":"GetMixMode","t":8,"pi":[{"n":"layer","pt":$n[0].Int32,"ps":0},{"n":"layerBlendMode","pt":spine.MixBlend,"ps":1}],"sn":"GetMixMode","rt":$n[4].SkeletonMecanim.MecanimTranslator.MixMode,"p":[$n[0].Int32,spine.MixBlend],"box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode, System.Enum.toStringFn(Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode));}},{"a":1,"n":"GetStateUpdatesFromAnimator","t":8,"pi":[{"n":"layer","pt":$n[0].Int32,"ps":0}],"sn":"GetStateUpdatesFromAnimator","rt":$n[0].Void,"p":[$n[0].Int32]},{"a":1,"n":"InitClipInfosForLayers","t":8,"sn":"InitClipInfosForLayers","rt":$n[0].Void},{"a":2,"n":"Initialize","t":8,"pi":[{"n":"animator","pt":$n[1].Animator,"ps":0},{"n":"skeletonDataAsset","pt":$n[4].SkeletonDataAsset,"ps":1}],"sn":"Initialize","rt":$n[0].Void,"p":[$n[1].Animator,$n[4].SkeletonDataAsset]},{"a":1,"n":"OnClipAppliedCallback","t":8,"pi":[{"n":"clip","pt":$n[3].Animation,"ps":0},{"n":"stateInfo","pt":$n[1].AnimatorStateInfo,"ps":1},{"n":"layerIndex","pt":$n[0].Int32,"ps":2},{"n":"time","pt":$n[0].Single,"ps":3},{"n":"isLooping","pt":$n[0].Boolean,"ps":4},{"n":"weight","pt":$n[0].Single,"ps":5}],"sn":"OnClipAppliedCallback","rt":$n[0].Void,"p":[$n[3].Animation,$n[1].AnimatorStateInfo,$n[0].Int32,$n[0].Single,$n[0].Boolean,$n[0].Single]},{"a":1,"n":"ToSpineAnimationTime","is":true,"t":8,"pi":[{"n":"normalizedTime","pt":$n[0].Single,"ps":0},{"n":"clipLength","pt":$n[0].Single,"ps":1},{"n":"loop","pt":$n[0].Boolean,"ps":2},{"n":"reversed","pt":$n[0].Boolean,"ps":3}],"sn":"ToSpineAnimationTime","rt":$n[0].Single,"p":[$n[0].Single,$n[0].Single,$n[0].Boolean,$n[0].Boolean],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"Animator","t":16,"rt":$n[1].Animator,"g":{"a":2,"n":"get_Animator","t":8,"rt":$n[1].Animator,"fg":"Animator"},"fn":"Animator"},{"a":2,"n":"MecanimLayerCount","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_MecanimLayerCount","t":8,"rt":$n[0].Int32,"fg":"MecanimLayerCount","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"MecanimLayerCount"},{"a":2,"n":"MecanimLayerNames","t":16,"rt":$n[0].Array.type(System.String),"g":{"a":2,"n":"get_MecanimLayerNames","t":8,"rt":$n[0].Array.type(System.String),"fg":"MecanimLayerNames"},"fn":"MecanimLayerNames"},{"a":1,"n":"WeightEpsilon","is":true,"t":4,"rt":$n[0].Single,"sn":"WeightEpsilon","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"animationTable","t":4,"rt":$n[5].Dictionary$2(System.Int32,Spine.Animation),"sn":"animationTable","ro":true},{"a":1,"n":"animator","t":4,"rt":$n[1].Animator,"sn":"animator"},{"a":2,"n":"autoReset","t":4,"rt":$n[0].Boolean,"sn":"autoReset","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"clipNameHashCodeTable","t":4,"rt":$n[5].Dictionary$2(UnityEngine.AnimationClip,System.Int32),"sn":"clipNameHashCodeTable","ro":true},{"a":2,"n":"layerBlendModes","t":4,"rt":System.Array.type(spine.MixBlend),"sn":"layerBlendModes"},{"a":3,"n":"layerClipInfos","t":4,"rt":System.Array.type(Spine.Unity.SkeletonMecanim.MecanimTranslator.ClipInfos),"sn":"layerClipInfos"},{"a":2,"n":"layerMixModes","t":4,"rt":System.Array.type(Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode),"sn":"layerMixModes"},{"a":1,"n":"previousAnimations","t":4,"rt":$n[5].List$1(Spine.Animation),"sn":"previousAnimations","ro":true},{"a":2,"n":"useCustomMixMode","t":4,"rt":$n[0].Boolean,"sn":"useCustomMixMode","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"OnClipApplied","t":2,"ad":{"a":2,"n":"add_OnClipApplied","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnClipApplied","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_OnClipApplied","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnClipApplied","rt":$n[0].Void,"p":[Function]}},{"a":3,"n":"_OnClipApplied","t":2,"ad":{"a":3,"n":"add__OnClipApplied","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"add_OnClipApplied","rt":$n[0].Void,"p":[Function]},"r":{"a":3,"n":"remove__OnClipApplied","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"remove_OnClipApplied","rt":$n[0].Void,"p":[Function]}}]}; }, $n);
    /*Spine.Unity.SkeletonMecanim+MecanimTranslator end.*/

    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+MixMode start.*/
    $m("Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode", function () { return {"td":$n[4].SkeletonMecanim.MecanimTranslator,"att":258,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"AlwaysMix","is":true,"t":4,"rt":$n[4].SkeletonMecanim.MecanimTranslator.MixMode,"sn":"AlwaysMix","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode, System.Enum.toStringFn(Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode));}},{"a":2,"n":"Hard","is":true,"t":4,"rt":$n[4].SkeletonMecanim.MecanimTranslator.MixMode,"sn":"Hard","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode, System.Enum.toStringFn(Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode));}},{"a":2,"n":"MixNext","is":true,"t":4,"rt":$n[4].SkeletonMecanim.MecanimTranslator.MixMode,"sn":"MixNext","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode, System.Enum.toStringFn(Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode));}}]}; }, $n);
    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+MixMode end.*/

    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+ClipInfos start.*/
    $m("Spine.Unity.SkeletonMecanim.MecanimTranslator.ClipInfos", function () { return {"td":$n[4].SkeletonMecanim.MecanimTranslator,"att":1048580,"a":3,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"clipInfoCount","t":4,"rt":$n[0].Int32,"sn":"clipInfoCount","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"clipInfos","t":4,"rt":$n[5].List$1(UnityEngine.AnimatorClipInfo),"sn":"clipInfos","ro":true},{"a":2,"n":"interruptingClipInfoCount","t":4,"rt":$n[0].Int32,"sn":"interruptingClipInfoCount","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"interruptingClipInfos","t":4,"rt":$n[5].List$1(UnityEngine.AnimatorClipInfo),"sn":"interruptingClipInfos","ro":true},{"a":2,"n":"interruptingClipTimeAddition","t":4,"rt":$n[0].Single,"sn":"interruptingClipTimeAddition","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"interruptingStateInfo","t":4,"rt":$n[1].AnimatorStateInfo,"sn":"interruptingStateInfo"},{"a":2,"n":"isInterruptionActive","t":4,"rt":$n[0].Boolean,"sn":"isInterruptionActive","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"isLastFrameOfInterruption","t":4,"rt":$n[0].Boolean,"sn":"isLastFrameOfInterruption","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"nextClipInfoCount","t":4,"rt":$n[0].Int32,"sn":"nextClipInfoCount","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"nextClipInfos","t":4,"rt":$n[5].List$1(UnityEngine.AnimatorClipInfo),"sn":"nextClipInfos","ro":true},{"a":2,"n":"nextStateInfo","t":4,"rt":$n[1].AnimatorStateInfo,"sn":"nextStateInfo"},{"a":2,"n":"stateInfo","t":4,"rt":$n[1].AnimatorStateInfo,"sn":"stateInfo"}]}; }, $n);
    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+ClipInfos end.*/

    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+AnimationClipEqualityComparer start.*/
    $m("Spine.Unity.SkeletonMecanim.MecanimTranslator.AnimationClipEqualityComparer", function () { return {"td":$n[4].SkeletonMecanim.MecanimTranslator,"att":1048579,"a":1,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Equals","t":8,"pi":[{"n":"x","pt":$n[1].AnimationClip,"ps":0},{"n":"y","pt":$n[1].AnimationClip,"ps":1}],"sn":"equals2","rt":$n[0].Boolean,"p":[$n[1].AnimationClip,$n[1].AnimationClip],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"GetHashCode","t":8,"pi":[{"n":"o","pt":$n[1].AnimationClip,"ps":0}],"sn":"getHashCode2","rt":$n[0].Int32,"p":[$n[1].AnimationClip],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":4,"n":"Instance","is":true,"t":4,"rt":$n[5].IEqualityComparer$1(UnityEngine.AnimationClip),"sn":"Instance","ro":true}]}; }, $n);
    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+AnimationClipEqualityComparer end.*/

    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+IntEqualityComparer start.*/
    $m("Spine.Unity.SkeletonMecanim.MecanimTranslator.IntEqualityComparer", function () { return {"td":$n[4].SkeletonMecanim.MecanimTranslator,"att":1048579,"a":1,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Equals","t":8,"pi":[{"n":"x","pt":$n[0].Int32,"ps":0},{"n":"y","pt":$n[0].Int32,"ps":1}],"sn":"equals2","rt":$n[0].Boolean,"p":[$n[0].Int32,$n[0].Int32],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"GetHashCode","t":8,"pi":[{"n":"o","pt":$n[0].Int32,"ps":0}],"sn":"getHashCode2","rt":$n[0].Int32,"p":[$n[0].Int32],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":4,"n":"Instance","is":true,"t":4,"rt":$n[5].IEqualityComparer$1(System.Int32),"sn":"Instance","ro":true}]}; }, $n);
    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+IntEqualityComparer end.*/

    /*Spine.Unity.SkeletonRenderer start.*/
    $m("Spine.Unity.SkeletonRenderer", function () { return {"nested":[$n[4].SkeletonRenderer.SpriteMaskInteractionMaterials,Function,Function],"att":1048577,"a":2,"at":[new UnityEngine.ExecuteAlwaysAttribute(),new UnityEngine.RequireComponent.ctor(UnityEngine.MeshRenderer),new UnityEngine.DisallowMultipleComponent(),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#SkeletonRenderer-Component")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"AddSpineComponent","is":true,"t":8,"pi":[{"n":"gameObject","pt":$n[1].GameObject,"ps":0},{"n":"skeletonDataAsset","pt":$n[4].SkeletonDataAsset,"ps":1},{"n":"quiet","dv":false,"o":true,"pt":$n[0].Boolean,"ps":2}],"tpc":1,"tprm":["T"],"sn":"AddSpineComponent","rt":System.Object,"p":[$n[1].GameObject,$n[4].SkeletonDataAsset,$n[0].Boolean]},{"a":1,"n":"AssignSpriteMaskMaterials","t":8,"sn":"AssignSpriteMaskMaterials","rt":$n[0].Void},{"v":true,"a":2,"n":"Awake","t":8,"sn":"Awake","rt":$n[0].Void},{"v":true,"a":2,"n":"ClearState","t":8,"sn":"ClearState","rt":$n[0].Void},{"a":2,"n":"EnsureMeshGeneratorCapacity","t":8,"pi":[{"n":"minimumVertexCount","pt":$n[0].Int32,"ps":0}],"sn":"EnsureMeshGeneratorCapacity","rt":$n[0].Void,"p":[$n[0].Int32]},{"a":2,"n":"FindAndApplySeparatorSlots","t":8,"pi":[{"n":"slotNamePredicate","pt":Function,"ps":0},{"n":"clearExistingSeparators","dv":true,"o":true,"pt":$n[0].Boolean,"ps":1},{"n":"updateStringArray","dv":false,"o":true,"pt":$n[0].Boolean,"ps":2}],"sn":"FindAndApplySeparatorSlots","rt":$n[0].Void,"p":[Function,$n[0].Boolean,$n[0].Boolean]},{"a":2,"n":"FindAndApplySeparatorSlots","t":8,"pi":[{"n":"startsWith","pt":$n[0].String,"ps":0},{"n":"clearExistingSeparators","dv":true,"o":true,"pt":$n[0].Boolean,"ps":1},{"n":"updateStringArray","dv":false,"o":true,"pt":$n[0].Boolean,"ps":2}],"sn":"FindAndApplySeparatorSlots$1","rt":$n[0].Void,"p":[$n[0].String,$n[0].Boolean,$n[0].Boolean]},{"a":1,"n":"HandleOnDemandLoading","t":8,"sn":"HandleOnDemandLoading","rt":$n[0].Void},{"a":1,"n":"InitSpriteMaskMaterialsForMaskType","t":8,"pi":[{"n":"maskFunction","pt":$n[7].CompareFunction,"ps":0},{"n":"materialsToFill","ref":true,"pt":System.Array.type(UnityEngine.Material),"ps":1}],"sn":"InitSpriteMaskMaterialsForMaskType","rt":$n[0].Boolean,"p":[$n[7].CompareFunction,System.Array.type(UnityEngine.Material)],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"InitSpriteMaskMaterialsInsideMask","t":8,"sn":"InitSpriteMaskMaterialsInsideMask","rt":$n[0].Boolean,"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"InitSpriteMaskMaterialsOutsideMask","t":8,"sn":"InitSpriteMaskMaterialsOutsideMask","rt":$n[0].Boolean,"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"v":true,"a":2,"n":"Initialize","t":8,"pi":[{"n":"overwrite","pt":$n[0].Boolean,"ps":0},{"n":"quiet","dv":false,"o":true,"pt":$n[0].Boolean,"ps":1}],"sn":"Initialize","rt":$n[0].Void,"p":[$n[0].Boolean,$n[0].Boolean]},{"v":true,"a":2,"n":"LateUpdate","t":8,"sn":"LateUpdate","rt":$n[0].Void},{"v":true,"a":2,"n":"LateUpdateMesh","t":8,"sn":"LateUpdateMesh","rt":$n[0].Void},{"a":2,"n":"NewSpineGameObject","is":true,"t":8,"pi":[{"n":"skeletonDataAsset","pt":$n[4].SkeletonDataAsset,"ps":0},{"n":"quiet","dv":false,"o":true,"pt":$n[0].Boolean,"ps":1}],"tpc":1,"tprm":["T"],"sn":"NewSpineGameObject","rt":System.Object,"p":[$n[4].SkeletonDataAsset,$n[0].Boolean]},{"a":2,"n":"OnBecameInvisible","t":8,"sn":"OnBecameInvisible","rt":$n[0].Void},{"v":true,"a":2,"n":"OnBecameVisible","t":8,"sn":"OnBecameVisible","rt":$n[0].Void},{"a":1,"n":"OnDestroy","t":8,"sn":"OnDestroy","rt":$n[0].Void},{"a":1,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"a":2,"n":"ReapplySeparatorSlotNames","t":8,"sn":"ReapplySeparatorSlotNames","rt":$n[0].Void},{"a":1,"n":"SetMaterialSettingsToFixDrawOrder","t":8,"sn":"SetMaterialSettingsToFixDrawOrder","rt":$n[0].Void},{"a":2,"n":"SetMeshSettings","t":8,"pi":[{"n":"settings","pt":$n[4].MeshGenerator.Settings,"ps":0}],"sn":"SetMeshSettings","rt":$n[0].Void,"p":[$n[4].MeshGenerator.Settings]},{"a":2,"n":"CustomMaterialOverride","t":16,"rt":$n[5].Dictionary$2(UnityEngine.Material,UnityEngine.Material),"g":{"a":2,"n":"get_CustomMaterialOverride","t":8,"rt":$n[5].Dictionary$2(UnityEngine.Material,UnityEngine.Material),"fg":"CustomMaterialOverride"},"fn":"CustomMaterialOverride"},{"a":2,"n":"CustomSlotMaterials","t":16,"rt":$n[5].Dictionary$2(Spine.Slot,UnityEngine.Material),"g":{"a":2,"n":"get_CustomSlotMaterials","t":8,"rt":$n[5].Dictionary$2(Spine.Slot,UnityEngine.Material),"fg":"CustomSlotMaterials"},"fn":"CustomSlotMaterials"},{"a":2,"n":"Skeleton","t":16,"rt":$n[3].Skeleton,"g":{"a":2,"n":"get_Skeleton","t":8,"rt":$n[3].Skeleton,"fg":"Skeleton"},"fn":"Skeleton"},{"a":2,"n":"SkeletonDataAsset","t":16,"rt":$n[4].SkeletonDataAsset,"g":{"a":2,"n":"get_SkeletonDataAsset","t":8,"rt":$n[4].SkeletonDataAsset,"fg":"SkeletonDataAsset"},"fn":"SkeletonDataAsset"},{"a":2,"n":"UpdateMode","t":16,"rt":$n[4].UpdateMode,"g":{"a":2,"n":"get_UpdateMode","t":8,"rt":$n[4].UpdateMode,"fg":"UpdateMode","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateMode, System.Enum.toStringFn(Spine.Unity.UpdateMode));}},"s":{"a":2,"n":"set_UpdateMode","t":8,"p":[$n[4].UpdateMode],"rt":$n[0].Void,"fs":"UpdateMode"},"fn":"UpdateMode"},{"a":2,"n":"STENCIL_COMP_MASKINTERACTION_NONE","is":true,"t":4,"rt":$n[7].CompareFunction,"sn":"STENCIL_COMP_MASKINTERACTION_NONE","box":function ($v) { return Bridge.box($v, UnityEngine.Rendering.CompareFunction, System.Enum.toStringFn(UnityEngine.Rendering.CompareFunction));}},{"a":2,"n":"STENCIL_COMP_MASKINTERACTION_VISIBLE_INSIDE","is":true,"t":4,"rt":$n[7].CompareFunction,"sn":"STENCIL_COMP_MASKINTERACTION_VISIBLE_INSIDE","box":function ($v) { return Bridge.box($v, UnityEngine.Rendering.CompareFunction, System.Enum.toStringFn(UnityEngine.Rendering.CompareFunction));}},{"a":2,"n":"STENCIL_COMP_MASKINTERACTION_VISIBLE_OUTSIDE","is":true,"t":4,"rt":$n[7].CompareFunction,"sn":"STENCIL_COMP_MASKINTERACTION_VISIBLE_OUTSIDE","box":function ($v) { return Bridge.box($v, UnityEngine.Rendering.CompareFunction, System.Enum.toStringFn(UnityEngine.Rendering.CompareFunction));}},{"a":2,"n":"STENCIL_COMP_PARAM_ID","is":true,"t":4,"rt":$n[0].Int32,"sn":"STENCIL_COMP_PARAM_ID","ro":true,"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"SUBMESH_DUMMY_PARAM_ID","is":true,"t":4,"rt":$n[0].Int32,"sn":"SUBMESH_DUMMY_PARAM_ID","ro":true,"box":function ($v) { return Bridge.box($v, System.Int32);}},{"at":[new UnityEngine.Serialization.FormerlySerializedAsAttribute("calculateNormals")],"a":2,"n":"addNormals","t":4,"rt":$n[0].Boolean,"sn":"addNormals","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"calculateTangents","t":4,"rt":$n[0].Boolean,"sn":"calculateTangents","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"clearStateOnDisable","t":4,"rt":$n[0].Boolean,"sn":"clearStateOnDisable","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"currentInstructions","t":4,"rt":$n[4].SkeletonRendererInstruction,"sn":"currentInstructions","ro":true},{"a":1,"n":"customMaterialOverride","t":4,"rt":$n[5].Dictionary$2(UnityEngine.Material,UnityEngine.Material),"sn":"customMaterialOverride","ro":true},{"a":1,"n":"customSlotMaterials","t":4,"rt":$n[5].Dictionary$2(Spine.Slot,UnityEngine.Material),"sn":"customSlotMaterials","ro":true},{"a":2,"n":"disableRenderingOnOverride","t":4,"rt":$n[0].Boolean,"sn":"disableRenderingOnOverride","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"fixDrawOrder","t":4,"rt":$n[0].Boolean,"sn":"fixDrawOrder","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"immutableTriangles","t":4,"rt":$n[0].Boolean,"sn":"immutableTriangles","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"initialFlipX","t":4,"rt":$n[0].Boolean,"sn":"initialFlipX","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"initialFlipY","t":4,"rt":$n[0].Boolean,"sn":"initialFlipY","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new Spine.Unity.SpineSkin("", "", true, false, true)],"a":2,"n":"initialSkinName","t":4,"rt":$n[0].String,"sn":"initialSkinName"},{"a":2,"n":"maskInteraction","t":4,"rt":$n[1].SpriteMaskInteraction,"sn":"maskInteraction","box":function ($v) { return Bridge.box($v, UnityEngine.SpriteMaskInteraction, System.Enum.toStringFn(UnityEngine.SpriteMaskInteraction));}},{"a":2,"n":"maskMaterials","t":4,"rt":$n[4].SkeletonRenderer.SpriteMaskInteractionMaterials,"sn":"maskMaterials"},{"a":1,"n":"meshFilter","t":4,"rt":$n[1].MeshFilter,"sn":"meshFilter"},{"a":1,"n":"meshGenerator","t":4,"rt":$n[4].MeshGenerator,"sn":"meshGenerator","ro":true},{"a":1,"n":"meshRenderer","t":4,"rt":$n[1].MeshRenderer,"sn":"meshRenderer"},{"a":2,"n":"pmaVertexColors","t":4,"rt":$n[0].Boolean,"sn":"pmaVertexColors","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"rendererBuffers","t":4,"rt":$n[4].MeshRendererBuffers,"sn":"rendererBuffers","ro":true},{"a":1,"n":"reusedPropertyBlock","t":4,"rt":$n[1].MaterialPropertyBlock,"sn":"reusedPropertyBlock"},{"at":[new UnityEngine.Serialization.FormerlySerializedAsAttribute("submeshSeparators"),new UnityEngine.SerializeFieldAttribute(),new Spine.Unity.SpineSlot("", "", false, true, false)],"a":3,"n":"separatorSlotNames","t":4,"rt":$n[0].Array.type(System.String),"sn":"separatorSlotNames"},{"a":2,"n":"separatorSlots","t":4,"rt":$n[5].List$1(Spine.Slot),"sn":"separatorSlots","ro":true},{"a":2,"n":"singleSubmesh","t":4,"rt":$n[0].Boolean,"sn":"singleSubmesh","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"skeleton","t":4,"rt":$n[3].Skeleton,"sn":"skeleton"},{"a":2,"n":"skeletonDataAsset","t":4,"rt":$n[4].SkeletonDataAsset,"sn":"skeletonDataAsset"},{"a":2,"n":"tintBlack","t":4,"rt":$n[0].Boolean,"sn":"tintBlack","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":3,"n":"updateMode","t":4,"rt":$n[4].UpdateMode,"sn":"updateMode","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateMode, System.Enum.toStringFn(Spine.Unity.UpdateMode));}},{"a":2,"n":"updateWhenInvisible","t":4,"rt":$n[4].UpdateMode,"sn":"updateWhenInvisible","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateMode, System.Enum.toStringFn(Spine.Unity.UpdateMode));}},{"a":2,"n":"useClipping","t":4,"rt":$n[0].Boolean,"sn":"useClipping","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"valid","t":4,"rt":$n[0].Boolean,"sn":"valid","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.RangeAttribute(-0.1, 0.0)],"a":2,"n":"zSpacing","t":4,"rt":$n[0].Single,"sn":"zSpacing","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"GenerateMeshOverride","t":2,"ad":{"a":2,"n":"add_GenerateMeshOverride","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addGenerateMeshOverride","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_GenerateMeshOverride","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeGenerateMeshOverride","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"OnMeshAndMaterialsUpdated","t":2,"ad":{"a":2,"n":"add_OnMeshAndMaterialsUpdated","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnMeshAndMaterialsUpdated","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_OnMeshAndMaterialsUpdated","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnMeshAndMaterialsUpdated","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"OnPostProcessVertices","t":2,"ad":{"a":2,"n":"add_OnPostProcessVertices","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnPostProcessVertices","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_OnPostProcessVertices","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnPostProcessVertices","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"OnRebuild","t":2,"ad":{"a":2,"n":"add_OnRebuild","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnRebuild","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_OnRebuild","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnRebuild","rt":$n[0].Void,"p":[Function]}},{"a":1,"n":"generateMeshOverride","t":2,"ad":{"a":1,"n":"add_generateMeshOverride","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addgenerateMeshOverride","rt":$n[0].Void,"p":[Function]},"r":{"a":1,"n":"remove_generateMeshOverride","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removegenerateMeshOverride","rt":$n[0].Void,"p":[Function]}}]}; }, $n);
    /*Spine.Unity.SkeletonRenderer end.*/

    /*Spine.Unity.SkeletonRenderer+SpriteMaskInteractionMaterials start.*/
    $m("Spine.Unity.SkeletonRenderer.SpriteMaskInteractionMaterials", function () { return {"td":$n[4].SkeletonRenderer,"att":1056770,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"AnyMaterialCreated","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_AnyMaterialCreated","t":8,"rt":$n[0].Boolean,"fg":"AnyMaterialCreated","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"AnyMaterialCreated"},{"a":2,"n":"materialsInsideMask","t":4,"rt":System.Array.type(UnityEngine.Material),"sn":"materialsInsideMask"},{"a":2,"n":"materialsMaskDisabled","t":4,"rt":System.Array.type(UnityEngine.Material),"sn":"materialsMaskDisabled"},{"a":2,"n":"materialsOutsideMask","t":4,"rt":System.Array.type(UnityEngine.Material),"sn":"materialsOutsideMask"}]}; }, $n);
    /*Spine.Unity.SkeletonRenderer+SpriteMaskInteractionMaterials end.*/

    /*Spine.Unity.SkeletonGraphicCustomMaterials start.*/
    $m("Spine.Unity.SkeletonGraphicCustomMaterials", function () { return {"nested":[$n[4].SkeletonGraphicCustomMaterials.AtlasMaterialOverride,$n[4].SkeletonGraphicCustomMaterials.AtlasTextureOverride],"att":1048577,"a":2,"at":[new UnityEngine.ExecuteAlwaysAttribute(),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#SkeletonGraphicCustomMaterials")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"a":1,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[0].Void},{"a":1,"n":"RemoveCustomMaterialOverrides","t":8,"sn":"RemoveCustomMaterialOverrides","rt":$n[0].Void},{"a":1,"n":"RemoveCustomTextureOverrides","t":8,"sn":"RemoveCustomTextureOverrides","rt":$n[0].Void},{"a":1,"n":"SetCustomMaterialOverrides","t":8,"sn":"SetCustomMaterialOverrides","rt":$n[0].Void},{"a":1,"n":"SetCustomTextureOverrides","t":8,"sn":"SetCustomTextureOverrides","rt":$n[0].Void},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"customMaterialOverrides","t":4,"rt":$n[5].List$1(Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride),"sn":"customMaterialOverrides"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"customTextureOverrides","t":4,"rt":$n[5].List$1(Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride),"sn":"customTextureOverrides"},{"a":2,"n":"skeletonGraphic","t":4,"rt":$n[4].SkeletonGraphic,"sn":"skeletonGraphic"}]}; }, $n);
    /*Spine.Unity.SkeletonGraphicCustomMaterials end.*/

    /*Spine.Unity.SkeletonGraphicCustomMaterials+AtlasMaterialOverride start.*/
    $m("Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride", function () { return {"td":$n[4].SkeletonGraphicCustomMaterials,"att":1057034,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Equals","t":8,"pi":[{"n":"other","pt":$n[4].SkeletonGraphicCustomMaterials.AtlasMaterialOverride,"ps":0}],"sn":"equalsT","rt":$n[0].Boolean,"p":[$n[4].SkeletonGraphicCustomMaterials.AtlasMaterialOverride],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"originalTexture","t":4,"rt":$n[1].Texture,"sn":"originalTexture"},{"a":2,"n":"overrideEnabled","t":4,"rt":$n[0].Boolean,"sn":"overrideEnabled","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"replacementMaterial","t":4,"rt":$n[1].Material,"sn":"replacementMaterial"}]}; }, $n);
    /*Spine.Unity.SkeletonGraphicCustomMaterials+AtlasMaterialOverride end.*/

    /*Spine.Unity.SkeletonGraphicCustomMaterials+AtlasTextureOverride start.*/
    $m("Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride", function () { return {"td":$n[4].SkeletonGraphicCustomMaterials,"att":1057034,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Equals","t":8,"pi":[{"n":"other","pt":$n[4].SkeletonGraphicCustomMaterials.AtlasTextureOverride,"ps":0}],"sn":"equalsT","rt":$n[0].Boolean,"p":[$n[4].SkeletonGraphicCustomMaterials.AtlasTextureOverride],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"originalTexture","t":4,"rt":$n[1].Texture,"sn":"originalTexture"},{"a":2,"n":"overrideEnabled","t":4,"rt":$n[0].Boolean,"sn":"overrideEnabled","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"replacementTexture","t":4,"rt":$n[1].Texture,"sn":"replacementTexture"}]}; }, $n);
    /*Spine.Unity.SkeletonGraphicCustomMaterials+AtlasTextureOverride end.*/

    /*Spine.Unity.SkeletonRendererCustomMaterials start.*/
    $m("Spine.Unity.SkeletonRendererCustomMaterials", function () { return {"nested":[$n[4].SkeletonRendererCustomMaterials.SlotMaterialOverride,$n[4].SkeletonRendererCustomMaterials.AtlasMaterialOverride],"att":1048577,"a":2,"at":[new UnityEngine.ExecuteAlwaysAttribute(),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#SkeletonRendererCustomMaterials")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"a":1,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[0].Void},{"a":1,"n":"RemoveCustomMaterialOverrides","t":8,"sn":"RemoveCustomMaterialOverrides","rt":$n[0].Void},{"a":1,"n":"RemoveCustomSlotMaterials","t":8,"sn":"RemoveCustomSlotMaterials","rt":$n[0].Void},{"a":1,"n":"SetCustomMaterialOverrides","t":8,"sn":"SetCustomMaterialOverrides","rt":$n[0].Void},{"a":1,"n":"SetCustomSlotMaterials","t":8,"sn":"SetCustomSlotMaterials","rt":$n[0].Void},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"customMaterialOverrides","t":4,"rt":$n[5].List$1(Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride),"sn":"customMaterialOverrides"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"customSlotMaterials","t":4,"rt":$n[5].List$1(Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride),"sn":"customSlotMaterials"},{"a":2,"n":"skeletonRenderer","t":4,"rt":$n[4].SkeletonRenderer,"sn":"skeletonRenderer"}]}; }, $n);
    /*Spine.Unity.SkeletonRendererCustomMaterials end.*/

    /*Spine.Unity.SkeletonRendererCustomMaterials+SlotMaterialOverride start.*/
    $m("Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride", function () { return {"td":$n[4].SkeletonRendererCustomMaterials,"att":1057034,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Equals","t":8,"pi":[{"n":"other","pt":$n[4].SkeletonRendererCustomMaterials.SlotMaterialOverride,"ps":0}],"sn":"equalsT","rt":$n[0].Boolean,"p":[$n[4].SkeletonRendererCustomMaterials.SlotMaterialOverride],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"material","t":4,"rt":$n[1].Material,"sn":"material"},{"a":2,"n":"overrideDisabled","t":4,"rt":$n[0].Boolean,"sn":"overrideDisabled","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new Spine.Unity.SpineSlot("", "", false, true, false)],"a":2,"n":"slotName","t":4,"rt":$n[0].String,"sn":"slotName"}]}; }, $n);
    /*Spine.Unity.SkeletonRendererCustomMaterials+SlotMaterialOverride end.*/

    /*Spine.Unity.SkeletonRendererCustomMaterials+AtlasMaterialOverride start.*/
    $m("Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride", function () { return {"td":$n[4].SkeletonRendererCustomMaterials,"att":1057034,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Equals","t":8,"pi":[{"n":"other","pt":$n[4].SkeletonRendererCustomMaterials.AtlasMaterialOverride,"ps":0}],"sn":"equalsT","rt":$n[0].Boolean,"p":[$n[4].SkeletonRendererCustomMaterials.AtlasMaterialOverride],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"originalMaterial","t":4,"rt":$n[1].Material,"sn":"originalMaterial"},{"a":2,"n":"overrideDisabled","t":4,"rt":$n[0].Boolean,"sn":"overrideDisabled","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"replacementMaterial","t":4,"rt":$n[1].Material,"sn":"replacementMaterial"}]}; }, $n);
    /*Spine.Unity.SkeletonRendererCustomMaterials+AtlasMaterialOverride end.*/

    /*Spine.Unity.SkeletonPartsRenderer start.*/
    $m("Spine.Unity.SkeletonPartsRenderer", function () { return {"nested":[Function],"att":1048577,"a":2,"at":[new UnityEngine.RequireComponent.$ctor1(UnityEngine.MeshRenderer, UnityEngine.MeshFilter),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#SkeletonRenderSeparator")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"ClearMesh","t":8,"sn":"ClearMesh","rt":$n[0].Void},{"a":1,"n":"LazyIntialize","t":8,"sn":"LazyIntialize","rt":$n[0].Void},{"a":2,"n":"NewPartsRendererGameObject","is":true,"t":8,"pi":[{"n":"parent","pt":$n[1].Transform,"ps":0},{"n":"name","pt":$n[0].String,"ps":1},{"n":"sortingOrder","dv":0,"o":true,"pt":$n[0].Int32,"ps":2}],"sn":"NewPartsRendererGameObject","rt":$n[4].SkeletonPartsRenderer,"p":[$n[1].Transform,$n[0].String,$n[0].Int32]},{"a":1,"n":"OnDestroy","t":8,"sn":"OnDestroy","rt":$n[0].Void},{"a":2,"n":"RenderParts","t":8,"pi":[{"n":"instructions","pt":$n[3].ExposedList$1(Spine.Unity.SubmeshInstruction),"ps":0},{"n":"startSubmesh","pt":$n[0].Int32,"ps":1},{"n":"endSubmesh","pt":$n[0].Int32,"ps":2}],"sn":"RenderParts","rt":$n[0].Void,"p":[$n[3].ExposedList$1(Spine.Unity.SubmeshInstruction),$n[0].Int32,$n[0].Int32]},{"a":2,"n":"SetPropertyBlock","t":8,"pi":[{"n":"block","pt":$n[1].MaterialPropertyBlock,"ps":0}],"sn":"SetPropertyBlock","rt":$n[0].Void,"p":[$n[1].MaterialPropertyBlock]},{"a":2,"n":"MeshFilter","t":16,"rt":$n[1].MeshFilter,"g":{"a":2,"n":"get_MeshFilter","t":8,"rt":$n[1].MeshFilter,"fg":"MeshFilter"},"fn":"MeshFilter"},{"a":2,"n":"MeshGenerator","t":16,"rt":$n[4].MeshGenerator,"g":{"a":2,"n":"get_MeshGenerator","t":8,"rt":$n[4].MeshGenerator,"fg":"MeshGenerator"},"fn":"MeshGenerator"},{"a":2,"n":"MeshRenderer","t":16,"rt":$n[1].MeshRenderer,"g":{"a":2,"n":"get_MeshRenderer","t":8,"rt":$n[1].MeshRenderer,"fg":"MeshRenderer"},"fn":"MeshRenderer"},{"a":1,"n":"buffers","t":4,"rt":$n[4].MeshRendererBuffers,"sn":"buffers"},{"a":1,"n":"currentInstructions","t":4,"rt":$n[4].SkeletonRendererInstruction,"sn":"currentInstructions"},{"a":1,"n":"meshFilter","t":4,"rt":$n[1].MeshFilter,"sn":"meshFilter"},{"a":1,"n":"meshGenerator","t":4,"rt":$n[4].MeshGenerator,"sn":"meshGenerator"},{"a":1,"n":"meshRenderer","t":4,"rt":$n[1].MeshRenderer,"sn":"meshRenderer"},{"a":2,"n":"OnMeshAndMaterialsUpdated","t":2,"ad":{"a":2,"n":"add_OnMeshAndMaterialsUpdated","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnMeshAndMaterialsUpdated","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_OnMeshAndMaterialsUpdated","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnMeshAndMaterialsUpdated","rt":$n[0].Void,"p":[Function]}}]}; }, $n);
    /*Spine.Unity.SkeletonPartsRenderer end.*/

    /*Spine.Unity.SkeletonRenderSeparator start.*/
    $m("Spine.Unity.SkeletonRenderSeparator", function () { return {"att":1048577,"a":2,"at":[new UnityEngine.ExecuteAlwaysAttribute(),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#SkeletonRenderSeparator")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"AddPartsRenderer","t":8,"pi":[{"n":"sortingOrderIncrement","dv":5,"o":true,"pt":$n[0].Int32,"ps":0},{"n":"name","dv":null,"o":true,"pt":$n[0].String,"ps":1}],"sn":"AddPartsRenderer","rt":$n[4].SkeletonPartsRenderer,"p":[$n[0].Int32,$n[0].String]},{"a":2,"n":"AddToSkeletonRenderer","is":true,"t":8,"pi":[{"n":"skeletonRenderer","pt":$n[4].SkeletonRenderer,"ps":0},{"n":"sortingLayerID","dv":0,"o":true,"pt":$n[0].Int32,"ps":1},{"n":"extraPartsRenderers","dv":0,"o":true,"pt":$n[0].Int32,"ps":2},{"n":"sortingOrderIncrement","dv":5,"o":true,"pt":$n[0].Int32,"ps":3},{"n":"baseSortingOrder","dv":0,"o":true,"pt":$n[0].Int32,"ps":4},{"n":"addMinimumPartsRenderers","dv":true,"o":true,"pt":$n[0].Boolean,"ps":5}],"sn":"AddToSkeletonRenderer","rt":$n[4].SkeletonRenderSeparator,"p":[$n[4].SkeletonRenderer,$n[0].Int32,$n[0].Int32,$n[0].Int32,$n[0].Int32,$n[0].Boolean]},{"a":3,"n":"ClearPartsRendererMeshes","t":8,"sn":"ClearPartsRendererMeshes","rt":$n[0].Void},{"a":1,"n":"HandleRender","t":8,"pi":[{"n":"instruction","pt":$n[4].SkeletonRendererInstruction,"ps":0}],"sn":"HandleRender","rt":$n[0].Void,"p":[$n[4].SkeletonRendererInstruction]},{"a":2,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"a":2,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[0].Void},{"a":2,"n":"SkeletonRenderer","t":16,"rt":$n[4].SkeletonRenderer,"g":{"a":2,"n":"get_SkeletonRenderer","t":8,"rt":$n[4].SkeletonRenderer,"fg":"SkeletonRenderer"},"s":{"a":2,"n":"set_SkeletonRenderer","t":8,"p":[$n[4].SkeletonRenderer],"rt":$n[0].Void,"fs":"SkeletonRenderer"},"fn":"SkeletonRenderer"},{"a":2,"n":"DefaultSortingOrderIncrement","is":true,"t":4,"rt":$n[0].Int32,"sn":"DefaultSortingOrderIncrement","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"copiedBlock","t":4,"rt":$n[1].MaterialPropertyBlock,"sn":"copiedBlock"},{"at":[new UnityEngine.TooltipAttribute("Copies MeshRenderer flags into each parts renderer")],"a":2,"n":"copyMeshRendererFlags","t":4,"rt":$n[0].Boolean,"sn":"copyMeshRendererFlags","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"copyPropertyBlock","t":4,"rt":$n[0].Boolean,"sn":"copyPropertyBlock","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"mainMeshRenderer","t":4,"rt":$n[1].MeshRenderer,"sn":"mainMeshRenderer"},{"a":2,"n":"partsRenderers","t":4,"rt":$n[5].List$1(Spine.Unity.SkeletonPartsRenderer),"sn":"partsRenderers"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"skeletonRenderer","t":4,"rt":$n[4].SkeletonRenderer,"sn":"skeletonRenderer"},{"a":2,"n":"OnMeshAndMaterialsUpdated","t":2,"ad":{"a":2,"n":"add_OnMeshAndMaterialsUpdated","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnMeshAndMaterialsUpdated","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_OnMeshAndMaterialsUpdated","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnMeshAndMaterialsUpdated","rt":$n[0].Void,"p":[Function]}}]}; }, $n);
    /*Spine.Unity.SkeletonRenderSeparator end.*/

    /*Spine.Unity.ActivateBasedOnFlipDirection start.*/
    $m("Spine.Unity.ActivateBasedOnFlipDirection", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"CompensateMovementAfterFlipX","t":8,"pi":[{"n":"toActivate","pt":$n[1].Transform,"ps":0},{"n":"toDeactivate","pt":$n[1].Transform,"ps":1}],"sn":"CompensateMovementAfterFlipX","rt":$n[0].Void,"p":[$n[1].Transform,$n[1].Transform]},{"a":1,"n":"FixedUpdate","t":8,"sn":"FixedUpdate","rt":$n[0].Void},{"a":1,"n":"HandleFlip","t":8,"pi":[{"n":"isFlippedX","pt":$n[0].Boolean,"ps":0}],"sn":"HandleFlip","rt":$n[0].Void,"p":[$n[0].Boolean]},{"a":1,"n":"ResetJointPositions","t":8,"pi":[{"n":"joints","pt":System.Array.type(UnityEngine.HingeJoint2D),"ps":0}],"sn":"ResetJointPositions","rt":$n[0].Void,"p":[System.Array.type(UnityEngine.HingeJoint2D)]},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":2,"n":"activeOnFlippedX","t":4,"rt":$n[1].GameObject,"sn":"activeOnFlippedX"},{"a":2,"n":"activeOnNormalX","t":4,"rt":$n[1].GameObject,"sn":"activeOnNormalX"},{"a":1,"n":"jointsFlippedX","t":4,"rt":System.Array.type(UnityEngine.HingeJoint2D),"sn":"jointsFlippedX"},{"a":1,"n":"jointsNormalX","t":4,"rt":System.Array.type(UnityEngine.HingeJoint2D),"sn":"jointsNormalX"},{"a":1,"n":"skeletonComponent","t":4,"rt":$n[4].ISkeletonComponent,"sn":"skeletonComponent"},{"a":2,"n":"skeletonGraphic","t":4,"rt":$n[4].SkeletonGraphic,"sn":"skeletonGraphic"},{"a":2,"n":"skeletonRenderer","t":4,"rt":$n[4].SkeletonRenderer,"sn":"skeletonRenderer"},{"a":1,"n":"wasFlippedXBefore","t":4,"rt":$n[0].Boolean,"sn":"wasFlippedXBefore","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.ActivateBasedOnFlipDirection end.*/

    /*Spine.Unity.FollowLocationRigidbody start.*/
    $m("Spine.Unity.FollowLocationRigidbody", function () { return {"att":1048577,"a":2,"at":[new UnityEngine.RequireComponent.ctor(UnityEngine.Rigidbody)],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"Awake","t":8,"sn":"Awake","rt":$n[0].Void},{"a":1,"n":"FixedUpdate","t":8,"sn":"FixedUpdate","rt":$n[0].Void},{"a":1,"n":"ownRigidbody","t":4,"rt":$n[1].Rigidbody,"sn":"ownRigidbody"},{"a":2,"n":"reference","t":4,"rt":$n[1].Transform,"sn":"reference"}]}; }, $n);
    /*Spine.Unity.FollowLocationRigidbody end.*/

    /*Spine.Unity.FollowLocationRigidbody2D start.*/
    $m("Spine.Unity.FollowLocationRigidbody2D", function () { return {"att":1048577,"a":2,"at":[new UnityEngine.RequireComponent.ctor(UnityEngine.Rigidbody2D)],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"Awake","t":8,"sn":"Awake","rt":$n[0].Void},{"a":1,"n":"FixedUpdate","t":8,"sn":"FixedUpdate","rt":$n[0].Void},{"a":2,"n":"followFlippedX","t":4,"rt":$n[0].Boolean,"sn":"followFlippedX","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"ownRigidbody","t":4,"rt":$n[1].Rigidbody2D,"sn":"ownRigidbody"},{"a":2,"n":"reference","t":4,"rt":$n[1].Transform,"sn":"reference"}]}; }, $n);
    /*Spine.Unity.FollowLocationRigidbody2D end.*/

    /*Spine.Unity.FollowSkeletonUtilityRootRotation start.*/
    $m("Spine.Unity.FollowSkeletonUtilityRootRotation", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"CompensatePositionToXRotation","t":8,"sn":"CompensatePositionToXRotation","rt":$n[0].Void},{"a":1,"n":"CompensatePositionToYRotation","t":8,"sn":"CompensatePositionToYRotation","rt":$n[0].Void},{"a":1,"n":"FixedUpdate","t":8,"sn":"FixedUpdate","rt":$n[0].Void},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":1,"n":"FLIP_ANGLE_THRESHOLD","is":true,"t":4,"rt":$n[0].Single,"sn":"FLIP_ANGLE_THRESHOLD","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"prevLocalEulerAngles","t":4,"rt":$n[1].Vector3,"sn":"prevLocalEulerAngles"},{"a":2,"n":"reference","t":4,"rt":$n[1].Transform,"sn":"reference"}]}; }, $n);
    /*Spine.Unity.FollowSkeletonUtilityRootRotation end.*/

    /*Spine.Unity.SkeletonUtility start.*/
    $m("Spine.Unity.SkeletonUtility", function () { return {"nested":[Function],"att":1048833,"a":2,"at":[new UnityEngine.ExecuteAlwaysAttribute(),new UnityEngine.RequireComponent.ctor(Spine.Unity.ISkeletonAnimation),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#SkeletonUtility")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"AddBoneRigidbody2D","is":true,"t":8,"pi":[{"n":"gameObject","pt":$n[1].GameObject,"ps":0},{"n":"isKinematic","dv":true,"o":true,"pt":$n[0].Boolean,"ps":1},{"n":"gravityScale","dv":0.0,"o":true,"pt":$n[0].Single,"ps":2}],"sn":"AddBoneRigidbody2D","rt":$n[1].Rigidbody2D,"p":[$n[1].GameObject,$n[0].Boolean,$n[0].Single]},{"a":2,"n":"AddBoundingBoxAsComponent","is":true,"t":8,"pi":[{"n":"box","pt":spine.BoundingBoxAttachment,"ps":0},{"n":"slot","pt":$n[3].Slot,"ps":1},{"n":"gameObject","pt":$n[1].GameObject,"ps":2},{"n":"isTrigger","dv":true,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"AddBoundingBoxAsComponent","rt":$n[1].PolygonCollider2D,"p":[spine.BoundingBoxAttachment,$n[3].Slot,$n[1].GameObject,$n[0].Boolean]},{"a":2,"n":"AddBoundingBoxGameObject","is":true,"t":8,"pi":[{"n":"name","pt":$n[0].String,"ps":0},{"n":"box","pt":spine.BoundingBoxAttachment,"ps":1},{"n":"slot","pt":$n[3].Slot,"ps":2},{"n":"parent","pt":$n[1].Transform,"ps":3},{"n":"isTrigger","dv":true,"o":true,"pt":$n[0].Boolean,"ps":4}],"sn":"AddBoundingBoxGameObject$1","rt":$n[1].PolygonCollider2D,"p":[$n[0].String,spine.BoundingBoxAttachment,$n[3].Slot,$n[1].Transform,$n[0].Boolean]},{"a":2,"n":"AddBoundingBoxGameObject","is":true,"t":8,"pi":[{"n":"skeleton","pt":$n[3].Skeleton,"ps":0},{"n":"skinName","pt":$n[0].String,"ps":1},{"n":"slotName","pt":$n[0].String,"ps":2},{"n":"attachmentName","pt":$n[0].String,"ps":3},{"n":"parent","pt":$n[1].Transform,"ps":4},{"n":"isTrigger","dv":true,"o":true,"pt":$n[0].Boolean,"ps":5}],"sn":"AddBoundingBoxGameObject","rt":$n[1].PolygonCollider2D,"p":[$n[3].Skeleton,$n[0].String,$n[0].String,$n[0].String,$n[1].Transform,$n[0].Boolean]},{"a":2,"n":"CollectBones","t":8,"sn":"CollectBones","rt":$n[0].Void},{"a":2,"n":"GetBoneRoot","t":8,"sn":"GetBoneRoot","rt":$n[1].Transform},{"a":2,"n":"GetBoundingBoxBounds","is":true,"t":8,"pi":[{"n":"boundingBox","pt":spine.BoundingBoxAttachment,"ps":0},{"n":"depth","dv":0.0,"o":true,"pt":$n[0].Single,"ps":1}],"sn":"GetBoundingBoxBounds","rt":$n[1].Bounds,"p":[spine.BoundingBoxAttachment,$n[0].Single]},{"a":1,"n":"HandleRendererReset","t":8,"pi":[{"n":"g","pt":$n[4].SkeletonGraphic,"ps":0}],"sn":"HandleRendererReset","rt":$n[0].Void,"p":[$n[4].SkeletonGraphic]},{"a":1,"n":"HandleRendererReset","t":8,"pi":[{"n":"r","pt":$n[4].SkeletonRenderer,"ps":0}],"sn":"HandleRendererReset$1","rt":$n[0].Void,"p":[$n[4].SkeletonRenderer]},{"a":1,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"a":1,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[0].Void},{"a":2,"n":"RegisterBone","t":8,"pi":[{"n":"bone","pt":$n[4].SkeletonUtilityBone,"ps":0}],"sn":"RegisterBone","rt":$n[0].Void,"p":[$n[4].SkeletonUtilityBone]},{"a":2,"n":"RegisterConstraint","t":8,"pi":[{"n":"constraint","pt":$n[4].SkeletonUtilityConstraint,"ps":0}],"sn":"RegisterConstraint","rt":$n[0].Void,"p":[$n[4].SkeletonUtilityConstraint]},{"a":2,"n":"ResubscribeEvents","t":8,"sn":"ResubscribeEvents","rt":$n[0].Void},{"a":2,"n":"SetColliderPointsLocal","is":true,"t":8,"pi":[{"n":"collider","pt":$n[1].PolygonCollider2D,"ps":0},{"n":"slot","pt":$n[3].Slot,"ps":1},{"n":"box","pt":spine.BoundingBoxAttachment,"ps":2},{"n":"scale","dv":1.0,"o":true,"pt":$n[0].Single,"ps":3}],"sn":"SetColliderPointsLocal","rt":$n[0].Void,"p":[$n[1].PolygonCollider2D,$n[3].Slot,spine.BoundingBoxAttachment,$n[0].Single]},{"a":2,"n":"SpawnBone","t":8,"pi":[{"n":"bone","pt":$n[3].Bone,"ps":0},{"n":"parent","pt":$n[1].Transform,"ps":1},{"n":"mode","pt":$n[4].SkeletonUtilityBone.Mode,"ps":2},{"n":"pos","pt":$n[0].Boolean,"ps":3},{"n":"rot","pt":$n[0].Boolean,"ps":4},{"n":"sca","pt":$n[0].Boolean,"ps":5}],"sn":"SpawnBone","rt":$n[1].GameObject,"p":[$n[3].Bone,$n[1].Transform,$n[4].SkeletonUtilityBone.Mode,$n[0].Boolean,$n[0].Boolean,$n[0].Boolean]},{"a":2,"n":"SpawnBoneRecursively","t":8,"pi":[{"n":"bone","pt":$n[3].Bone,"ps":0},{"n":"parent","pt":$n[1].Transform,"ps":1},{"n":"mode","pt":$n[4].SkeletonUtilityBone.Mode,"ps":2},{"n":"pos","pt":$n[0].Boolean,"ps":3},{"n":"rot","pt":$n[0].Boolean,"ps":4},{"n":"sca","pt":$n[0].Boolean,"ps":5}],"sn":"SpawnBoneRecursively","rt":$n[1].GameObject,"p":[$n[3].Bone,$n[1].Transform,$n[4].SkeletonUtilityBone.Mode,$n[0].Boolean,$n[0].Boolean,$n[0].Boolean]},{"a":2,"n":"SpawnHierarchy","t":8,"pi":[{"n":"mode","pt":$n[4].SkeletonUtilityBone.Mode,"ps":0},{"n":"pos","pt":$n[0].Boolean,"ps":1},{"n":"rot","pt":$n[0].Boolean,"ps":2},{"n":"sca","pt":$n[0].Boolean,"ps":3}],"sn":"SpawnHierarchy","rt":$n[1].GameObject,"p":[$n[4].SkeletonUtilityBone.Mode,$n[0].Boolean,$n[0].Boolean,$n[0].Boolean]},{"a":2,"n":"SpawnRoot","t":8,"pi":[{"n":"mode","pt":$n[4].SkeletonUtilityBone.Mode,"ps":0},{"n":"pos","pt":$n[0].Boolean,"ps":1},{"n":"rot","pt":$n[0].Boolean,"ps":2},{"n":"sca","pt":$n[0].Boolean,"ps":3}],"sn":"SpawnRoot","rt":$n[1].GameObject,"p":[$n[4].SkeletonUtilityBone.Mode,$n[0].Boolean,$n[0].Boolean,$n[0].Boolean]},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":2,"n":"UnregisterBone","t":8,"pi":[{"n":"bone","pt":$n[4].SkeletonUtilityBone,"ps":0}],"sn":"UnregisterBone","rt":$n[0].Void,"p":[$n[4].SkeletonUtilityBone]},{"a":2,"n":"UnregisterConstraint","t":8,"pi":[{"n":"constraint","pt":$n[4].SkeletonUtilityConstraint,"ps":0}],"sn":"UnregisterConstraint","rt":$n[0].Void,"p":[$n[4].SkeletonUtilityConstraint]},{"a":1,"n":"Update","t":8,"sn":"Update","rt":$n[0].Void},{"a":1,"n":"UpdateAllBones","t":8,"pi":[{"n":"phase","pt":$n[4].SkeletonUtilityBone.UpdatePhase,"ps":0}],"sn":"UpdateAllBones","rt":$n[0].Void,"p":[$n[4].SkeletonUtilityBone.UpdatePhase]},{"a":1,"n":"UpdateComplete","t":8,"pi":[{"n":"anim","pt":$n[4].ISkeletonAnimation,"ps":0}],"sn":"UpdateComplete","rt":$n[0].Void,"p":[$n[4].ISkeletonAnimation]},{"a":1,"n":"UpdateLocal","t":8,"pi":[{"n":"anim","pt":$n[4].ISkeletonAnimation,"ps":0}],"sn":"UpdateLocal","rt":$n[0].Void,"p":[$n[4].ISkeletonAnimation]},{"a":1,"n":"UpdateWorld","t":8,"pi":[{"n":"anim","pt":$n[4].ISkeletonAnimation,"ps":0}],"sn":"UpdateWorld","rt":$n[0].Void,"p":[$n[4].ISkeletonAnimation]},{"a":2,"n":"IsValid","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_IsValid","t":8,"rt":$n[0].Boolean,"fg":"IsValid","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"IsValid"},{"a":2,"n":"PositionScale","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_PositionScale","t":8,"rt":$n[0].Single,"fg":"PositionScale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"fn":"PositionScale"},{"a":2,"n":"Skeleton","t":16,"rt":$n[3].Skeleton,"g":{"a":2,"n":"get_Skeleton","t":8,"rt":$n[3].Skeleton,"fg":"Skeleton"},"fn":"Skeleton"},{"a":2,"n":"SkeletonComponent","t":16,"rt":$n[4].ISkeletonComponent,"g":{"a":2,"n":"get_SkeletonComponent","t":8,"rt":$n[4].ISkeletonComponent,"fg":"SkeletonComponent"},"fn":"SkeletonComponent"},{"a":2,"n":"boneComponents","t":4,"rt":$n[5].List$1(Spine.Unity.SkeletonUtilityBone),"sn":"boneComponents"},{"a":2,"n":"boneRoot","t":4,"rt":$n[1].Transform,"sn":"boneRoot"},{"a":2,"n":"constraintComponents","t":4,"rt":$n[5].List$1(Spine.Unity.SkeletonUtilityConstraint),"sn":"constraintComponents"},{"a":2,"n":"flipBy180DegreeRotation","t":4,"rt":$n[0].Boolean,"sn":"flipBy180DegreeRotation","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"hasConstraints","t":4,"rt":$n[0].Boolean,"sn":"hasConstraints","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"hasOverrideBones","t":4,"rt":$n[0].Boolean,"sn":"hasOverrideBones","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"needToReprocessBones","t":4,"rt":$n[0].Boolean,"sn":"needToReprocessBones","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"positionScale","t":4,"rt":$n[0].Single,"sn":"positionScale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"skeletonAnimation","t":4,"rt":$n[4].ISkeletonAnimation,"sn":"skeletonAnimation"},{"a":1,"n":"skeletonComponent","t":4,"rt":$n[4].ISkeletonComponent,"sn":"skeletonComponent"},{"at":[new UnityEngine.HideInInspector()],"a":2,"n":"skeletonGraphic","t":4,"rt":$n[4].SkeletonGraphic,"sn":"skeletonGraphic"},{"at":[new UnityEngine.HideInInspector()],"a":2,"n":"skeletonRenderer","t":4,"rt":$n[4].SkeletonRenderer,"sn":"skeletonRenderer"},{"a":2,"n":"OnReset","t":2,"ad":{"a":2,"n":"add_OnReset","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnReset","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_OnReset","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnReset","rt":$n[0].Void,"p":[Function]}}]}; }, $n);
    /*Spine.Unity.SkeletonUtility end.*/

    /*Spine.Unity.SkeletonUtilityBone start.*/
    $m("Spine.Unity.SkeletonUtilityBone", function () { return {"nested":[$n[4].SkeletonUtilityBone.Mode,$n[4].SkeletonUtilityBone.UpdatePhase],"att":1048577,"a":2,"at":[new UnityEngine.ExecuteAlwaysAttribute(),new UnityEngine.AddComponentMenu.ctor("Spine/SkeletonUtilityBone"),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#SkeletonUtilityBone")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"AddBoundingBox","t":8,"pi":[{"n":"skinName","pt":$n[0].String,"ps":0},{"n":"slotName","pt":$n[0].String,"ps":1},{"n":"attachmentName","pt":$n[0].String,"ps":2}],"sn":"AddBoundingBox","rt":$n[0].Void,"p":[$n[0].String,$n[0].String,$n[0].String]},{"a":2,"n":"BoneTransformModeIncompatible","is":true,"t":8,"pi":[{"n":"bone","pt":$n[3].Bone,"ps":0}],"sn":"BoneTransformModeIncompatible","rt":$n[0].Boolean,"p":[$n[3].Bone],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"DoUpdate","t":8,"pi":[{"n":"phase","pt":$n[4].SkeletonUtilityBone.UpdatePhase,"ps":0}],"sn":"DoUpdate","rt":$n[0].Void,"p":[$n[4].SkeletonUtilityBone.UpdatePhase]},{"a":1,"n":"HandleOnReset","t":8,"sn":"HandleOnReset","rt":$n[0].Void},{"a":1,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"a":1,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[0].Void},{"a":2,"n":"Reset","t":8,"sn":"Reset","rt":$n[0].Void},{"a":2,"n":"IncompatibleTransformMode","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_IncompatibleTransformMode","t":8,"rt":$n[0].Boolean,"fg":"IncompatibleTransformMode","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"IncompatibleTransformMode"},{"a":2,"n":"bone","t":4,"rt":$n[3].Bone,"sn":"bone"},{"a":2,"n":"boneName","t":4,"rt":$n[0].String,"sn":"boneName"},{"a":1,"n":"cachedTransform","t":4,"rt":$n[1].Transform,"sn":"cachedTransform"},{"a":2,"n":"hierarchy","t":4,"rt":$n[4].SkeletonUtility,"sn":"hierarchy"},{"a":1,"n":"incompatibleTransformMode","t":4,"rt":$n[0].Boolean,"sn":"incompatibleTransformMode","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"mode","t":4,"rt":$n[4].SkeletonUtilityBone.Mode,"sn":"mode","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonUtilityBone.Mode, System.Enum.toStringFn(Spine.Unity.SkeletonUtilityBone.Mode));}},{"at":[new UnityEngine.RangeAttribute(0.0, 1.0)],"a":2,"n":"overrideAlpha","t":4,"rt":$n[0].Single,"sn":"overrideAlpha","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"parentReference","t":4,"rt":$n[1].Transform,"sn":"parentReference"},{"a":2,"n":"position","t":4,"rt":$n[0].Boolean,"sn":"position","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"rotation","t":4,"rt":$n[0].Boolean,"sn":"rotation","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"scale","t":4,"rt":$n[0].Boolean,"sn":"scale","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"skeletonTransform","t":4,"rt":$n[1].Transform,"sn":"skeletonTransform"},{"a":2,"n":"transformLerpComplete","t":4,"rt":$n[0].Boolean,"sn":"transformLerpComplete","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"valid","t":4,"rt":$n[0].Boolean,"sn":"valid","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"zPosition","t":4,"rt":$n[0].Boolean,"sn":"zPosition","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.SkeletonUtilityBone end.*/

    /*Spine.Unity.SkeletonUtilityBone+Mode start.*/
    $m("Spine.Unity.SkeletonUtilityBone.Mode", function () { return {"td":$n[4].SkeletonUtilityBone,"att":258,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Follow","is":true,"t":4,"rt":$n[4].SkeletonUtilityBone.Mode,"sn":"Follow","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonUtilityBone.Mode, System.Enum.toStringFn(Spine.Unity.SkeletonUtilityBone.Mode));}},{"a":2,"n":"Override","is":true,"t":4,"rt":$n[4].SkeletonUtilityBone.Mode,"sn":"Override","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonUtilityBone.Mode, System.Enum.toStringFn(Spine.Unity.SkeletonUtilityBone.Mode));}}]}; }, $n);
    /*Spine.Unity.SkeletonUtilityBone+Mode end.*/

    /*Spine.Unity.SkeletonUtilityBone+UpdatePhase start.*/
    $m("Spine.Unity.SkeletonUtilityBone.UpdatePhase", function () { return {"td":$n[4].SkeletonUtilityBone,"att":258,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Complete","is":true,"t":4,"rt":$n[4].SkeletonUtilityBone.UpdatePhase,"sn":"Complete","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonUtilityBone.UpdatePhase, System.Enum.toStringFn(Spine.Unity.SkeletonUtilityBone.UpdatePhase));}},{"a":2,"n":"Local","is":true,"t":4,"rt":$n[4].SkeletonUtilityBone.UpdatePhase,"sn":"Local","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonUtilityBone.UpdatePhase, System.Enum.toStringFn(Spine.Unity.SkeletonUtilityBone.UpdatePhase));}},{"a":2,"n":"World","is":true,"t":4,"rt":$n[4].SkeletonUtilityBone.UpdatePhase,"sn":"World","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonUtilityBone.UpdatePhase, System.Enum.toStringFn(Spine.Unity.SkeletonUtilityBone.UpdatePhase));}}]}; }, $n);
    /*Spine.Unity.SkeletonUtilityBone+UpdatePhase end.*/

    /*Spine.Unity.SkeletonUtilityConstraint start.*/
    $m("Spine.Unity.SkeletonUtilityConstraint", function () { return {"att":1048705,"a":2,"at":[new UnityEngine.ExecuteAlwaysAttribute(),new UnityEngine.RequireComponent.ctor(Spine.Unity.SkeletonUtilityBone),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#SkeletonUtilityConstraint")],"m":[{"a":3,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"ab":true,"a":2,"n":"DoUpdate","t":8,"sn":"DoUpdate","rt":$n[0].Void},{"v":true,"a":3,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"v":true,"a":3,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[0].Void},{"a":3,"n":"bone","t":4,"rt":$n[4].SkeletonUtilityBone,"sn":"bone"},{"a":3,"n":"hierarchy","t":4,"rt":$n[4].SkeletonUtility,"sn":"hierarchy"}]}; }, $n);
    /*Spine.Unity.SkeletonUtilityConstraint end.*/

    /*Spine.Unity.UpdateMode start.*/
    $m("Spine.Unity.UpdateMode", function () { return {"att":257,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"EverythingExceptMesh","is":true,"t":4,"rt":$n[4].UpdateMode,"sn":"EverythingExceptMesh","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateMode, System.Enum.toStringFn(Spine.Unity.UpdateMode));}},{"a":2,"n":"FullUpdate","is":true,"t":4,"rt":$n[4].UpdateMode,"sn":"FullUpdate","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateMode, System.Enum.toStringFn(Spine.Unity.UpdateMode));}},{"a":2,"n":"Nothing","is":true,"t":4,"rt":$n[4].UpdateMode,"sn":"Nothing","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateMode, System.Enum.toStringFn(Spine.Unity.UpdateMode));}},{"a":2,"n":"OnlyAnimationStatus","is":true,"t":4,"rt":$n[4].UpdateMode,"sn":"OnlyAnimationStatus","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateMode, System.Enum.toStringFn(Spine.Unity.UpdateMode));}},{"a":2,"n":"OnlyEventTimelines","is":true,"t":4,"rt":$n[4].UpdateMode,"sn":"OnlyEventTimelines","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateMode, System.Enum.toStringFn(Spine.Unity.UpdateMode));}}]}; }, $n);
    /*Spine.Unity.UpdateMode end.*/

    /*Spine.Unity.UpdateTiming start.*/
    $m("Spine.Unity.UpdateTiming", function () { return {"att":257,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"InFixedUpdate","is":true,"t":4,"rt":$n[4].UpdateTiming,"sn":"InFixedUpdate","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateTiming, System.Enum.toStringFn(Spine.Unity.UpdateTiming));}},{"a":2,"n":"InLateUpdate","is":true,"t":4,"rt":$n[4].UpdateTiming,"sn":"InLateUpdate","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateTiming, System.Enum.toStringFn(Spine.Unity.UpdateTiming));}},{"a":2,"n":"InUpdate","is":true,"t":4,"rt":$n[4].UpdateTiming,"sn":"InUpdate","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateTiming, System.Enum.toStringFn(Spine.Unity.UpdateTiming));}},{"a":2,"n":"ManualUpdate","is":true,"t":4,"rt":$n[4].UpdateTiming,"sn":"ManualUpdate","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateTiming, System.Enum.toStringFn(Spine.Unity.UpdateTiming));}}]}; }, $n);
    /*Spine.Unity.UpdateTiming end.*/

    /*Spine.Unity.ISpineComponent start.*/
    $m("Spine.Unity.ISpineComponent", function () { return {"att":1048737,"a":2}; }, $n);
    /*Spine.Unity.ISpineComponent end.*/

    /*Spine.Unity.ISpineComponentExtensions start.*/
    $m("Spine.Unity.ISpineComponentExtensions", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"IsNullOrDestroyed","is":true,"t":8,"pi":[{"n":"component","pt":$n[4].ISpineComponent,"ps":0}],"sn":"IsNullOrDestroyed","rt":$n[0].Boolean,"p":[$n[4].ISpineComponent],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.ISpineComponentExtensions end.*/

    /*Spine.Unity.ISkeletonAnimation start.*/
    $m("Spine.Unity.ISkeletonAnimation", function () { return {"att":1048737,"a":2,"m":[{"ab":true,"a":2,"n":"Skeleton","t":16,"rt":$n[3].Skeleton,"g":{"ab":true,"a":2,"n":"get_Skeleton","t":8,"rt":$n[3].Skeleton,"fg":"Spine$Unity$ISkeletonAnimation$Skeleton"},"fn":"Spine$Unity$ISkeletonAnimation$Skeleton"},{"ab":true,"a":2,"n":"UpdateTiming","t":16,"rt":$n[4].UpdateTiming,"g":{"ab":true,"a":2,"n":"get_UpdateTiming","t":8,"rt":$n[4].UpdateTiming,"fg":"Spine$Unity$ISkeletonAnimation$UpdateTiming","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateTiming, System.Enum.toStringFn(Spine.Unity.UpdateTiming));}},"s":{"ab":true,"a":2,"n":"set_UpdateTiming","t":8,"p":[$n[4].UpdateTiming],"rt":$n[0].Void,"fs":"Spine$Unity$ISkeletonAnimation$UpdateTiming"},"fn":"Spine$Unity$ISkeletonAnimation$UpdateTiming"},{"ab":true,"a":2,"n":"OnAnimationRebuild","t":2,"ad":{"ab":true,"a":2,"n":"add_OnAnimationRebuild","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"Spine$Unity$ISkeletonAnimation$addOnAnimationRebuild","rt":$n[0].Void,"p":[Function]},"r":{"ab":true,"a":2,"n":"remove_OnAnimationRebuild","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"Spine$Unity$ISkeletonAnimation$removeOnAnimationRebuild","rt":$n[0].Void,"p":[Function]}},{"ab":true,"a":2,"n":"UpdateComplete","t":2,"ad":{"ab":true,"a":2,"n":"add_UpdateComplete","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"Spine$Unity$ISkeletonAnimation$addUpdateComplete","rt":$n[0].Void,"p":[Function]},"r":{"ab":true,"a":2,"n":"remove_UpdateComplete","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"Spine$Unity$ISkeletonAnimation$removeUpdateComplete","rt":$n[0].Void,"p":[Function]}},{"ab":true,"a":2,"n":"UpdateLocal","t":2,"ad":{"ab":true,"a":2,"n":"add_UpdateLocal","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"Spine$Unity$ISkeletonAnimation$addUpdateLocal","rt":$n[0].Void,"p":[Function]},"r":{"ab":true,"a":2,"n":"remove_UpdateLocal","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"Spine$Unity$ISkeletonAnimation$removeUpdateLocal","rt":$n[0].Void,"p":[Function]}},{"ab":true,"a":2,"n":"UpdateWorld","t":2,"ad":{"ab":true,"a":2,"n":"add_UpdateWorld","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"Spine$Unity$ISkeletonAnimation$addUpdateWorld","rt":$n[0].Void,"p":[Function]},"r":{"ab":true,"a":2,"n":"remove_UpdateWorld","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"Spine$Unity$ISkeletonAnimation$removeUpdateWorld","rt":$n[0].Void,"p":[Function]}},{"a":1,"backing":true,"n":"<Skeleton>k__BackingField","t":4,"rt":$n[3].Skeleton,"sn":"Spine$Unity$ISkeletonAnimation$Skeleton"},{"a":1,"backing":true,"n":"<UpdateTiming>k__BackingField","t":4,"rt":$n[4].UpdateTiming,"sn":"Spine$Unity$ISkeletonAnimation$UpdateTiming","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateTiming, System.Enum.toStringFn(Spine.Unity.UpdateTiming));}}]}; }, $n);
    /*Spine.Unity.ISkeletonAnimation end.*/

    /*Spine.Unity.IHasSkeletonDataAsset start.*/
    $m("Spine.Unity.IHasSkeletonDataAsset", function () { return {"att":1048737,"a":2,"m":[{"ab":true,"a":2,"n":"SkeletonDataAsset","t":16,"rt":$n[4].SkeletonDataAsset,"g":{"ab":true,"a":2,"n":"get_SkeletonDataAsset","t":8,"rt":$n[4].SkeletonDataAsset,"fg":"Spine$Unity$IHasSkeletonDataAsset$SkeletonDataAsset"},"fn":"Spine$Unity$IHasSkeletonDataAsset$SkeletonDataAsset"},{"a":1,"backing":true,"n":"<SkeletonDataAsset>k__BackingField","t":4,"rt":$n[4].SkeletonDataAsset,"sn":"Spine$Unity$IHasSkeletonDataAsset$SkeletonDataAsset"}]}; }, $n);
    /*Spine.Unity.IHasSkeletonDataAsset end.*/

    /*Spine.Unity.ISkeletonComponent start.*/
    $m("Spine.Unity.ISkeletonComponent", function () { return {"att":1048737,"a":2,"m":[{"ab":true,"a":2,"n":"Skeleton","t":16,"rt":$n[3].Skeleton,"g":{"ab":true,"a":2,"n":"get_Skeleton","t":8,"rt":$n[3].Skeleton,"fg":"Spine$Unity$ISkeletonComponent$Skeleton"},"fn":"Spine$Unity$ISkeletonComponent$Skeleton"},{"ab":true,"a":2,"n":"SkeletonDataAsset","t":16,"rt":$n[4].SkeletonDataAsset,"g":{"ab":true,"a":2,"n":"get_SkeletonDataAsset","t":8,"rt":$n[4].SkeletonDataAsset,"fg":"Spine$Unity$ISkeletonComponent$SkeletonDataAsset"},"fn":"Spine$Unity$ISkeletonComponent$SkeletonDataAsset"},{"a":1,"backing":true,"n":"<Skeleton>k__BackingField","t":4,"rt":$n[3].Skeleton,"sn":"Spine$Unity$ISkeletonComponent$Skeleton"},{"a":1,"backing":true,"n":"<SkeletonDataAsset>k__BackingField","t":4,"rt":$n[4].SkeletonDataAsset,"sn":"Spine$Unity$ISkeletonComponent$SkeletonDataAsset"}]}; }, $n);
    /*Spine.Unity.ISkeletonComponent end.*/

    /*Spine.Unity.IAnimationStateComponent start.*/
    $m("Spine.Unity.IAnimationStateComponent", function () { return {"att":1048737,"a":2,"m":[{"ab":true,"a":2,"n":"AnimationState","t":16,"rt":$n[3].AnimationState,"g":{"ab":true,"a":2,"n":"get_AnimationState","t":8,"rt":$n[3].AnimationState,"fg":"Spine$Unity$IAnimationStateComponent$AnimationState"},"fn":"Spine$Unity$IAnimationStateComponent$AnimationState"},{"ab":true,"a":2,"n":"UnscaledTime","t":16,"rt":$n[0].Boolean,"g":{"ab":true,"a":2,"n":"get_UnscaledTime","t":8,"rt":$n[0].Boolean,"fg":"Spine$Unity$IAnimationStateComponent$UnscaledTime","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"ab":true,"a":2,"n":"set_UnscaledTime","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"Spine$Unity$IAnimationStateComponent$UnscaledTime"},"fn":"Spine$Unity$IAnimationStateComponent$UnscaledTime"},{"a":1,"backing":true,"n":"<AnimationState>k__BackingField","t":4,"rt":$n[3].AnimationState,"sn":"Spine$Unity$IAnimationStateComponent$AnimationState"},{"a":1,"backing":true,"n":"<UnscaledTime>k__BackingField","t":4,"rt":$n[0].Boolean,"sn":"Spine$Unity$IAnimationStateComponent$UnscaledTime","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.IAnimationStateComponent end.*/

    /*Spine.Unity.IHasSkeletonRenderer start.*/
    $m("Spine.Unity.IHasSkeletonRenderer", function () { return {"att":1048737,"a":2,"m":[{"ab":true,"a":2,"n":"SkeletonRenderer","t":16,"rt":$n[4].SkeletonRenderer,"g":{"ab":true,"a":2,"n":"get_SkeletonRenderer","t":8,"rt":$n[4].SkeletonRenderer,"fg":"Spine$Unity$IHasSkeletonRenderer$SkeletonRenderer"},"fn":"Spine$Unity$IHasSkeletonRenderer$SkeletonRenderer"},{"a":1,"backing":true,"n":"<SkeletonRenderer>k__BackingField","t":4,"rt":$n[4].SkeletonRenderer,"sn":"Spine$Unity$IHasSkeletonRenderer$SkeletonRenderer"}]}; }, $n);
    /*Spine.Unity.IHasSkeletonRenderer end.*/

    /*Spine.Unity.IHasSkeletonComponent start.*/
    $m("Spine.Unity.IHasSkeletonComponent", function () { return {"att":1048737,"a":2,"m":[{"ab":true,"a":2,"n":"SkeletonComponent","t":16,"rt":$n[4].ISkeletonComponent,"g":{"ab":true,"a":2,"n":"get_SkeletonComponent","t":8,"rt":$n[4].ISkeletonComponent,"fg":"Spine$Unity$IHasSkeletonComponent$SkeletonComponent"},"fn":"Spine$Unity$IHasSkeletonComponent$SkeletonComponent"},{"a":1,"backing":true,"n":"<SkeletonComponent>k__BackingField","t":4,"rt":$n[4].ISkeletonComponent,"sn":"Spine$Unity$IHasSkeletonComponent$SkeletonComponent"}]}; }, $n);
    /*Spine.Unity.IHasSkeletonComponent end.*/

    /*Spine.Unity.DoubleBuffered$1 start.*/
    $m("Spine.Unity.DoubleBuffered$1", function (T) { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"GetCurrent","t":8,"sn":"GetCurrent","rt":T},{"a":2,"n":"GetNext","t":8,"sn":"GetNext","rt":T},{"a":1,"n":"a","t":4,"rt":T,"sn":"a","ro":true},{"a":1,"n":"b","t":4,"rt":T,"sn":"b","ro":true},{"a":1,"n":"usingA","t":4,"rt":$n[0].Boolean,"sn":"usingA","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.DoubleBuffered$1 end.*/

    /*Spine.Unity.MeshGeneratorBuffers start.*/
    $m("Spine.Unity.MeshGeneratorBuffers", function () { return {"att":1048841,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"colorBuffer","t":4,"rt":System.Array.type(UnityEngine.Color32),"sn":"colorBuffer"},{"a":2,"n":"meshGenerator","t":4,"rt":$n[4].MeshGenerator,"sn":"meshGenerator"},{"a":2,"n":"uvBuffer","t":4,"rt":System.Array.type(UnityEngine.Vector2),"sn":"uvBuffer"},{"a":2,"n":"vertexBuffer","t":4,"rt":System.Array.type(UnityEngine.Vector3),"sn":"vertexBuffer"},{"a":2,"n":"vertexCount","t":4,"rt":$n[0].Int32,"sn":"vertexCount","box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.Unity.MeshGeneratorBuffers end.*/

    /*Spine.Unity.MeshGenerator start.*/
    $m("Spine.Unity.MeshGenerator", function () { return {"nested":[$n[4].MeshGenerator.Settings],"att":1056769,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"AddAttachmentTintBlack","t":8,"pi":[{"n":"r2","pt":$n[0].Single,"ps":0},{"n":"g2","pt":$n[0].Single,"ps":1},{"n":"b2","pt":$n[0].Single,"ps":2},{"n":"a","pt":$n[0].Single,"ps":3},{"n":"vertexCount","pt":$n[0].Int32,"ps":4}],"sn":"AddAttachmentTintBlack","rt":$n[0].Void,"p":[$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Int32]},{"a":2,"n":"AddSubmesh","t":8,"pi":[{"n":"instruction","pt":$n[4].SubmeshInstruction,"ps":0},{"n":"updateTriangles","dv":true,"o":true,"pt":$n[0].Boolean,"ps":1}],"sn":"AddSubmesh","rt":$n[0].Void,"p":[$n[4].SubmeshInstruction,$n[0].Boolean]},{"a":2,"n":"Begin","t":8,"sn":"Begin","rt":$n[0].Void},{"a":2,"n":"BuildMesh","t":8,"pi":[{"n":"instruction","pt":$n[4].SkeletonRendererInstruction,"ps":0},{"n":"updateTriangles","pt":$n[0].Boolean,"ps":1}],"sn":"BuildMesh","rt":$n[0].Void,"p":[$n[4].SkeletonRendererInstruction,$n[0].Boolean]},{"a":2,"n":"BuildMeshWithArrays","t":8,"pi":[{"n":"instruction","pt":$n[4].SkeletonRendererInstruction,"ps":0},{"n":"updateTriangles","pt":$n[0].Boolean,"ps":1}],"sn":"BuildMeshWithArrays","rt":$n[0].Void,"p":[$n[4].SkeletonRendererInstruction,$n[0].Boolean]},{"a":2,"n":"EnsureVertexCapacity","t":8,"pi":[{"n":"minimumVertexCount","pt":$n[0].Int32,"ps":0},{"n":"inlcudeTintBlack","dv":false,"o":true,"pt":$n[0].Boolean,"ps":1},{"n":"includeTangents","dv":false,"o":true,"pt":$n[0].Boolean,"ps":2},{"n":"includeNormals","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"EnsureVertexCapacity","rt":$n[0].Void,"p":[$n[0].Int32,$n[0].Boolean,$n[0].Boolean,$n[0].Boolean]},{"a":2,"n":"FillLateVertexData","t":8,"pi":[{"n":"mesh","pt":$n[1].Mesh,"ps":0}],"sn":"FillLateVertexData","rt":$n[0].Void,"p":[$n[1].Mesh]},{"a":2,"n":"FillMeshLocal","is":true,"t":8,"pi":[{"n":"mesh","pt":$n[1].Mesh,"ps":0},{"n":"regionAttachment","pt":$n[3].RegionAttachment,"ps":1}],"sn":"FillMeshLocal$1","rt":$n[0].Void,"p":[$n[1].Mesh,$n[3].RegionAttachment]},{"a":2,"n":"FillMeshLocal","is":true,"t":8,"pi":[{"n":"mesh","pt":$n[1].Mesh,"ps":0},{"n":"meshAttachment","pt":$n[3].MeshAttachment,"ps":1},{"n":"skeletonData","pt":$n[3].SkeletonData,"ps":2}],"sn":"FillMeshLocal","rt":$n[0].Void,"p":[$n[1].Mesh,$n[3].MeshAttachment,$n[3].SkeletonData]},{"a":2,"n":"FillTriangles","t":8,"pi":[{"n":"mesh","pt":$n[1].Mesh,"ps":0}],"sn":"FillTriangles","rt":$n[0].Void,"p":[$n[1].Mesh]},{"a":2,"n":"FillVertexData","t":8,"pi":[{"n":"mesh","pt":$n[1].Mesh,"ps":0}],"sn":"FillVertexData","rt":$n[0].Void,"p":[$n[1].Mesh]},{"a":2,"n":"GenerateSingleSubmeshInstruction","is":true,"t":8,"pi":[{"n":"instructionOutput","pt":$n[4].SkeletonRendererInstruction,"ps":0},{"n":"skeleton","pt":$n[3].Skeleton,"ps":1},{"n":"material","pt":$n[1].Material,"ps":2}],"sn":"GenerateSingleSubmeshInstruction","rt":$n[0].Void,"p":[$n[4].SkeletonRendererInstruction,$n[3].Skeleton,$n[1].Material]},{"a":2,"n":"GenerateSkeletonRendererInstruction","is":true,"t":8,"pi":[{"n":"instructionOutput","pt":$n[4].SkeletonRendererInstruction,"ps":0},{"n":"skeleton","pt":$n[3].Skeleton,"ps":1},{"n":"customSlotMaterials","pt":$n[5].Dictionary$2(Spine.Slot,UnityEngine.Material),"ps":2},{"n":"separatorSlots","pt":$n[5].List$1(Spine.Slot),"ps":3},{"n":"generateMeshOverride","pt":$n[0].Boolean,"ps":4},{"n":"immutableTriangles","dv":false,"o":true,"pt":$n[0].Boolean,"ps":5}],"sn":"GenerateSkeletonRendererInstruction","rt":$n[0].Void,"p":[$n[4].SkeletonRendererInstruction,$n[3].Skeleton,$n[5].Dictionary$2(Spine.Slot,UnityEngine.Material),$n[5].List$1(Spine.Slot),$n[0].Boolean,$n[0].Boolean]},{"a":2,"n":"GetMeshBounds","t":8,"sn":"GetMeshBounds","rt":$n[1].Bounds},{"a":2,"n":"RequiresMultipleSubmeshesByDrawOrder","is":true,"t":8,"pi":[{"n":"skeleton","pt":$n[3].Skeleton,"ps":0}],"sn":"RequiresMultipleSubmeshesByDrawOrder","rt":$n[0].Boolean,"p":[$n[3].Skeleton],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"ScaleVertexData","t":8,"pi":[{"n":"scale","pt":$n[0].Single,"ps":0}],"sn":"ScaleVertexData","rt":$n[0].Void,"p":[$n[0].Single]},{"a":4,"n":"SolveTangents2DBuffer","is":true,"t":8,"pi":[{"n":"tangents","pt":System.Array.type(UnityEngine.Vector4),"ps":0},{"n":"tempTanBuffer","pt":System.Array.type(UnityEngine.Vector2),"ps":1},{"n":"vertexCount","pt":$n[0].Int32,"ps":2}],"sn":"SolveTangents2DBuffer","rt":$n[0].Void,"p":[System.Array.type(UnityEngine.Vector4),System.Array.type(UnityEngine.Vector2),$n[0].Int32]},{"a":4,"n":"SolveTangents2DEnsureSize","is":true,"t":8,"pi":[{"n":"tangentBuffer","ref":true,"pt":System.Array.type(UnityEngine.Vector4),"ps":0},{"n":"tempTanBuffer","ref":true,"pt":System.Array.type(UnityEngine.Vector2),"ps":1},{"n":"vertexCount","pt":$n[0].Int32,"ps":2},{"n":"vertexBufferLength","pt":$n[0].Int32,"ps":3}],"sn":"SolveTangents2DEnsureSize","rt":$n[0].Void,"p":[System.Array.type(UnityEngine.Vector4),System.Array.type(UnityEngine.Vector2),$n[0].Int32,$n[0].Int32]},{"a":4,"n":"SolveTangents2DTriangles","is":true,"t":8,"pi":[{"n":"tempTanBuffer","pt":System.Array.type(UnityEngine.Vector2),"ps":0},{"n":"triangles","pt":$n[0].Array.type(System.Int32),"ps":1},{"n":"triangleCount","pt":$n[0].Int32,"ps":2},{"n":"vertices","pt":System.Array.type(UnityEngine.Vector3),"ps":3},{"n":"uvs","pt":System.Array.type(UnityEngine.Vector2),"ps":4},{"n":"vertexCount","pt":$n[0].Int32,"ps":5}],"sn":"SolveTangents2DTriangles","rt":$n[0].Void,"p":[System.Array.type(UnityEngine.Vector2),$n[0].Array.type(System.Int32),$n[0].Int32,System.Array.type(UnityEngine.Vector3),System.Array.type(UnityEngine.Vector2),$n[0].Int32]},{"a":2,"n":"SubmeshIndexCount","t":8,"pi":[{"n":"submeshIndex","pt":$n[0].Int32,"ps":0}],"sn":"SubmeshIndexCount","rt":$n[0].Int32,"p":[$n[0].Int32],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"TrimExcess","t":8,"sn":"TrimExcess","rt":$n[0].Void},{"a":2,"n":"TryReplaceMaterials","is":true,"t":8,"pi":[{"n":"workingSubmeshInstructions","pt":$n[3].ExposedList$1(Spine.Unity.SubmeshInstruction),"ps":0},{"n":"customMaterialOverride","pt":$n[5].Dictionary$2(UnityEngine.Material,UnityEngine.Material),"ps":1}],"sn":"TryReplaceMaterials","rt":$n[0].Void,"p":[$n[3].ExposedList$1(Spine.Unity.SubmeshInstruction),$n[5].Dictionary$2(UnityEngine.Material,UnityEngine.Material)]},{"a":2,"n":"Buffers","t":16,"rt":$n[4].MeshGeneratorBuffers,"g":{"a":2,"n":"get_Buffers","t":8,"rt":$n[4].MeshGeneratorBuffers,"fg":"Buffers"},"fn":"Buffers"},{"a":2,"n":"VertexCount","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_VertexCount","t":8,"rt":$n[0].Int32,"fg":"VertexCount","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"VertexCount"},{"a":1,"n":"AttachmentColors32","is":true,"t":4,"rt":$n[5].List$1(UnityEngine.Color32),"sn":"AttachmentColors32"},{"a":1,"n":"AttachmentIndices","is":true,"t":4,"rt":$n[5].List$1(System.Int32),"sn":"AttachmentIndices"},{"a":1,"n":"AttachmentUVs","is":true,"t":4,"rt":$n[5].List$1(UnityEngine.Vector2),"sn":"AttachmentUVs"},{"a":1,"n":"AttachmentVerts","is":true,"t":4,"rt":$n[5].List$1(UnityEngine.Vector3),"sn":"AttachmentVerts"},{"a":1,"n":"BoundsMaxDefault","is":true,"t":4,"rt":$n[0].Single,"sn":"BoundsMaxDefault","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"BoundsMinDefault","is":true,"t":4,"rt":$n[0].Single,"sn":"BoundsMinDefault","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"clipper","t":4,"rt":$n[3].SkeletonClipping,"sn":"clipper"},{"a":3,"n":"colorBuffer","t":4,"rt":$n[3].ExposedList$1(UnityEngine.Color32),"sn":"colorBuffer","ro":true},{"a":1,"n":"meshBoundsMax","t":4,"rt":$n[1].Vector2,"sn":"meshBoundsMax"},{"a":1,"n":"meshBoundsMin","t":4,"rt":$n[1].Vector2,"sn":"meshBoundsMin"},{"a":1,"n":"meshBoundsThickness","t":4,"rt":$n[0].Single,"sn":"meshBoundsThickness","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"normals","t":4,"rt":System.Array.type(UnityEngine.Vector3),"sn":"normals"},{"a":1,"n":"regionTriangles","t":4,"rt":$n[0].Array.type(System.Int32),"sn":"regionTriangles"},{"a":2,"n":"settings","t":4,"rt":$n[4].MeshGenerator.Settings,"sn":"settings"},{"a":1,"n":"submeshIndex","t":4,"rt":$n[0].Int32,"sn":"submeshIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":3,"n":"submeshes","t":4,"rt":$n[3].ExposedList$1(Spine.ExposedList$1(System.Int32)),"sn":"submeshes","ro":true},{"a":1,"n":"tangents","t":4,"rt":System.Array.type(UnityEngine.Vector4),"sn":"tangents"},{"a":1,"n":"tempTanBuffer","t":4,"rt":System.Array.type(UnityEngine.Vector2),"sn":"tempTanBuffer"},{"a":1,"n":"tempVerts","t":4,"rt":$n[0].Array.type(System.Single),"sn":"tempVerts"},{"a":1,"n":"uv2","t":4,"rt":$n[3].ExposedList$1(UnityEngine.Vector2),"sn":"uv2"},{"a":1,"n":"uv3","t":4,"rt":$n[3].ExposedList$1(UnityEngine.Vector2),"sn":"uv3"},{"a":3,"n":"uvBuffer","t":4,"rt":$n[3].ExposedList$1(UnityEngine.Vector2),"sn":"uvBuffer","ro":true},{"a":3,"n":"vertexBuffer","t":4,"rt":$n[3].ExposedList$1(UnityEngine.Vector3),"sn":"vertexBuffer","ro":true}]}; }, $n);
    /*Spine.Unity.MeshGenerator end.*/

    /*Spine.Unity.MeshGenerator+Settings start.*/
    $m("Spine.Unity.MeshGenerator.Settings", function () { return {"td":$n[4].MeshGenerator,"att":1057034,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Default","is":true,"t":16,"rt":$n[4].MeshGenerator.Settings,"g":{"a":2,"n":"get_Default","t":8,"rt":$n[4].MeshGenerator.Settings,"fg":"Default","is":true},"fn":"Default"},{"a":2,"n":"addNormals","t":4,"rt":$n[0].Boolean,"sn":"addNormals","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"calculateTangents","t":4,"rt":$n[0].Boolean,"sn":"calculateTangents","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.TooltipAttribute("Enable when using Additive blend mode at SkeletonGraphic under a CanvasGroup. When enabled, Additive alpha value is stored at uv2.g instead of color.a to capture CanvasGroup modifying color.a.")],"a":2,"n":"canvasGroupTintBlack","t":4,"rt":$n[0].Boolean,"sn":"canvasGroupTintBlack","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"immutableTriangles","t":4,"rt":$n[0].Boolean,"sn":"immutableTriangles","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SpaceAttribute.ctor(),new UnityEngine.HeaderAttribute("Vertex Data")],"a":2,"n":"pmaVertexColors","t":4,"rt":$n[0].Boolean,"sn":"pmaVertexColors","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"tintBlack","t":4,"rt":$n[0].Boolean,"sn":"tintBlack","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"useClipping","t":4,"rt":$n[0].Boolean,"sn":"useClipping","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SpaceAttribute.ctor(),new UnityEngine.RangeAttribute(-0.1, 0.0)],"a":2,"n":"zSpacing","t":4,"rt":$n[0].Single,"sn":"zSpacing","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*Spine.Unity.MeshGenerator+Settings end.*/

    /*Spine.Unity.MeshRendererBuffers start.*/
    $m("Spine.Unity.MeshRendererBuffers", function () { return {"nested":[$n[4].MeshRendererBuffers.SmartMesh],"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Clear","t":8,"sn":"Clear","rt":$n[0].Void},{"a":2,"n":"Dispose","t":8,"sn":"Dispose","rt":$n[0].Void},{"a":2,"n":"GetNextMesh","t":8,"sn":"GetNextMesh","rt":$n[4].MeshRendererBuffers.SmartMesh},{"a":2,"n":"GetUpdatedSharedMaterialsArray","t":8,"sn":"GetUpdatedSharedMaterialsArray","rt":System.Array.type(UnityEngine.Material)},{"a":2,"n":"Initialize","t":8,"sn":"Initialize","rt":$n[0].Void},{"a":2,"n":"MaterialsChangedInLastUpdate","t":8,"sn":"MaterialsChangedInLastUpdate","rt":$n[0].Boolean,"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"UpdateSharedMaterials","t":8,"pi":[{"n":"instructions","pt":$n[3].ExposedList$1(Spine.Unity.SubmeshInstruction),"ps":0}],"sn":"UpdateSharedMaterials","rt":$n[0].Void,"p":[$n[3].ExposedList$1(Spine.Unity.SubmeshInstruction)]},{"a":1,"n":"doubleBufferedMesh","t":4,"rt":$n[4].DoubleBuffered$1(Spine.Unity.MeshRendererBuffers.SmartMesh),"sn":"doubleBufferedMesh"},{"a":4,"n":"sharedMaterials","t":4,"rt":System.Array.type(UnityEngine.Material),"sn":"sharedMaterials"},{"a":4,"n":"submeshMaterials","t":4,"rt":$n[3].ExposedList$1(UnityEngine.Material),"sn":"submeshMaterials","ro":true}]}; }, $n);
    /*Spine.Unity.MeshRendererBuffers end.*/

    /*Spine.Unity.MeshRendererBuffers+SmartMesh start.*/
    $m("Spine.Unity.MeshRendererBuffers.SmartMesh", function () { return {"td":$n[4].MeshRendererBuffers,"att":1048578,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Clear","t":8,"sn":"Clear","rt":$n[0].Void},{"a":2,"n":"Dispose","t":8,"sn":"Dispose","rt":$n[0].Void},{"a":2,"n":"instructionUsed","t":4,"rt":$n[4].SkeletonRendererInstruction,"sn":"instructionUsed"},{"a":2,"n":"mesh","t":4,"rt":$n[1].Mesh,"sn":"mesh"}]}; }, $n);
    /*Spine.Unity.MeshRendererBuffers+SmartMesh end.*/

    /*Spine.Unity.SkeletonRendererInstruction start.*/
    $m("Spine.Unity.SkeletonRendererInstruction", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Clear","t":8,"sn":"Clear","rt":$n[0].Void},{"a":2,"n":"Dispose","t":8,"sn":"Dispose","rt":$n[0].Void},{"a":2,"n":"GeometryNotEqual","is":true,"t":8,"pi":[{"n":"a","pt":$n[4].SkeletonRendererInstruction,"ps":0},{"n":"b","pt":$n[4].SkeletonRendererInstruction,"ps":1}],"sn":"GeometryNotEqual","rt":$n[0].Boolean,"p":[$n[4].SkeletonRendererInstruction,$n[4].SkeletonRendererInstruction],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"Set","t":8,"pi":[{"n":"other","pt":$n[4].SkeletonRendererInstruction,"ps":0}],"sn":"Set","rt":$n[0].Void,"p":[$n[4].SkeletonRendererInstruction]},{"a":2,"n":"SetWithSubset","t":8,"pi":[{"n":"instructions","pt":$n[3].ExposedList$1(Spine.Unity.SubmeshInstruction),"ps":0},{"n":"startSubmesh","pt":$n[0].Int32,"ps":1},{"n":"endSubmesh","pt":$n[0].Int32,"ps":2}],"sn":"SetWithSubset","rt":$n[0].Void,"p":[$n[3].ExposedList$1(Spine.Unity.SubmeshInstruction),$n[0].Int32,$n[0].Int32]},{"a":2,"n":"attachments","t":4,"rt":$n[3].ExposedList$1(spine.Attachment),"sn":"attachments","ro":true},{"a":2,"n":"hasActiveClipping","t":4,"rt":$n[0].Boolean,"sn":"hasActiveClipping","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"immutableTriangles","t":4,"rt":$n[0].Boolean,"sn":"immutableTriangles","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"rawVertexCount","t":4,"rt":$n[0].Int32,"sn":"rawVertexCount","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"submeshInstructions","t":4,"rt":$n[3].ExposedList$1(Spine.Unity.SubmeshInstruction),"sn":"submeshInstructions","ro":true}]}; }, $n);
    /*Spine.Unity.SkeletonRendererInstruction end.*/

    /*Spine.Unity.SpineMesh start.*/
    $m("Spine.Unity.SpineMesh", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"NewSkeletonMesh","is":true,"t":8,"sn":"NewSkeletonMesh","rt":$n[1].Mesh},{"a":4,"n":"MeshHideflags","is":true,"t":4,"rt":$n[1].HideFlags,"sn":"MeshHideflags","box":function ($v) { return Bridge.box($v, UnityEngine.HideFlags, System.Enum.toStringFn(UnityEngine.HideFlags));}}]}; }, $n);
    /*Spine.Unity.SpineMesh end.*/

    /*Spine.Unity.SubmeshInstruction start.*/
    $m("Spine.Unity.SubmeshInstruction", function () { return {"att":1048841,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"ov":true,"a":2,"n":"ToString","t":8,"sn":"toString","rt":$n[0].String},{"a":2,"n":"SlotCount","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_SlotCount","t":8,"rt":$n[0].Int32,"fg":"SlotCount","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"SlotCount"},{"a":2,"n":"endSlot","t":4,"rt":$n[0].Int32,"sn":"endSlot","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"forceSeparate","t":4,"rt":$n[0].Boolean,"sn":"forceSeparate","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"hasClipping","t":4,"rt":$n[0].Boolean,"sn":"hasClipping","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"hasPMAAdditiveSlot","t":4,"rt":$n[0].Boolean,"sn":"hasPMAAdditiveSlot","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"material","t":4,"rt":$n[1].Material,"sn":"material"},{"a":2,"n":"preActiveClippingSlotSource","t":4,"rt":$n[0].Int32,"sn":"preActiveClippingSlotSource","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"rawFirstVertexIndex","t":4,"rt":$n[0].Int32,"sn":"rawFirstVertexIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"rawTriangleCount","t":4,"rt":$n[0].Int32,"sn":"rawTriangleCount","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"rawVertexCount","t":4,"rt":$n[0].Int32,"sn":"rawVertexCount","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"skeleton","t":4,"rt":$n[3].Skeleton,"sn":"skeleton"},{"a":2,"n":"startSlot","t":4,"rt":$n[0].Int32,"sn":"startSlot","box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.Unity.SubmeshInstruction end.*/

    /*Spine.Unity.BlendModeMaterialsAsset start.*/
    $m("Spine.Unity.BlendModeMaterialsAsset", function () { return {"nested":[$n[4].BlendModeMaterialsAsset.AtlasMaterialCache],"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Spine/SkeletonData Modifiers/Blend Mode Materials", order: 200
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"ov":true,"a":2,"n":"Apply","t":8,"pi":[{"n":"skeletonData","pt":$n[3].SkeletonData,"ps":0}],"sn":"Apply","rt":$n[0].Void,"p":[$n[3].SkeletonData]},{"a":2,"n":"ApplyMaterials","is":true,"t":8,"pi":[{"n":"skeletonData","pt":$n[3].SkeletonData,"ps":0},{"n":"multiplyTemplate","pt":$n[1].Material,"ps":1},{"n":"screenTemplate","pt":$n[1].Material,"ps":2},{"n":"additiveTemplate","pt":$n[1].Material,"ps":3},{"n":"includeAdditiveSlots","pt":$n[0].Boolean,"ps":4}],"sn":"ApplyMaterials","rt":$n[0].Void,"p":[$n[3].SkeletonData,$n[1].Material,$n[1].Material,$n[1].Material,$n[0].Boolean]},{"a":2,"n":"additiveMaterialTemplate","t":4,"rt":$n[1].Material,"sn":"additiveMaterialTemplate"},{"a":2,"n":"applyAdditiveMaterial","t":4,"rt":$n[0].Boolean,"sn":"applyAdditiveMaterial","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"multiplyMaterialTemplate","t":4,"rt":$n[1].Material,"sn":"multiplyMaterialTemplate"},{"a":2,"n":"screenMaterialTemplate","t":4,"rt":$n[1].Material,"sn":"screenMaterialTemplate"}]}; }, $n);
    /*Spine.Unity.BlendModeMaterialsAsset end.*/

    /*Spine.Unity.BlendModeMaterialsAsset+AtlasMaterialCache start.*/
    $m("Spine.Unity.BlendModeMaterialsAsset.AtlasMaterialCache", function () { return {"td":$n[4].BlendModeMaterialsAsset,"att":1048579,"a":1,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"CloneAtlasRegionWithMaterial","t":8,"pi":[{"n":"originalRegion","pt":$n[3].AtlasRegion,"ps":0},{"n":"materialTemplate","pt":$n[1].Material,"ps":1}],"sn":"CloneAtlasRegionWithMaterial","rt":$n[3].AtlasRegion,"p":[$n[3].AtlasRegion,$n[1].Material]},{"a":2,"n":"Dispose","t":8,"sn":"Dispose","rt":$n[0].Void},{"a":1,"n":"GetAtlasPageWithMaterial","t":8,"pi":[{"n":"originalPage","pt":$n[3].AtlasPage,"ps":0},{"n":"materialTemplate","pt":$n[1].Material,"ps":1}],"sn":"GetAtlasPageWithMaterial","rt":$n[3].AtlasPage,"p":[$n[3].AtlasPage,$n[1].Material]},{"a":1,"n":"cache","t":4,"rt":$n[5].Dictionary$2(System.Collections.Generic.KeyValuePair$2(Spine.AtlasPage,UnityEngine.Material),Spine.AtlasPage),"sn":"cache","ro":true}]}; }, $n);
    /*Spine.Unity.BlendModeMaterialsAsset+AtlasMaterialCache end.*/

    /*Spine.Unity.SpineAttributeBase start.*/
    $m("Spine.Unity.SpineAttributeBase", function () { return {"att":1048705,"a":2,"m":[{"a":3,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"dataField","t":4,"rt":$n[0].String,"sn":"dataField"},{"a":2,"n":"fallbackToTextField","t":4,"rt":$n[0].Boolean,"sn":"fallbackToTextField","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"includeNone","t":4,"rt":$n[0].Boolean,"sn":"includeNone","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"startsWith","t":4,"rt":$n[0].String,"sn":"startsWith"}]}; }, $n);
    /*Spine.Unity.SpineAttributeBase end.*/

    /*Spine.Unity.SpineBone start.*/
    $m("Spine.Unity.SpineBone", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].String,$n[0].String,$n[0].Boolean,$n[0].Boolean],"pi":[{"n":"startsWith","dv":"","o":true,"pt":$n[0].String,"ps":0},{"n":"dataField","dv":"","o":true,"pt":$n[0].String,"ps":1},{"n":"includeNone","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2},{"n":"fallbackToTextField","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"ctor"},{"a":2,"n":"GetBone","is":true,"t":8,"pi":[{"n":"boneName","pt":$n[0].String,"ps":0},{"n":"renderer","pt":$n[4].SkeletonRenderer,"ps":1}],"sn":"getBone","rt":$n[3].Bone,"p":[$n[0].String,$n[4].SkeletonRenderer]},{"a":2,"n":"GetBoneData","is":true,"t":8,"pi":[{"n":"boneName","pt":$n[0].String,"ps":0},{"n":"skeletonDataAsset","pt":$n[4].SkeletonDataAsset,"ps":1}],"sn":"getBoneData","rt":spine.BoneData,"p":[$n[0].String,$n[4].SkeletonDataAsset]}]}; }, $n);
    /*Spine.Unity.SpineBone end.*/

    /*Spine.Unity.SpineSlot start.*/
    $m("Spine.Unity.SpineSlot", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].String,$n[0].String,$n[0].Boolean,$n[0].Boolean,$n[0].Boolean],"pi":[{"n":"startsWith","dv":"","o":true,"pt":$n[0].String,"ps":0},{"n":"dataField","dv":"","o":true,"pt":$n[0].String,"ps":1},{"n":"containsBoundingBoxes","dv":false,"o":true,"pt":$n[0].Boolean,"ps":2},{"n":"includeNone","dv":true,"o":true,"pt":$n[0].Boolean,"ps":3},{"n":"fallbackToTextField","dv":false,"o":true,"pt":$n[0].Boolean,"ps":4}],"sn":"ctor"},{"a":2,"n":"containsBoundingBoxes","t":4,"rt":$n[0].Boolean,"sn":"containsBoundingBoxes","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.SpineSlot end.*/

    /*Spine.Unity.SpineAnimation start.*/
    $m("Spine.Unity.SpineAnimation", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].String,$n[0].String,$n[0].Boolean,$n[0].Boolean],"pi":[{"n":"startsWith","dv":"","o":true,"pt":$n[0].String,"ps":0},{"n":"dataField","dv":"","o":true,"pt":$n[0].String,"ps":1},{"n":"includeNone","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2},{"n":"fallbackToTextField","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"ctor"}]}; }, $n);
    /*Spine.Unity.SpineAnimation end.*/

    /*Spine.Unity.SpineEvent start.*/
    $m("Spine.Unity.SpineEvent", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].String,$n[0].String,$n[0].Boolean,$n[0].Boolean,$n[0].Boolean],"pi":[{"n":"startsWith","dv":"","o":true,"pt":$n[0].String,"ps":0},{"n":"dataField","dv":"","o":true,"pt":$n[0].String,"ps":1},{"n":"includeNone","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2},{"n":"fallbackToTextField","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3},{"n":"audioOnly","dv":false,"o":true,"pt":$n[0].Boolean,"ps":4}],"sn":"ctor"},{"a":2,"n":"audioOnly","t":4,"rt":$n[0].Boolean,"sn":"audioOnly","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.SpineEvent end.*/

    /*Spine.Unity.SpineIkConstraint start.*/
    $m("Spine.Unity.SpineIkConstraint", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].String,$n[0].String,$n[0].Boolean,$n[0].Boolean],"pi":[{"n":"startsWith","dv":"","o":true,"pt":$n[0].String,"ps":0},{"n":"dataField","dv":"","o":true,"pt":$n[0].String,"ps":1},{"n":"includeNone","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2},{"n":"fallbackToTextField","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"ctor"}]}; }, $n);
    /*Spine.Unity.SpineIkConstraint end.*/

    /*Spine.Unity.SpineTransformConstraint start.*/
    $m("Spine.Unity.SpineTransformConstraint", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].String,$n[0].String,$n[0].Boolean,$n[0].Boolean],"pi":[{"n":"startsWith","dv":"","o":true,"pt":$n[0].String,"ps":0},{"n":"dataField","dv":"","o":true,"pt":$n[0].String,"ps":1},{"n":"includeNone","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2},{"n":"fallbackToTextField","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"ctor"}]}; }, $n);
    /*Spine.Unity.SpineTransformConstraint end.*/

    /*Spine.Unity.SpinePathConstraint start.*/
    $m("Spine.Unity.SpinePathConstraint", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].String,$n[0].String,$n[0].Boolean,$n[0].Boolean],"pi":[{"n":"startsWith","dv":"","o":true,"pt":$n[0].String,"ps":0},{"n":"dataField","dv":"","o":true,"pt":$n[0].String,"ps":1},{"n":"includeNone","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2},{"n":"fallbackToTextField","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"ctor"}]}; }, $n);
    /*Spine.Unity.SpinePathConstraint end.*/

    /*Spine.Unity.SpineSkin start.*/
    $m("Spine.Unity.SpineSkin", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].String,$n[0].String,$n[0].Boolean,$n[0].Boolean,$n[0].Boolean],"pi":[{"n":"startsWith","dv":"","o":true,"pt":$n[0].String,"ps":0},{"n":"dataField","dv":"","o":true,"pt":$n[0].String,"ps":1},{"n":"includeNone","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2},{"n":"fallbackToTextField","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3},{"n":"defaultAsEmptyString","dv":false,"o":true,"pt":$n[0].Boolean,"ps":4}],"sn":"ctor"},{"a":2,"n":"defaultAsEmptyString","t":4,"rt":$n[0].Boolean,"sn":"defaultAsEmptyString","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.SpineSkin end.*/

    /*Spine.Unity.SpineAttachment start.*/
    $m("Spine.Unity.SpineAttachment", function () { return {"nested":[$n[4].SpineAttachment.Hierarchy],"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Boolean,$n[0].Boolean,$n[0].Boolean,$n[0].String,$n[0].String,$n[0].String,$n[0].Boolean,$n[0].Boolean],"pi":[{"n":"currentSkinOnly","dv":true,"o":true,"pt":$n[0].Boolean,"ps":0},{"n":"returnAttachmentPath","dv":false,"o":true,"pt":$n[0].Boolean,"ps":1},{"n":"placeholdersOnly","dv":false,"o":true,"pt":$n[0].Boolean,"ps":2},{"n":"slotField","dv":"","o":true,"pt":$n[0].String,"ps":3},{"n":"dataField","dv":"","o":true,"pt":$n[0].String,"ps":4},{"n":"skinField","dv":"","o":true,"pt":$n[0].String,"ps":5},{"n":"includeNone","dv":true,"o":true,"pt":$n[0].Boolean,"ps":6},{"n":"fallbackToTextField","dv":false,"o":true,"pt":$n[0].Boolean,"ps":7}],"sn":"ctor"},{"a":2,"n":"GetAttachment","is":true,"t":8,"pi":[{"n":"attachmentPath","pt":$n[0].String,"ps":0},{"n":"skeletonData","pt":$n[3].SkeletonData,"ps":1}],"sn":"getAttachment","rt":spine.Attachment,"p":[$n[0].String,$n[3].SkeletonData]},{"a":2,"n":"GetAttachment","is":true,"t":8,"pi":[{"n":"attachmentPath","pt":$n[0].String,"ps":0},{"n":"skeletonDataAsset","pt":$n[4].SkeletonDataAsset,"ps":1}],"sn":"getAttachment$1","rt":spine.Attachment,"p":[$n[0].String,$n[4].SkeletonDataAsset]},{"a":2,"n":"GetHierarchy","is":true,"t":8,"pi":[{"n":"fullPath","pt":$n[0].String,"ps":0}],"sn":"getHierarchy","rt":$n[4].SpineAttachment.Hierarchy,"p":[$n[0].String]},{"a":2,"n":"currentSkinOnly","t":4,"rt":$n[0].Boolean,"sn":"currentSkinOnly","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"placeholdersOnly","t":4,"rt":$n[0].Boolean,"sn":"placeholdersOnly","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"returnAttachmentPath","t":4,"rt":$n[0].Boolean,"sn":"returnAttachmentPath","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"skinField","t":4,"rt":$n[0].String,"sn":"skinField"},{"a":2,"n":"slotField","t":4,"rt":$n[0].String,"sn":"slotField"}]}; }, $n);
    /*Spine.Unity.SpineAttachment end.*/

    /*Spine.Unity.SpineAttachment+Hierarchy start.*/
    $m("Spine.Unity.SpineAttachment.Hierarchy", function () { return {"td":$n[4].SpineAttachment,"att":1048842,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":".ctor","t":1,"p":[$n[0].String],"pi":[{"n":"fullPath","pt":$n[0].String,"ps":0}],"sn":"$ctor1"},{"a":2,"n":"name","t":4,"rt":$n[0].String,"sn":"name"},{"a":2,"n":"skin","t":4,"rt":$n[0].String,"sn":"skin"},{"a":2,"n":"slot","t":4,"rt":$n[0].String,"sn":"slot"}]}; }, $n);
    /*Spine.Unity.SpineAttachment+Hierarchy end.*/

    /*Spine.Unity.SpineAtlasRegion start.*/
    $m("Spine.Unity.SpineAtlasRegion", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].String],"pi":[{"n":"atlasAssetField","dv":"","o":true,"pt":$n[0].String,"ps":0}],"sn":"ctor"},{"a":2,"n":"atlasAssetField","t":4,"rt":$n[0].String,"sn":"atlasAssetField"}]}; }, $n);
    /*Spine.Unity.SpineAtlasRegion end.*/

    /*Spine.Unity.MathUtilities start.*/
    $m("Spine.Unity.MathUtilities", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"InverseLerp","is":true,"t":8,"pi":[{"n":"a","pt":$n[0].Single,"ps":0},{"n":"b","pt":$n[0].Single,"ps":1},{"n":"value","pt":$n[0].Single,"ps":2}],"sn":"InverseLerp","rt":$n[0].Single,"p":[$n[0].Single,$n[0].Single,$n[0].Single],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"InverseLerp","is":true,"t":8,"pi":[{"n":"a","pt":$n[1].Vector2,"ps":0},{"n":"b","pt":$n[1].Vector2,"ps":1},{"n":"value","pt":$n[1].Vector2,"ps":2}],"sn":"InverseLerp$1","rt":$n[1].Vector2,"p":[$n[1].Vector2,$n[1].Vector2,$n[1].Vector2]},{"a":2,"n":"InverseLerp","is":true,"t":8,"pi":[{"n":"a","pt":$n[1].Vector3,"ps":0},{"n":"b","pt":$n[1].Vector3,"ps":1},{"n":"value","pt":$n[1].Vector3,"ps":2}],"sn":"InverseLerp$2","rt":$n[1].Vector3,"p":[$n[1].Vector3,$n[1].Vector3,$n[1].Vector3]},{"a":2,"n":"InverseLerp","is":true,"t":8,"pi":[{"n":"a","pt":$n[1].Vector4,"ps":0},{"n":"b","pt":$n[1].Vector4,"ps":1},{"n":"value","pt":$n[1].Vector4,"ps":2}],"sn":"InverseLerp$3","rt":$n[1].Vector4,"p":[$n[1].Vector4,$n[1].Vector4,$n[1].Vector4]}]}; }, $n);
    /*Spine.Unity.MathUtilities end.*/

    /*Spine.Unity.SettingsTriState start.*/
    $m("Spine.Unity.SettingsTriState", function () { return {"att":257,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Disable","is":true,"t":4,"rt":$n[4].SettingsTriState,"sn":"Disable","box":function ($v) { return Bridge.box($v, Spine.Unity.SettingsTriState, System.Enum.toStringFn(Spine.Unity.SettingsTriState));}},{"a":2,"n":"Enable","is":true,"t":4,"rt":$n[4].SettingsTriState,"sn":"Enable","box":function ($v) { return Bridge.box($v, Spine.Unity.SettingsTriState, System.Enum.toStringFn(Spine.Unity.SettingsTriState));}},{"a":2,"n":"UseGlobalSetting","is":true,"t":4,"rt":$n[4].SettingsTriState,"sn":"UseGlobalSetting","box":function ($v) { return Bridge.box($v, Spine.Unity.SettingsTriState, System.Enum.toStringFn(Spine.Unity.SettingsTriState));}}]}; }, $n);
    /*Spine.Unity.SettingsTriState end.*/

    /*Spine.Unity.SkeletonExtensions start.*/
    $m("Spine.Unity.SkeletonExtensions", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"GetColor","is":true,"t":8,"pi":[{"n":"a","pt":$n[3].MeshAttachment,"ps":0}],"sn":"GetColor","rt":$n[1].Color,"p":[$n[3].MeshAttachment]},{"a":2,"n":"GetColor","is":true,"t":8,"pi":[{"n":"a","pt":$n[3].RegionAttachment,"ps":0}],"sn":"GetColor$1","rt":$n[1].Color,"p":[$n[3].RegionAttachment]},{"a":2,"n":"GetColor","is":true,"t":8,"pi":[{"n":"s","pt":$n[3].Skeleton,"ps":0}],"sn":"GetColor$2","rt":$n[1].Color,"p":[$n[3].Skeleton]},{"a":2,"n":"GetColor","is":true,"t":8,"pi":[{"n":"s","pt":$n[3].Slot,"ps":0}],"sn":"GetColor$3","rt":$n[1].Color,"p":[$n[3].Slot]},{"a":2,"n":"GetColorTintBlack","is":true,"t":8,"pi":[{"n":"s","pt":$n[3].Slot,"ps":0}],"sn":"GetColorTintBlack","rt":$n[1].Color,"p":[$n[3].Slot]},{"a":2,"n":"GetLocalPosition","is":true,"t":8,"pi":[{"n":"bone","pt":$n[3].Bone,"ps":0}],"sn":"GetLocalPosition","rt":$n[1].Vector2,"p":[$n[3].Bone]},{"a":2,"n":"GetLocalQuaternion","is":true,"t":8,"pi":[{"n":"bone","pt":$n[3].Bone,"ps":0}],"sn":"GetLocalQuaternion","rt":$n[1].Quaternion,"p":[$n[3].Bone]},{"a":2,"n":"GetLocalScale","is":true,"t":8,"pi":[{"n":"skeleton","pt":$n[3].Skeleton,"ps":0}],"sn":"GetLocalScale","rt":$n[1].Vector2,"p":[$n[3].Skeleton]},{"a":2,"n":"GetLocalVertices","is":true,"t":8,"pi":[{"n":"va","pt":spine.VertexAttachment,"ps":0},{"n":"slot","pt":$n[3].Slot,"ps":1},{"n":"buffer","pt":System.Array.type(UnityEngine.Vector2),"ps":2}],"sn":"GetLocalVertices","rt":System.Array.type(UnityEngine.Vector2),"p":[spine.VertexAttachment,$n[3].Slot,System.Array.type(UnityEngine.Vector2)]},{"a":2,"n":"GetMaterial","is":true,"t":8,"pi":[{"n":"a","pt":spine.Attachment,"ps":0}],"sn":"GetMaterial","rt":$n[1].Material,"p":[spine.Attachment]},{"a":2,"n":"GetMatrix4x4","is":true,"t":8,"pi":[{"n":"bone","pt":$n[3].Bone,"ps":0}],"sn":"GetMatrix4x4","rt":$n[1].Matrix4x4,"p":[$n[3].Bone]},{"a":2,"n":"GetQuaternion","is":true,"t":8,"pi":[{"n":"bone","pt":$n[3].Bone,"ps":0}],"sn":"GetQuaternion","rt":$n[1].Quaternion,"p":[$n[3].Bone]},{"a":2,"n":"GetSkeletonSpacePosition","is":true,"t":8,"pi":[{"n":"bone","pt":$n[3].Bone,"ps":0}],"sn":"GetSkeletonSpacePosition","rt":$n[1].Vector2,"p":[$n[3].Bone]},{"a":2,"n":"GetSkeletonSpacePosition","is":true,"t":8,"pi":[{"n":"bone","pt":$n[3].Bone,"ps":0},{"n":"boneLocal","pt":$n[1].Vector2,"ps":1}],"sn":"GetSkeletonSpacePosition$1","rt":$n[1].Vector2,"p":[$n[3].Bone,$n[1].Vector2]},{"a":2,"n":"GetWorldPosition","is":true,"t":8,"pi":[{"n":"bone","pt":$n[3].Bone,"ps":0},{"n":"spineGameObjectTransform","pt":$n[1].Transform,"ps":1}],"sn":"GetWorldPosition","rt":$n[1].Vector3,"p":[$n[3].Bone,$n[1].Transform]},{"a":2,"n":"GetWorldPosition","is":true,"t":8,"pi":[{"n":"bone","pt":$n[3].Bone,"ps":0},{"n":"spineGameObjectTransform","pt":$n[1].Transform,"ps":1},{"n":"positionScale","pt":$n[0].Single,"ps":2}],"sn":"GetWorldPosition$1","rt":$n[1].Vector3,"p":[$n[3].Bone,$n[1].Transform,$n[0].Single]},{"a":2,"n":"GetWorldPosition","is":true,"t":8,"pi":[{"n":"attachment","pt":$n[3].PointAttachment,"ps":0},{"n":"bone","pt":$n[3].Bone,"ps":1},{"n":"spineGameObjectTransform","pt":$n[1].Transform,"ps":2}],"sn":"GetWorldPosition$2","rt":$n[1].Vector3,"p":[$n[3].PointAttachment,$n[3].Bone,$n[1].Transform]},{"a":2,"n":"GetWorldPosition","is":true,"t":8,"pi":[{"n":"attachment","pt":$n[3].PointAttachment,"ps":0},{"n":"slot","pt":$n[3].Slot,"ps":1},{"n":"spineGameObjectTransform","pt":$n[1].Transform,"ps":2}],"sn":"GetWorldPosition$3","rt":$n[1].Vector3,"p":[$n[3].PointAttachment,$n[3].Slot,$n[1].Transform]},{"a":2,"n":"GetWorldToLocalMatrix","is":true,"t":8,"pi":[{"n":"bone","pt":$n[3].Bone,"ps":0},{"n":"ia","out":true,"pt":$n[0].Single,"ps":1},{"n":"ib","out":true,"pt":$n[0].Single,"ps":2},{"n":"ic","out":true,"pt":$n[0].Single,"ps":3},{"n":"id","out":true,"pt":$n[0].Single,"ps":4}],"sn":"GetWorldToLocalMatrix","rt":$n[0].Void,"p":[$n[3].Bone,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single]},{"a":2,"n":"GetWorldVertices","is":true,"t":8,"pi":[{"n":"a","pt":spine.VertexAttachment,"ps":0},{"n":"slot","pt":$n[3].Slot,"ps":1},{"n":"buffer","pt":System.Array.type(UnityEngine.Vector2),"ps":2}],"sn":"GetWorldVertices","rt":System.Array.type(UnityEngine.Vector2),"p":[spine.VertexAttachment,$n[3].Slot,System.Array.type(UnityEngine.Vector2)]},{"a":2,"n":"SetColor","is":true,"t":8,"pi":[{"n":"attachment","pt":$n[3].MeshAttachment,"ps":0},{"n":"color","pt":$n[1].Color,"ps":1}],"sn":"SetColor","rt":$n[0].Void,"p":[$n[3].MeshAttachment,$n[1].Color]},{"a":2,"n":"SetColor","is":true,"t":8,"pi":[{"n":"attachment","pt":$n[3].MeshAttachment,"ps":0},{"n":"color","pt":$n[1].Color32,"ps":1}],"sn":"SetColor$1","rt":$n[0].Void,"p":[$n[3].MeshAttachment,$n[1].Color32]},{"a":2,"n":"SetColor","is":true,"t":8,"pi":[{"n":"attachment","pt":$n[3].RegionAttachment,"ps":0},{"n":"color","pt":$n[1].Color,"ps":1}],"sn":"SetColor$2","rt":$n[0].Void,"p":[$n[3].RegionAttachment,$n[1].Color]},{"a":2,"n":"SetColor","is":true,"t":8,"pi":[{"n":"attachment","pt":$n[3].RegionAttachment,"ps":0},{"n":"color","pt":$n[1].Color32,"ps":1}],"sn":"SetColor$3","rt":$n[0].Void,"p":[$n[3].RegionAttachment,$n[1].Color32]},{"a":2,"n":"SetColor","is":true,"t":8,"pi":[{"n":"skeleton","pt":$n[3].Skeleton,"ps":0},{"n":"color","pt":$n[1].Color,"ps":1}],"sn":"SetColor$4","rt":$n[0].Void,"p":[$n[3].Skeleton,$n[1].Color]},{"a":2,"n":"SetColor","is":true,"t":8,"pi":[{"n":"skeleton","pt":$n[3].Skeleton,"ps":0},{"n":"color","pt":$n[1].Color32,"ps":1}],"sn":"SetColor$5","rt":$n[0].Void,"p":[$n[3].Skeleton,$n[1].Color32]},{"a":2,"n":"SetColor","is":true,"t":8,"pi":[{"n":"slot","pt":$n[3].Slot,"ps":0},{"n":"color","pt":$n[1].Color,"ps":1}],"sn":"SetColor$6","rt":$n[0].Void,"p":[$n[3].Slot,$n[1].Color]},{"a":2,"n":"SetColor","is":true,"t":8,"pi":[{"n":"slot","pt":$n[3].Slot,"ps":0},{"n":"color","pt":$n[1].Color32,"ps":1}],"sn":"SetColor$7","rt":$n[0].Void,"p":[$n[3].Slot,$n[1].Color32]},{"a":2,"n":"SetLocalPosition","is":true,"t":8,"pi":[{"n":"bone","pt":$n[3].Bone,"ps":0},{"n":"position","pt":$n[1].Vector2,"ps":1}],"sn":"SetLocalPosition","rt":$n[0].Void,"p":[$n[3].Bone,$n[1].Vector2]},{"a":2,"n":"SetLocalPosition","is":true,"t":8,"pi":[{"n":"bone","pt":$n[3].Bone,"ps":0},{"n":"position","pt":$n[1].Vector3,"ps":1}],"sn":"SetLocalPosition$1","rt":$n[0].Void,"p":[$n[3].Bone,$n[1].Vector3]},{"a":2,"n":"SetLocalScale","is":true,"t":8,"pi":[{"n":"skeleton","pt":$n[3].Skeleton,"ps":0},{"n":"scale","pt":$n[1].Vector2,"ps":1}],"sn":"SetLocalScale","rt":$n[0].Void,"p":[$n[3].Skeleton,$n[1].Vector2]},{"a":2,"n":"SetPositionSkeletonSpace","is":true,"t":8,"pi":[{"n":"bone","pt":$n[3].Bone,"ps":0},{"n":"skeletonSpacePosition","pt":$n[1].Vector2,"ps":1}],"sn":"SetPositionSkeletonSpace","rt":$n[1].Vector2,"p":[$n[3].Bone,$n[1].Vector2]},{"a":2,"n":"WorldToLocal","is":true,"t":8,"pi":[{"n":"bone","pt":$n[3].Bone,"ps":0},{"n":"worldPosition","pt":$n[1].Vector2,"ps":1}],"sn":"WorldToLocal","rt":$n[1].Vector2,"p":[$n[3].Bone,$n[1].Vector2]},{"a":1,"n":"ByteToFloat","is":true,"t":4,"rt":$n[0].Single,"sn":"ByteToFloat","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*Spine.Unity.SkeletonExtensions end.*/

    /*Spine.Unity.WaitForSpineAnimation start.*/
    $m("Spine.Unity.WaitForSpineAnimation", function () { return {"nested":[$n[4].WaitForSpineAnimation.AnimationEventTypes],"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[3].TrackEntry,$n[4].WaitForSpineAnimation.AnimationEventTypes],"pi":[{"n":"trackEntry","pt":$n[3].TrackEntry,"ps":0},{"n":"eventsToWaitFor","pt":$n[4].WaitForSpineAnimation.AnimationEventTypes,"ps":1}],"sn":"ctor"},{"a":1,"n":"HandleComplete","t":8,"pi":[{"n":"trackEntry","pt":$n[3].TrackEntry,"ps":0}],"sn":"HandleComplete","rt":$n[0].Void,"p":[$n[3].TrackEntry]},{"a":2,"n":"NowWaitFor","t":8,"pi":[{"n":"trackEntry","pt":$n[3].TrackEntry,"ps":0},{"n":"eventsToWaitFor","pt":$n[4].WaitForSpineAnimation.AnimationEventTypes,"ps":1}],"sn":"NowWaitFor","rt":$n[4].WaitForSpineAnimation,"p":[$n[3].TrackEntry,$n[4].WaitForSpineAnimation.AnimationEventTypes]},{"a":3,"n":"SafeSubscribe","t":8,"pi":[{"n":"trackEntry","pt":$n[3].TrackEntry,"ps":0},{"n":"eventsToWaitFor","pt":$n[4].WaitForSpineAnimation.AnimationEventTypes,"ps":1}],"sn":"SafeSubscribe","rt":$n[0].Void,"p":[$n[3].TrackEntry,$n[4].WaitForSpineAnimation.AnimationEventTypes]},{"a":1,"n":"m_WasFired","t":4,"rt":$n[0].Boolean,"sn":"m_WasFired","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.WaitForSpineAnimation end.*/

    /*Spine.Unity.WaitForSpineAnimation+AnimationEventTypes start.*/
    $m("Spine.Unity.WaitForSpineAnimation.AnimationEventTypes", function () { return {"td":$n[4].WaitForSpineAnimation,"att":258,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Complete","is":true,"t":4,"rt":$n[4].WaitForSpineAnimation.AnimationEventTypes,"sn":"Complete","box":function ($v) { return Bridge.box($v, Spine.Unity.WaitForSpineAnimation.AnimationEventTypes, System.Enum.toStringFn(Spine.Unity.WaitForSpineAnimation.AnimationEventTypes));}},{"a":2,"n":"Dispose","is":true,"t":4,"rt":$n[4].WaitForSpineAnimation.AnimationEventTypes,"sn":"Dispose","box":function ($v) { return Bridge.box($v, Spine.Unity.WaitForSpineAnimation.AnimationEventTypes, System.Enum.toStringFn(Spine.Unity.WaitForSpineAnimation.AnimationEventTypes));}},{"a":2,"n":"End","is":true,"t":4,"rt":$n[4].WaitForSpineAnimation.AnimationEventTypes,"sn":"End","box":function ($v) { return Bridge.box($v, Spine.Unity.WaitForSpineAnimation.AnimationEventTypes, System.Enum.toStringFn(Spine.Unity.WaitForSpineAnimation.AnimationEventTypes));}},{"a":2,"n":"Interrupt","is":true,"t":4,"rt":$n[4].WaitForSpineAnimation.AnimationEventTypes,"sn":"Interrupt","box":function ($v) { return Bridge.box($v, Spine.Unity.WaitForSpineAnimation.AnimationEventTypes, System.Enum.toStringFn(Spine.Unity.WaitForSpineAnimation.AnimationEventTypes));}},{"a":2,"n":"Start","is":true,"t":4,"rt":$n[4].WaitForSpineAnimation.AnimationEventTypes,"sn":"Start","box":function ($v) { return Bridge.box($v, Spine.Unity.WaitForSpineAnimation.AnimationEventTypes, System.Enum.toStringFn(Spine.Unity.WaitForSpineAnimation.AnimationEventTypes));}}]}; }, $n);
    /*Spine.Unity.WaitForSpineAnimation+AnimationEventTypes end.*/

    /*Spine.Unity.WaitForSpineAnimationComplete start.*/
    $m("Spine.Unity.WaitForSpineAnimationComplete", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[3].TrackEntry,$n[0].Boolean],"pi":[{"n":"trackEntry","pt":$n[3].TrackEntry,"ps":0},{"n":"includeEndEvent","dv":false,"o":true,"pt":$n[0].Boolean,"ps":1}],"sn":"ctor"},{"a":2,"n":"NowWaitFor","t":8,"pi":[{"n":"trackEntry","pt":$n[3].TrackEntry,"ps":0},{"n":"includeEndEvent","dv":false,"o":true,"pt":$n[0].Boolean,"ps":1}],"sn":"NowWaitFor$1","rt":$n[4].WaitForSpineAnimationComplete,"p":[$n[3].TrackEntry,$n[0].Boolean]}]}; }, $n);
    /*Spine.Unity.WaitForSpineAnimationComplete end.*/

    /*Spine.Unity.WaitForSpineAnimationEnd start.*/
    $m("Spine.Unity.WaitForSpineAnimationEnd", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[3].TrackEntry],"pi":[{"n":"trackEntry","pt":$n[3].TrackEntry,"ps":0}],"sn":"ctor"},{"a":2,"n":"NowWaitFor","t":8,"pi":[{"n":"trackEntry","pt":$n[3].TrackEntry,"ps":0}],"sn":"NowWaitFor$1","rt":$n[4].WaitForSpineAnimationEnd,"p":[$n[3].TrackEntry]}]}; }, $n);
    /*Spine.Unity.WaitForSpineAnimationEnd end.*/

    /*Spine.Unity.WaitForSpineEvent start.*/
    $m("Spine.Unity.WaitForSpineEvent", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[3].AnimationState,spine.EventData,$n[0].Boolean],"pi":[{"n":"state","pt":$n[3].AnimationState,"ps":0},{"n":"eventDataReference","pt":spine.EventData,"ps":1},{"n":"unsubscribeAfterFiring","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2}],"sn":"ctor"},{"a":2,"n":".ctor","t":1,"p":[$n[3].AnimationState,$n[0].String,$n[0].Boolean],"pi":[{"n":"state","pt":$n[3].AnimationState,"ps":0},{"n":"eventName","pt":$n[0].String,"ps":1},{"n":"unsubscribeAfterFiring","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2}],"sn":"$ctor1"},{"a":2,"n":".ctor","t":1,"p":[$n[4].SkeletonAnimation,spine.EventData,$n[0].Boolean],"pi":[{"n":"skeletonAnimation","pt":$n[4].SkeletonAnimation,"ps":0},{"n":"eventDataReference","pt":spine.EventData,"ps":1},{"n":"unsubscribeAfterFiring","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2}],"sn":"$ctor2"},{"a":2,"n":".ctor","t":1,"p":[$n[4].SkeletonAnimation,$n[0].String,$n[0].Boolean],"pi":[{"n":"skeletonAnimation","pt":$n[4].SkeletonAnimation,"ps":0},{"n":"eventName","pt":$n[0].String,"ps":1},{"n":"unsubscribeAfterFiring","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2}],"sn":"$ctor3"},{"a":1,"n":"Clear","t":8,"pi":[{"n":"state","pt":$n[3].AnimationState,"ps":0}],"sn":"Clear","rt":$n[0].Void,"p":[$n[3].AnimationState]},{"a":1,"n":"HandleAnimationStateEvent","t":8,"pi":[{"n":"trackEntry","pt":$n[3].TrackEntry,"ps":0},{"n":"e","pt":spine.Event,"ps":1}],"sn":"HandleAnimationStateEvent","rt":$n[0].Void,"p":[$n[3].TrackEntry,spine.Event]},{"a":1,"n":"HandleAnimationStateEventByName","t":8,"pi":[{"n":"trackEntry","pt":$n[3].TrackEntry,"ps":0},{"n":"e","pt":spine.Event,"ps":1}],"sn":"HandleAnimationStateEventByName","rt":$n[0].Void,"p":[$n[3].TrackEntry,spine.Event]},{"a":2,"n":"NowWaitFor","t":8,"pi":[{"n":"state","pt":$n[3].AnimationState,"ps":0},{"n":"eventDataReference","pt":spine.EventData,"ps":1},{"n":"unsubscribeAfterFiring","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2}],"sn":"NowWaitFor","rt":$n[4].WaitForSpineEvent,"p":[$n[3].AnimationState,spine.EventData,$n[0].Boolean]},{"a":2,"n":"NowWaitFor","t":8,"pi":[{"n":"state","pt":$n[3].AnimationState,"ps":0},{"n":"eventName","pt":$n[0].String,"ps":1},{"n":"unsubscribeAfterFiring","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2}],"sn":"NowWaitFor$1","rt":$n[4].WaitForSpineEvent,"p":[$n[3].AnimationState,$n[0].String,$n[0].Boolean]},{"a":1,"n":"Subscribe","t":8,"pi":[{"n":"state","pt":$n[3].AnimationState,"ps":0},{"n":"eventDataReference","pt":spine.EventData,"ps":1},{"n":"unsubscribe","pt":$n[0].Boolean,"ps":2}],"sn":"Subscribe","rt":$n[0].Void,"p":[$n[3].AnimationState,spine.EventData,$n[0].Boolean]},{"a":1,"n":"SubscribeByName","t":8,"pi":[{"n":"state","pt":$n[3].AnimationState,"ps":0},{"n":"eventName","pt":$n[0].String,"ps":1},{"n":"unsubscribe","pt":$n[0].Boolean,"ps":2}],"sn":"SubscribeByName","rt":$n[0].Void,"p":[$n[3].AnimationState,$n[0].String,$n[0].Boolean]},{"a":2,"n":"WillUnsubscribeAfterFiring","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_WillUnsubscribeAfterFiring","t":8,"rt":$n[0].Boolean,"fg":"WillUnsubscribeAfterFiring","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_WillUnsubscribeAfterFiring","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"WillUnsubscribeAfterFiring"},"fn":"WillUnsubscribeAfterFiring"},{"a":1,"n":"m_AnimationState","t":4,"rt":$n[3].AnimationState,"sn":"m_AnimationState"},{"a":1,"n":"m_EventName","t":4,"rt":$n[0].String,"sn":"m_EventName"},{"a":1,"n":"m_TargetEvent","t":4,"rt":spine.EventData,"sn":"m_TargetEvent"},{"a":1,"n":"m_WasFired","t":4,"rt":$n[0].Boolean,"sn":"m_WasFired","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"m_unsubscribeAfterFiring","t":4,"rt":$n[0].Boolean,"sn":"m_unsubscribeAfterFiring","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.WaitForSpineEvent end.*/

    /*Spine.Unity.WaitForSpineTrackEntryEnd start.*/
    $m("Spine.Unity.WaitForSpineTrackEntryEnd", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[3].TrackEntry],"pi":[{"n":"trackEntry","pt":$n[3].TrackEntry,"ps":0}],"sn":"ctor"},{"a":1,"n":"HandleEnd","t":8,"pi":[{"n":"trackEntry","pt":$n[3].TrackEntry,"ps":0}],"sn":"HandleEnd","rt":$n[0].Void,"p":[$n[3].TrackEntry]},{"a":2,"n":"NowWaitFor","t":8,"pi":[{"n":"trackEntry","pt":$n[3].TrackEntry,"ps":0}],"sn":"NowWaitFor","rt":$n[4].WaitForSpineTrackEntryEnd,"p":[$n[3].TrackEntry]},{"a":1,"n":"SafeSubscribe","t":8,"pi":[{"n":"trackEntry","pt":$n[3].TrackEntry,"ps":0}],"sn":"SafeSubscribe","rt":$n[0].Void,"p":[$n[3].TrackEntry]},{"a":1,"n":"m_WasFired","t":4,"rt":$n[0].Boolean,"sn":"m_WasFired","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.WaitForSpineTrackEntryEnd end.*/

    /*Spine.Unity.AnimationTools.TimelineExtensions start.*/
    $m("Spine.Unity.AnimationTools.TimelineExtensions", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"Evaluate","is":true,"t":8,"pi":[{"n":"timeline","pt":spine.RotateTimeline,"ps":0},{"n":"time","pt":$n[0].Single,"ps":1},{"n":"skeletonData","dv":null,"o":true,"pt":$n[3].SkeletonData,"ps":2}],"sn":"Evaluate","rt":$n[0].Single,"p":[spine.RotateTimeline,$n[0].Single,$n[3].SkeletonData],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"Evaluate","is":true,"t":8,"pi":[{"n":"timeline","pt":spine.TranslateTimeline,"ps":0},{"n":"time","pt":$n[0].Single,"ps":1},{"n":"skeletonData","dv":null,"o":true,"pt":$n[3].SkeletonData,"ps":2}],"sn":"Evaluate$1","rt":$n[1].Vector2,"p":[spine.TranslateTimeline,$n[0].Single,$n[3].SkeletonData]},{"a":2,"n":"Evaluate","is":true,"t":8,"pi":[{"n":"xTimeline","pt":spine.TranslateXTimeline,"ps":0},{"n":"yTimeline","pt":spine.TranslateYTimeline,"ps":1},{"n":"time","pt":$n[0].Single,"ps":2},{"n":"skeletonData","dv":null,"o":true,"pt":$n[3].SkeletonData,"ps":3}],"sn":"Evaluate$2","rt":$n[1].Vector2,"p":[spine.TranslateXTimeline,spine.TranslateYTimeline,$n[0].Single,$n[3].SkeletonData]},{"a":2,"n":"EvaluateRotateMix","is":true,"t":8,"pi":[{"n":"timeline","pt":spine.TransformConstraintTimeline,"ps":0},{"n":"time","pt":$n[0].Single,"ps":1}],"sn":"EvaluateRotateMix","rt":$n[0].Single,"p":[spine.TransformConstraintTimeline,$n[0].Single],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"EvaluateTranslateXYMix","is":true,"t":8,"pi":[{"n":"timeline","pt":spine.TransformConstraintTimeline,"ps":0},{"n":"time","pt":$n[0].Single,"ps":1}],"sn":"EvaluateTranslateXYMix","rt":$n[1].Vector2,"p":[spine.TransformConstraintTimeline,$n[0].Single]},{"a":2,"n":"FindTimelineForBone","is":true,"t":8,"pi":[{"n":"a","pt":$n[3].Animation,"ps":0},{"n":"boneIndex","pt":$n[0].Int32,"ps":1}],"tpc":1,"tprm":["T"],"sn":"FindTimelineForBone","rt":System.Object,"p":[$n[3].Animation,$n[0].Int32]},{"a":2,"n":"FindTransformConstraintTimeline","is":true,"t":8,"pi":[{"n":"a","pt":$n[3].Animation,"ps":0},{"n":"transformConstraintIndex","pt":$n[0].Int32,"ps":1}],"sn":"FindTransformConstraintTimeline","rt":spine.TransformConstraintTimeline,"p":[$n[3].Animation,$n[0].Int32]},{"a":2,"n":"FindTranslateTimelineForBone","is":true,"t":8,"pi":[{"n":"a","pt":$n[3].Animation,"ps":0},{"n":"boneIndex","pt":$n[0].Int32,"ps":1}],"sn":"FindTranslateTimelineForBone","rt":spine.TranslateTimeline,"p":[$n[3].Animation,$n[0].Int32]}]}; }, $n);
    /*Spine.Unity.AnimationTools.TimelineExtensions end.*/

    /*Spine.Unity.AttachmentTools.AtlasUtilities start.*/
    $m("Spine.Unity.AttachmentTools.AtlasUtilities", function () { return {"nested":[$n[8].AtlasUtilities.IntAndAtlasRegionKey],"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"ClearCache","is":true,"t":8,"sn":"ClearCache","rt":$n[0].Void},{"a":1,"n":"CopyTexture","is":true,"t":8,"pi":[{"n":"source","pt":$n[1].Texture2D,"ps":0},{"n":"sourceRect","pt":$n[1].Rect,"ps":1},{"n":"destination","pt":$n[1].Texture2D,"ps":2}],"sn":"CopyTexture","rt":$n[0].Void,"p":[$n[1].Texture2D,$n[1].Rect,$n[1].Texture2D]},{"a":1,"n":"CopyTextureApplyPMA","is":true,"t":8,"pi":[{"n":"source","pt":$n[1].Texture2D,"ps":0},{"n":"sourceRect","pt":$n[1].Rect,"ps":1},{"n":"destination","pt":$n[1].Texture2D,"ps":2}],"sn":"CopyTextureApplyPMA","rt":$n[0].Void,"p":[$n[1].Texture2D,$n[1].Rect,$n[1].Texture2D]},{"a":1,"n":"CopyTextureAttributesFrom","is":true,"t":8,"pi":[{"n":"destination","pt":$n[1].Texture2D,"ps":0},{"n":"source","pt":$n[1].Texture2D,"ps":1}],"sn":"CopyTextureAttributesFrom","rt":$n[0].Void,"p":[$n[1].Texture2D,$n[1].Texture2D]},{"a":1,"n":"GetClone","is":true,"t":8,"pi":[{"n":"t","pt":$n[1].Texture2D,"ps":0},{"n":"textureFormat","dv":4,"o":true,"pt":$n[1].TextureFormat,"ps":1},{"n":"mipmaps","dv":false,"o":true,"pt":$n[0].Boolean,"ps":2},{"n":"linear","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3},{"n":"applyPMA","dv":false,"o":true,"pt":$n[0].Boolean,"ps":4}],"sn":"GetClone","rt":$n[1].Texture2D,"p":[$n[1].Texture2D,$n[1].TextureFormat,$n[0].Boolean,$n[0].Boolean,$n[0].Boolean]},{"a":1,"n":"GetMainTexture","is":true,"t":8,"pi":[{"n":"region","pt":$n[3].AtlasRegion,"ps":0}],"sn":"GetMainTexture","rt":$n[1].Texture2D,"p":[$n[3].AtlasRegion]},{"a":2,"n":"GetRepackedAttachments","is":true,"t":8,"pi":[{"n":"sourceAttachments","pt":$n[5].List$1(spine.Attachment),"ps":0},{"n":"outputAttachments","pt":$n[5].List$1(spine.Attachment),"ps":1},{"n":"materialPropertySource","pt":$n[1].Material,"ps":2},{"n":"outputMaterial","out":true,"pt":$n[1].Material,"ps":3},{"n":"outputTexture","out":true,"pt":$n[1].Texture2D,"ps":4},{"n":"maxAtlasSize","dv":1024,"o":true,"pt":$n[0].Int32,"ps":5},{"n":"padding","dv":2,"o":true,"pt":$n[0].Int32,"ps":6},{"n":"textureFormat","dv":4,"o":true,"pt":$n[1].TextureFormat,"ps":7},{"n":"mipmaps","dv":false,"o":true,"pt":$n[0].Boolean,"ps":8},{"n":"newAssetName","dv":"Repacked Attachments","o":true,"pt":$n[0].String,"ps":9},{"n":"clearCache","dv":false,"o":true,"pt":$n[0].Boolean,"ps":10},{"n":"useOriginalNonrenderables","dv":true,"o":true,"pt":$n[0].Boolean,"ps":11},{"n":"additionalTexturePropertyIDsToCopy","dv":null,"o":true,"pt":$n[0].Array.type(System.Int32),"ps":12},{"n":"additionalOutputTextures","dv":null,"o":true,"pt":System.Array.type(UnityEngine.Texture2D),"ps":13},{"n":"additionalTextureFormats","dv":null,"o":true,"pt":System.Array.type(UnityEngine.TextureFormat),"ps":14},{"n":"additionalTextureIsLinear","dv":null,"o":true,"pt":$n[0].Array.type(System.Boolean),"ps":15}],"sn":"GetRepackedAttachments","rt":$n[0].Void,"p":[$n[5].List$1(spine.Attachment),$n[5].List$1(spine.Attachment),$n[1].Material,$n[1].Material,$n[1].Texture2D,$n[0].Int32,$n[0].Int32,$n[1].TextureFormat,$n[0].Boolean,$n[0].String,$n[0].Boolean,$n[0].Boolean,$n[0].Array.type(System.Int32),System.Array.type(UnityEngine.Texture2D),System.Array.type(UnityEngine.TextureFormat),$n[0].Array.type(System.Boolean)]},{"a":2,"n":"GetRepackedAttachments","is":true,"t":8,"pi":[{"n":"sourceAttachments","pt":$n[5].List$1(spine.Attachment),"ps":0},{"n":"outputAttachments","pt":$n[5].List$1(spine.Attachment),"ps":1},{"n":"shader","pt":$n[1].Shader,"ps":2},{"n":"outputMaterial","out":true,"pt":$n[1].Material,"ps":3},{"n":"outputTexture","out":true,"pt":$n[1].Texture2D,"ps":4},{"n":"maxAtlasSize","dv":1024,"o":true,"pt":$n[0].Int32,"ps":5},{"n":"padding","dv":2,"o":true,"pt":$n[0].Int32,"ps":6},{"n":"textureFormat","dv":4,"o":true,"pt":$n[1].TextureFormat,"ps":7},{"n":"mipmaps","dv":false,"o":true,"pt":$n[0].Boolean,"ps":8},{"n":"newAssetName","dv":"Repacked Attachments","o":true,"pt":$n[0].String,"ps":9},{"n":"materialPropertySource","dv":null,"o":true,"pt":$n[1].Material,"ps":10},{"n":"clearCache","dv":false,"o":true,"pt":$n[0].Boolean,"ps":11},{"n":"useOriginalNonrenderables","dv":true,"o":true,"pt":$n[0].Boolean,"ps":12},{"n":"additionalTexturePropertyIDsToCopy","dv":null,"o":true,"pt":$n[0].Array.type(System.Int32),"ps":13},{"n":"additionalOutputTextures","dv":null,"o":true,"pt":System.Array.type(UnityEngine.Texture2D),"ps":14},{"n":"additionalTextureFormats","dv":null,"o":true,"pt":System.Array.type(UnityEngine.TextureFormat),"ps":15},{"n":"additionalTextureIsLinear","dv":null,"o":true,"pt":$n[0].Array.type(System.Boolean),"ps":16}],"sn":"GetRepackedAttachments$1","rt":$n[0].Void,"p":[$n[5].List$1(spine.Attachment),$n[5].List$1(spine.Attachment),$n[1].Shader,$n[1].Material,$n[1].Texture2D,$n[0].Int32,$n[0].Int32,$n[1].TextureFormat,$n[0].Boolean,$n[0].String,$n[1].Material,$n[0].Boolean,$n[0].Boolean,$n[0].Array.type(System.Int32),System.Array.type(UnityEngine.Texture2D),System.Array.type(UnityEngine.TextureFormat),$n[0].Array.type(System.Boolean)]},{"a":2,"n":"GetRepackedSkin","is":true,"t":8,"pi":[{"n":"o","pt":$n[3].Skin,"ps":0},{"n":"newName","pt":$n[0].String,"ps":1},{"n":"materialPropertySource","pt":$n[1].Material,"ps":2},{"n":"outputMaterial","out":true,"pt":$n[1].Material,"ps":3},{"n":"outputTexture","out":true,"pt":$n[1].Texture2D,"ps":4},{"n":"maxAtlasSize","dv":1024,"o":true,"pt":$n[0].Int32,"ps":5},{"n":"padding","dv":2,"o":true,"pt":$n[0].Int32,"ps":6},{"n":"textureFormat","dv":4,"o":true,"pt":$n[1].TextureFormat,"ps":7},{"n":"mipmaps","dv":false,"o":true,"pt":$n[0].Boolean,"ps":8},{"n":"useOriginalNonrenderables","dv":true,"o":true,"pt":$n[0].Boolean,"ps":9},{"n":"clearCache","dv":false,"o":true,"pt":$n[0].Boolean,"ps":10},{"n":"additionalTexturePropertyIDsToCopy","dv":null,"o":true,"pt":$n[0].Array.type(System.Int32),"ps":11},{"n":"additionalOutputTextures","dv":null,"o":true,"pt":System.Array.type(UnityEngine.Texture2D),"ps":12},{"n":"additionalTextureFormats","dv":null,"o":true,"pt":System.Array.type(UnityEngine.TextureFormat),"ps":13},{"n":"additionalTextureIsLinear","dv":null,"o":true,"pt":$n[0].Array.type(System.Boolean),"ps":14}],"sn":"GetRepackedSkin","rt":$n[3].Skin,"p":[$n[3].Skin,$n[0].String,$n[1].Material,$n[1].Material,$n[1].Texture2D,$n[0].Int32,$n[0].Int32,$n[1].TextureFormat,$n[0].Boolean,$n[0].Boolean,$n[0].Boolean,$n[0].Array.type(System.Int32),System.Array.type(UnityEngine.Texture2D),System.Array.type(UnityEngine.TextureFormat),$n[0].Array.type(System.Boolean)]},{"a":2,"n":"GetRepackedSkin","is":true,"t":8,"pi":[{"n":"o","pt":$n[3].Skin,"ps":0},{"n":"newName","pt":$n[0].String,"ps":1},{"n":"shader","pt":$n[1].Shader,"ps":2},{"n":"outputMaterial","out":true,"pt":$n[1].Material,"ps":3},{"n":"outputTexture","out":true,"pt":$n[1].Texture2D,"ps":4},{"n":"maxAtlasSize","dv":1024,"o":true,"pt":$n[0].Int32,"ps":5},{"n":"padding","dv":2,"o":true,"pt":$n[0].Int32,"ps":6},{"n":"textureFormat","dv":4,"o":true,"pt":$n[1].TextureFormat,"ps":7},{"n":"mipmaps","dv":false,"o":true,"pt":$n[0].Boolean,"ps":8},{"n":"materialPropertySource","dv":null,"o":true,"pt":$n[1].Material,"ps":9},{"n":"clearCache","dv":false,"o":true,"pt":$n[0].Boolean,"ps":10},{"n":"useOriginalNonrenderables","dv":true,"o":true,"pt":$n[0].Boolean,"ps":11},{"n":"additionalTexturePropertyIDsToCopy","dv":null,"o":true,"pt":$n[0].Array.type(System.Int32),"ps":12},{"n":"additionalOutputTextures","dv":null,"o":true,"pt":System.Array.type(UnityEngine.Texture2D),"ps":13},{"n":"additionalTextureFormats","dv":null,"o":true,"pt":System.Array.type(UnityEngine.TextureFormat),"ps":14},{"n":"additionalTextureIsLinear","dv":null,"o":true,"pt":$n[0].Array.type(System.Boolean),"ps":15}],"sn":"GetRepackedSkin$1","rt":$n[3].Skin,"p":[$n[3].Skin,$n[0].String,$n[1].Shader,$n[1].Material,$n[1].Texture2D,$n[0].Int32,$n[0].Int32,$n[1].TextureFormat,$n[0].Boolean,$n[1].Material,$n[0].Boolean,$n[0].Boolean,$n[0].Array.type(System.Int32),System.Array.type(UnityEngine.Texture2D),System.Array.type(UnityEngine.TextureFormat),$n[0].Array.type(System.Boolean)]},{"a":1,"n":"GetSpineAtlasRect","is":true,"t":8,"pi":[{"n":"region","pt":$n[3].AtlasRegion,"ps":0},{"n":"includeRotate","dv":true,"o":true,"pt":$n[0].Boolean,"ps":1}],"sn":"GetSpineAtlasRect","rt":$n[1].Rect,"p":[$n[3].AtlasRegion,$n[0].Boolean]},{"a":1,"n":"GetTexture","is":true,"t":8,"pi":[{"n":"region","pt":$n[3].AtlasRegion,"ps":0},{"n":"texturePropertyId","pt":$n[0].Int32,"ps":1}],"sn":"GetTexture","rt":$n[1].Texture2D,"p":[$n[3].AtlasRegion,$n[0].Int32]},{"a":1,"n":"GetTexture","is":true,"t":8,"pi":[{"n":"region","pt":$n[3].AtlasRegion,"ps":0},{"n":"texturePropertyName","pt":$n[0].String,"ps":1}],"sn":"GetTexture$1","rt":$n[1].Texture2D,"p":[$n[3].AtlasRegion,$n[0].String]},{"a":1,"n":"GetUnityRect","is":true,"t":8,"pi":[{"n":"region","pt":$n[3].AtlasRegion,"ps":0}],"sn":"GetUnityRect","rt":$n[1].Rect,"p":[$n[3].AtlasRegion]},{"a":1,"n":"GetUnityRect","is":true,"t":8,"pi":[{"n":"region","pt":$n[3].AtlasRegion,"ps":0},{"n":"textureHeight","pt":$n[0].Int32,"ps":1}],"sn":"GetUnityRect$1","rt":$n[1].Rect,"p":[$n[3].AtlasRegion,$n[0].Int32]},{"at":[new UnityEngine.RuntimeInitializeOnLoadMethodAttribute.$ctor1(4)],"a":1,"n":"Init","is":true,"t":8,"sn":"Init","rt":$n[0].Void},{"a":1,"n":"InverseLerp","is":true,"t":8,"pi":[{"n":"a","pt":$n[0].Single,"ps":0},{"n":"b","pt":$n[0].Single,"ps":1},{"n":"value","pt":$n[0].Single,"ps":2}],"sn":"InverseLerp","rt":$n[0].Single,"p":[$n[0].Single,$n[0].Single,$n[0].Single],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"IsRenderable","is":true,"t":8,"pi":[{"n":"a","pt":spine.Attachment,"ps":0}],"sn":"IsRenderable","rt":$n[0].Boolean,"p":[spine.Attachment],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"SpineUnityFlipRect","is":true,"t":8,"pi":[{"n":"rect","pt":$n[1].Rect,"ps":0},{"n":"textureHeight","pt":$n[0].Int32,"ps":1}],"sn":"SpineUnityFlipRect","rt":$n[1].Rect,"p":[$n[1].Rect,$n[0].Int32]},{"a":1,"n":"TextureRectToUVRect","is":true,"t":8,"pi":[{"n":"textureRect","pt":$n[1].Rect,"ps":0},{"n":"texWidth","pt":$n[0].Int32,"ps":1},{"n":"texHeight","pt":$n[0].Int32,"ps":2}],"sn":"TextureRectToUVRect","rt":$n[1].Rect,"p":[$n[1].Rect,$n[0].Int32,$n[0].Int32]},{"a":2,"n":"ToAtlasRegion","is":true,"t":8,"pi":[{"n":"s","pt":$n[1].Sprite,"ps":0},{"n":"page","pt":$n[3].AtlasPage,"ps":1}],"sn":"ToAtlasRegion","rt":$n[3].AtlasRegion,"p":[$n[1].Sprite,$n[3].AtlasPage]},{"a":4,"n":"ToAtlasRegion","is":true,"t":8,"pi":[{"n":"s","pt":$n[1].Sprite,"ps":0},{"n":"isolatedTexture","dv":false,"o":true,"pt":$n[0].Boolean,"ps":1}],"sn":"ToAtlasRegion$4","rt":$n[3].AtlasRegion,"p":[$n[1].Sprite,$n[0].Boolean]},{"a":2,"n":"ToAtlasRegion","is":true,"t":8,"pi":[{"n":"s","pt":$n[1].Sprite,"ps":0},{"n":"material","pt":$n[1].Material,"ps":1}],"sn":"ToAtlasRegion$1","rt":$n[3].AtlasRegion,"p":[$n[1].Sprite,$n[1].Material]},{"a":2,"n":"ToAtlasRegion","is":true,"t":8,"pi":[{"n":"t","pt":$n[1].Texture2D,"ps":0},{"n":"materialPropertySource","pt":$n[1].Material,"ps":1},{"n":"scale","dv":0.01,"o":true,"pt":$n[0].Single,"ps":2}],"sn":"ToAtlasRegion$2","rt":$n[3].AtlasRegion,"p":[$n[1].Texture2D,$n[1].Material,$n[0].Single]},{"a":2,"n":"ToAtlasRegion","is":true,"t":8,"pi":[{"n":"t","pt":$n[1].Texture2D,"ps":0},{"n":"shader","pt":$n[1].Shader,"ps":1},{"n":"scale","dv":0.01,"o":true,"pt":$n[0].Single,"ps":2},{"n":"materialPropertySource","dv":null,"o":true,"pt":$n[1].Material,"ps":3}],"sn":"ToAtlasRegion$3","rt":$n[3].AtlasRegion,"p":[$n[1].Texture2D,$n[1].Shader,$n[0].Single,$n[1].Material]},{"a":2,"n":"ToAtlasRegionPMAClone","is":true,"t":8,"pi":[{"n":"s","pt":$n[1].Sprite,"ps":0},{"n":"materialPropertySource","pt":$n[1].Material,"ps":1},{"n":"textureFormat","dv":4,"o":true,"pt":$n[1].TextureFormat,"ps":2},{"n":"mipmaps","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"ToAtlasRegionPMAClone","rt":$n[3].AtlasRegion,"p":[$n[1].Sprite,$n[1].Material,$n[1].TextureFormat,$n[0].Boolean]},{"a":2,"n":"ToAtlasRegionPMAClone","is":true,"t":8,"pi":[{"n":"t","pt":$n[1].Texture2D,"ps":0},{"n":"materialPropertySource","pt":$n[1].Material,"ps":1},{"n":"textureFormat","dv":4,"o":true,"pt":$n[1].TextureFormat,"ps":2},{"n":"mipmaps","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"ToAtlasRegionPMAClone$2","rt":$n[3].AtlasRegion,"p":[$n[1].Texture2D,$n[1].Material,$n[1].TextureFormat,$n[0].Boolean]},{"a":2,"n":"ToAtlasRegionPMAClone","is":true,"t":8,"pi":[{"n":"s","pt":$n[1].Sprite,"ps":0},{"n":"shader","pt":$n[1].Shader,"ps":1},{"n":"textureFormat","dv":4,"o":true,"pt":$n[1].TextureFormat,"ps":2},{"n":"mipmaps","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3},{"n":"materialPropertySource","dv":null,"o":true,"pt":$n[1].Material,"ps":4}],"sn":"ToAtlasRegionPMAClone$1","rt":$n[3].AtlasRegion,"p":[$n[1].Sprite,$n[1].Shader,$n[1].TextureFormat,$n[0].Boolean,$n[1].Material]},{"a":2,"n":"ToAtlasRegionPMAClone","is":true,"t":8,"pi":[{"n":"t","pt":$n[1].Texture2D,"ps":0},{"n":"shader","pt":$n[1].Shader,"ps":1},{"n":"textureFormat","dv":4,"o":true,"pt":$n[1].TextureFormat,"ps":2},{"n":"mipmaps","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3},{"n":"materialPropertySource","dv":null,"o":true,"pt":$n[1].Material,"ps":4}],"sn":"ToAtlasRegionPMAClone$3","rt":$n[3].AtlasRegion,"p":[$n[1].Texture2D,$n[1].Shader,$n[1].TextureFormat,$n[0].Boolean,$n[1].Material]},{"a":2,"n":"ToSpineAtlasPage","is":true,"t":8,"pi":[{"n":"m","pt":$n[1].Material,"ps":0}],"sn":"ToSpineAtlasPage","rt":$n[3].AtlasPage,"p":[$n[1].Material]},{"a":2,"n":"ToSprite","is":true,"t":8,"pi":[{"n":"ar","pt":$n[3].AtlasRegion,"ps":0},{"n":"pixelsPerUnit","dv":100.0,"o":true,"pt":$n[0].Single,"ps":1}],"sn":"ToSprite","rt":$n[1].Sprite,"p":[$n[3].AtlasRegion,$n[0].Single]},{"a":1,"n":"ToTexture","is":true,"t":8,"pi":[{"n":"s","pt":$n[1].Sprite,"ps":0},{"n":"textureFormat","dv":4,"o":true,"pt":$n[1].TextureFormat,"ps":1},{"n":"mipmaps","dv":false,"o":true,"pt":$n[0].Boolean,"ps":2},{"n":"linear","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3},{"n":"applyPMA","dv":false,"o":true,"pt":$n[0].Boolean,"ps":4}],"sn":"ToTexture$1","rt":$n[1].Texture2D,"p":[$n[1].Sprite,$n[1].TextureFormat,$n[0].Boolean,$n[0].Boolean,$n[0].Boolean]},{"a":2,"n":"ToTexture","is":true,"t":8,"pi":[{"n":"ar","pt":$n[3].AtlasRegion,"ps":0},{"n":"textureFormat","dv":4,"o":true,"pt":$n[1].TextureFormat,"ps":1},{"n":"mipmaps","dv":false,"o":true,"pt":$n[0].Boolean,"ps":2},{"n":"texturePropertyId","dv":0,"o":true,"pt":$n[0].Int32,"ps":3},{"n":"linear","dv":false,"o":true,"pt":$n[0].Boolean,"ps":4},{"n":"applyPMA","dv":false,"o":true,"pt":$n[0].Boolean,"ps":5}],"sn":"ToTexture","rt":$n[1].Texture2D,"p":[$n[3].AtlasRegion,$n[1].TextureFormat,$n[0].Boolean,$n[0].Int32,$n[0].Boolean,$n[0].Boolean]},{"a":1,"n":"UVRectToAtlasRegion","is":true,"t":8,"pi":[{"n":"uvRect","pt":$n[1].Rect,"ps":0},{"n":"referenceRegion","pt":$n[3].AtlasRegion,"ps":1},{"n":"page","pt":$n[3].AtlasPage,"ps":2}],"sn":"UVRectToAtlasRegion","rt":$n[3].AtlasRegion,"p":[$n[1].Rect,$n[3].AtlasRegion,$n[3].AtlasPage]},{"a":1,"n":"UVRectToTextureRect","is":true,"t":8,"pi":[{"n":"uvRect","pt":$n[1].Rect,"ps":0},{"n":"texWidth","pt":$n[0].Int32,"ps":1},{"n":"texHeight","pt":$n[0].Int32,"ps":2}],"sn":"UVRectToTextureRect","rt":$n[1].Rect,"p":[$n[1].Rect,$n[0].Int32,$n[0].Int32]},{"a":1,"n":"CachedRegionTextures","is":true,"t":4,"rt":$n[5].Dictionary$2(Spine.Unity.AttachmentTools.AtlasUtilities.IntAndAtlasRegionKey,UnityEngine.Texture2D),"sn":"CachedRegionTextures"},{"a":1,"n":"CachedRegionTexturesList","is":true,"t":4,"rt":$n[5].List$1(UnityEngine.Texture2D),"sn":"CachedRegionTexturesList"},{"a":4,"n":"DefaultMipmapBias","is":true,"t":4,"rt":$n[0].Single,"sn":"DefaultMipmapBias","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"DefaultScale","is":true,"t":4,"rt":$n[0].Single,"sn":"DefaultScale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"NonrenderingRegion","is":true,"t":4,"rt":$n[0].Int32,"sn":"NonrenderingRegion","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":4,"n":"SpineTextureFormat","is":true,"t":4,"rt":$n[1].TextureFormat,"sn":"SpineTextureFormat","box":function ($v) { return Bridge.box($v, UnityEngine.TextureFormat, System.Enum.toStringFn(UnityEngine.TextureFormat));}},{"a":4,"n":"UseMipMaps","is":true,"t":4,"rt":$n[0].Boolean,"sn":"UseMipMaps","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"existingRegions","is":true,"t":4,"rt":$n[5].Dictionary$2(Spine.AtlasRegion,System.Int32),"sn":"existingRegions","ro":true},{"a":1,"n":"inoutAttachments","is":true,"t":4,"rt":$n[5].List$1(spine.Attachment),"sn":"inoutAttachments"},{"a":1,"n":"originalRegions","is":true,"t":4,"rt":$n[5].List$1(Spine.AtlasRegion),"sn":"originalRegions","ro":true},{"a":1,"n":"regionIndices","is":true,"t":4,"rt":$n[5].List$1(System.Int32),"sn":"regionIndices","ro":true},{"a":1,"n":"repackedRegions","is":true,"t":4,"rt":$n[5].List$1(Spine.AtlasRegion),"sn":"repackedRegions","ro":true},{"a":1,"n":"texturesToPackAtParam","is":true,"t":4,"rt":System.Array.type(System.Collections.Generic.List$1(UnityEngine.Texture2D)),"sn":"texturesToPackAtParam"}]}; }, $n);
    /*Spine.Unity.AttachmentTools.AtlasUtilities end.*/

    /*Spine.Unity.AttachmentTools.AtlasUtilities+IntAndAtlasRegionKey start.*/
    $m("Spine.Unity.AttachmentTools.AtlasUtilities.IntAndAtlasRegionKey", function () { return {"td":$n[8].AtlasUtilities,"att":1048843,"a":1,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32,$n[3].AtlasRegion],"pi":[{"n":"i","pt":$n[0].Int32,"ps":0},{"n":"region","pt":$n[3].AtlasRegion,"ps":1}],"sn":"$ctor1"},{"ov":true,"a":2,"n":"GetHashCode","t":8,"sn":"getHashCode","rt":$n[0].Int32,"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"i","t":4,"rt":$n[0].Int32,"sn":"i","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"region","t":4,"rt":$n[3].AtlasRegion,"sn":"region"}]}; }, $n);
    /*Spine.Unity.AttachmentTools.AtlasUtilities+IntAndAtlasRegionKey end.*/

    /*Spine.Unity.AttachmentTools.AttachmentCloneExtensions start.*/
    $m("Spine.Unity.AttachmentTools.AttachmentCloneExtensions", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"GetRemappedClone","is":true,"t":8,"pi":[{"n":"o","pt":spine.Attachment,"ps":0},{"n":"atlasRegion","pt":$n[3].AtlasRegion,"ps":1},{"n":"cloneMeshAsLinked","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2},{"n":"useOriginalRegionSize","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3},{"n":"scale","dv":0.01,"o":true,"pt":$n[0].Single,"ps":4}],"sn":"GetRemappedClone","rt":spine.Attachment,"p":[spine.Attachment,$n[3].AtlasRegion,$n[0].Boolean,$n[0].Boolean,$n[0].Single]},{"a":2,"n":"GetRemappedClone","is":true,"t":8,"pi":[{"n":"o","pt":spine.Attachment,"ps":0},{"n":"sprite","pt":$n[1].Sprite,"ps":1},{"n":"sourceMaterial","pt":$n[1].Material,"ps":2},{"n":"premultiplyAlpha","dv":true,"o":true,"pt":$n[0].Boolean,"ps":3},{"n":"cloneMeshAsLinked","dv":true,"o":true,"pt":$n[0].Boolean,"ps":4},{"n":"useOriginalRegionSize","dv":false,"o":true,"pt":$n[0].Boolean,"ps":5},{"n":"pivotShiftsMeshUVCoords","dv":true,"o":true,"pt":$n[0].Boolean,"ps":6},{"n":"useOriginalRegionScale","dv":false,"o":true,"pt":$n[0].Boolean,"ps":7},{"n":"pmaCloneTextureFormat","dv":4,"o":true,"pt":$n[1].TextureFormat,"ps":8},{"n":"pmaCloneMipmaps","dv":false,"o":true,"pt":$n[0].Boolean,"ps":9}],"sn":"GetRemappedClone$1","rt":spine.Attachment,"p":[spine.Attachment,$n[1].Sprite,$n[1].Material,$n[0].Boolean,$n[0].Boolean,$n[0].Boolean,$n[0].Boolean,$n[0].Boolean,$n[1].TextureFormat,$n[0].Boolean]}]}; }, $n);
    /*Spine.Unity.AttachmentTools.AttachmentCloneExtensions end.*/

    /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions start.*/
    $m("Spine.Unity.AttachmentTools.AttachmentRegionExtensions", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"SetPositionOffset","is":true,"t":8,"pi":[{"n":"regionAttachment","pt":$n[3].RegionAttachment,"ps":0},{"n":"offset","pt":$n[1].Vector2,"ps":1}],"sn":"SetPositionOffset$1","rt":$n[0].Void,"p":[$n[3].RegionAttachment,$n[1].Vector2]},{"a":2,"n":"SetPositionOffset","is":true,"t":8,"pi":[{"n":"regionAttachment","pt":$n[3].RegionAttachment,"ps":0},{"n":"x","pt":$n[0].Single,"ps":1},{"n":"y","pt":$n[0].Single,"ps":2}],"sn":"SetPositionOffset","rt":$n[0].Void,"p":[$n[3].RegionAttachment,$n[0].Single,$n[0].Single]},{"a":2,"n":"SetRotation","is":true,"t":8,"pi":[{"n":"regionAttachment","pt":$n[3].RegionAttachment,"ps":0},{"n":"rotation","pt":$n[0].Single,"ps":1}],"sn":"SetRotation","rt":$n[0].Void,"p":[$n[3].RegionAttachment,$n[0].Single]},{"a":2,"n":"SetScale","is":true,"t":8,"pi":[{"n":"regionAttachment","pt":$n[3].RegionAttachment,"ps":0},{"n":"scale","pt":$n[1].Vector2,"ps":1}],"sn":"SetScale$1","rt":$n[0].Void,"p":[$n[3].RegionAttachment,$n[1].Vector2]},{"a":2,"n":"SetScale","is":true,"t":8,"pi":[{"n":"regionAttachment","pt":$n[3].RegionAttachment,"ps":0},{"n":"x","pt":$n[0].Single,"ps":1},{"n":"y","pt":$n[0].Single,"ps":2}],"sn":"SetScale","rt":$n[0].Void,"p":[$n[3].RegionAttachment,$n[0].Single,$n[0].Single]},{"a":2,"n":"ToRegionAttachment","is":true,"t":8,"pi":[{"n":"sprite","pt":$n[1].Sprite,"ps":0},{"n":"page","pt":$n[3].AtlasPage,"ps":1},{"n":"rotation","dv":0.0,"o":true,"pt":$n[0].Single,"ps":2}],"sn":"ToRegionAttachment$1","rt":$n[3].RegionAttachment,"p":[$n[1].Sprite,$n[3].AtlasPage,$n[0].Single]},{"a":2,"n":"ToRegionAttachment","is":true,"t":8,"pi":[{"n":"sprite","pt":$n[1].Sprite,"ps":0},{"n":"material","pt":$n[1].Material,"ps":1},{"n":"rotation","dv":0.0,"o":true,"pt":$n[0].Single,"ps":2}],"sn":"ToRegionAttachment$2","rt":$n[3].RegionAttachment,"p":[$n[1].Sprite,$n[1].Material,$n[0].Single]},{"a":2,"n":"ToRegionAttachment","is":true,"t":8,"pi":[{"n":"region","pt":$n[3].AtlasRegion,"ps":0},{"n":"attachmentName","pt":$n[0].String,"ps":1},{"n":"scale","dv":0.01,"o":true,"pt":$n[0].Single,"ps":2},{"n":"rotation","dv":0.0,"o":true,"pt":$n[0].Single,"ps":3}],"sn":"ToRegionAttachment","rt":$n[3].RegionAttachment,"p":[$n[3].AtlasRegion,$n[0].String,$n[0].Single,$n[0].Single]},{"a":2,"n":"ToRegionAttachmentPMAClone","is":true,"t":8,"pi":[{"n":"sprite","pt":$n[1].Sprite,"ps":0},{"n":"materialPropertySource","pt":$n[1].Material,"ps":1},{"n":"textureFormat","dv":4,"o":true,"pt":$n[1].TextureFormat,"ps":2},{"n":"mipmaps","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3},{"n":"rotation","dv":0.0,"o":true,"pt":$n[0].Single,"ps":4}],"sn":"ToRegionAttachmentPMAClone","rt":$n[3].RegionAttachment,"p":[$n[1].Sprite,$n[1].Material,$n[1].TextureFormat,$n[0].Boolean,$n[0].Single]},{"a":2,"n":"ToRegionAttachmentPMAClone","is":true,"t":8,"pi":[{"n":"sprite","pt":$n[1].Sprite,"ps":0},{"n":"shader","pt":$n[1].Shader,"ps":1},{"n":"textureFormat","dv":4,"o":true,"pt":$n[1].TextureFormat,"ps":2},{"n":"mipmaps","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3},{"n":"materialPropertySource","dv":null,"o":true,"pt":$n[1].Material,"ps":4},{"n":"rotation","dv":0.0,"o":true,"pt":$n[0].Single,"ps":5}],"sn":"ToRegionAttachmentPMAClone$1","rt":$n[3].RegionAttachment,"p":[$n[1].Sprite,$n[1].Shader,$n[1].TextureFormat,$n[0].Boolean,$n[1].Material,$n[0].Single]}]}; }, $n);
    /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions end.*/

    }});
